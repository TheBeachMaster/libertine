set -o errexit +o hashall

function linkOrCopyFile()
{
	local -r mirrorName="$1"
	local -r relativePath="$2"
	local -r toPath="$3"
	local -r fileName="$4"
	
	if [ "$toPath" = "/dev/null" ]; then
		return
	fi
	
	local -r downloadFilePath="$lfsDownloadsPath"/"$mirrorName"/"$relativePath"
	local -r linkTo="$toPath"/"$fileName"
	
	if [ ! -f "$linkTo" ]; then
		rm -rf -- "$linkTo"
		# Try to hard link, then copy
		ln --force "$downloadFilePath" "$linkTo" || cp --force "$downloadFilePath" "$linkTo"
	fi
}

# metalink in the latest curl (7.29.0) and wget (1.15, not released) allows parallel downloading and fail-over and obsoletes mirrorNames logic
function downloadFileAndCheckHash()
{
	if [ $# -ne 8 ]; then
		exitError "Needs 8 arguments"
	fi
	
	local -r downloadName="$1"
	local -r mirrorName="$2"
	local -r relativePath="$3"
	local -r toPath="$4"
	local -r fileName="$5"
	local -r decompressionOption="$6"
	local -r hashesMayBeEmpty="$7"
	local -r hashes="$8"
	
	local -r url="${mirrors_Url["${mirrorName}"]}${relativePath}"
	local -i exitCode
	
	mkdir -m 0755 -p "$downloadsLogsPath"
	
	local -r downloadFilePath="$lfsDownloadsPath"/"$mirrorName"/"$relativePath"
	local -r downloadFileName="$(purebash_basename "$downloadFilePath")"
	local -r downloadFolderPath="$(purebash_dirname "$downloadFilePath")"
	if [ ! -d "$downloadFolderPath" ]; then
		rm -rf -- "$downloadFolderPath"
	fi
	mkdir -m 0755 -p "$downloadFolderPath"
	
	# Extracts file path - currently only used by linux package / HKP_UNCOMPRESSED
	local -r extractsFilePath="$lfsExtractsPath"/"$mirrorName"/"$relativePath".decompressed
	local -r extractsFolderPath="$(purebash_dirname "$extractsFilePath")"
	
	if [ -f "$extractsFilePath" ]; then
		progressMessage "Using cached extracted $downloadName $url at $extractsFilePath"
		progressMessageSucceeded
	elif [ -f "$downloadFilePath" ]; then
		rm -rf -- "$extractsFilePath"
		linkOrCopyFile "$mirrorName" "$relativePath" "$toPath" "$fileName"
		
		progressMessage "Using cached $downloadName $url at $downloadFilePath"
		progressMessageSucceeded
	else
		progressMessage "Downloading $downloadName $url to $toPath/$fileName"
		
		rm -rf -- "$downloadFilePath"
		rm -rf -- "$extractsFilePath"
		
		# We re-load the config after specifying our options
		touch "$HOME"/.curlrc
		
		# Only enabled compression for uncompressed files, because a few badly configured servers (eg http://www.multiprecision.org/mpc/download/mpc-1.0.1.tar.gz) then stream the non-gz tarball
		if [ -z "$decompressionOption" ]; then
			local -r curlCompressionOption="--compressed "
		else
			local -r curlCompressionOption=""
		fi
		
		local -r referer="$(dirname "$url")/"
		
		local certificateAuthorityName="${mirrors_CertificateAuthority["${mirrorName}"]}"
		if [ -z "$certificateAuthorityName" ]; then
			# Unless ssl hashing has occurred, capath will not reference any certificate authorities
			local -ar certificateAuthorityOption=("--insecure" "--capath" "$certificateAuthoritiesPath")
		else
			if [ "${certificateAuthorities_Parent["${certificateAuthorityName}"]}" = "root" ]; then
				local -r certificateAuthorityBundle="$certificateAuthoritiesPath"/"${certificateAuthorities_FileName["${certificateAuthorityName}"]}"
			else
				temporaryFileToRemoveOnExit
				local -r certificateAuthorityBundle="$TMP_FILE"
				
				while [ "$certificateAuthorityName" != "root" ]
				do
					cat "$certificateAuthoritiesPath"/"${certificateAuthorities_FileName["${certificateAuthorityName}"]}" >>"$certificateAuthorityBundle"
					certificateAuthorityName="${certificateAuthorities_Parent["${certificateAuthorityName}"]}"
				done
			fi
			local -ar certificateAuthorityOption=("--capath" "$certificateAuthoritiesPath" "--cacert" "$certificateAuthorityBundle")
		fi
		
		set +e
		curl --fail --silent --show-error \
		--user-agent "lfs/${LFS_DISTRIBUTION_VERSION}" --referer "${referer};auto" \
		--location --max-redirs 5 --retry 20 \
		--anyauth --netrc-optional --tlsv1 "${certificateAuthorityOption[@]}" \
		${curlCompressionOption}--remote-time \
		--dump-header "$downloadsLogsPath"/"$fileName".headers.log \
		--trace-time --trace-ascii "$downloadsLogsPath"/"$fileName".trace-ascii.log \
		--stderr "$downloadsLogsPath"/"$fileName".stderr.log \
		--write-out '%{url_effective}\t%{http_code}\t%{ssl_verify_result}\t%{http_connect}\t%{time_total}\t%{size_download}\t%{speed_download}\t%{num_redirects}\n' \
		--config "$HOME"/.curlrc \
		--url "$url" --output "$downloadFilePath" \
		1>"$downloadsLogsPath"/"$fileName".stdout.log
		exitCode=$?
		set -e
		if [ $exitCode -ne 0 ]; then
			progressMessageFailed "download $downloadName failed, check logs $downloadsLogsPath/$fileName.*.log"
		else
			linkOrCopyFile "$mirrorName" "$relativePath" "$toPath" "$fileName"
			progressMessageSucceeded
		fi
	fi
	
	if [ "$hashesMayBeEmpty" = "yes" ]; then
		if [ ${#hashes} -eq 0 ]; then
			return 0
		fi
	fi
	
	if [ "$skipSignatureChecks" = "yes" ]; then
		return 0
	fi
	
	progressMessage "Verifying $downloadName $url hashes of $downloadFilePath"
	
	local hashNameAndValue
	local hashName
	local hashValue
	local hashSignatureFileName
	local hashProgram
	local -i hasHash=1
	local progressMessage
	local signatureFileName
	local temporaryFolder
	for hashNameAndValue in ${hashes}
	do
		IFS=':' read -r -d$'\n' hashName hashValue hashSignatureFileName <<<"$hashNameAndValue"
		case "$hashName" in
			
			MD5|SHA1|SHA224|SHA256|SHA384|SHA512)
				hashProgram=${hashName,,}sum
				hasHash=0
				if ! verifyHash "$downloadFolderPath" "$downloadFileName" "$hashProgram" "$hashValue"; then
					progressMessageFailed "$hashName hash sum of $downloadName does not match, check logs $downloadsLogsPath/$fileName.$hashProgram.log"
				fi
			;;
			
			KEYRING|KEYFILE|HKP|HKP_UNCOMPRESSED)
				hasHash=0
				progressMessage="$hashName signature does not match, check logs $downloadsLogsPath/$fileName.${hashName,,}.log"
				if [ -z "$hashSignatureFileName" ]; then
					signatureFileName="$fileName".sig
				else
					signatureFileName="$hashSignatureFileName"
				fi
				
				case "$hashName" in
					KEYRING)
						if ! verifyKeyringSignature "$downloadFolderPath" "$downloadFileName" "$hashValue" "$signatureFileName" "no"; then
							progressMessageFailed "$progressMessage"
						fi
					;;
			
					KEYFILE)
						if ! verifyKeyFileSignature "$downloadFolderPath" "$downloadFileName" "$hashValue" "$signatureFileName" "no"; then
							progressMessageFailed "$progressMessage"
						fi
					;;
			
					HKP)
						if ! verifyHkpSignature "$downloadFolderPath" "$downloadFileName" "$hashValue" "$signatureFileName" "no"; then
							progressMessageFailed "$progressMessage"
						fi
					;;
			
					HKP_UNCOMPRESSED)
						if [ ! -f "$extractsFilePath" ]; then
							if [ ! -d "$extractsFolderPath" ]; then
								rm -rf -- "$extractsFolderPath"
							fi
							mkdir -m 0755 -p "$extractsFolderPath"
							rm -rf -- "$extractsFilePath"
							extractFileForSignatureTest "$decompressionOption" "$downloadFilePath" >"$extractsFilePath"
						fi
						
						if ! verifyHkpSignature "$extractsFolderPath" "$(purebash_basename "$extractsFilePath")" "$hashValue" "$signatureFileName" "yes"; then
							progressMessageFailed "$progressMessage"
						fi
					;;
				esac
				
			;;
			
			
			*)
				exitError "Unsupported hash algorithm $hashName for $toPath/$fileName"
			;;
			
		esac
	done
	
	if [ $hasHash -ne 0 ]; then
		progressMessageFailed "no hash algorithms specified"
	fi
	
	progressMessageSucceeded
}

function gpgVerifySignatureUsingKey()
{
	local -r toPath="$1"
	local -r fileName="$2"
	local -r keyFileOrKeyringFilePath="$3"
	local -r signatureFileName="$4"
	local -r isCompressed="$5"
	local -r method="$6"
	
	if [ ! -f "$keyFileOrKeyringFilePath" ]; then
		exitError "$keyFileOrKeyringFilePath does not exist"
	fi
	
	if [ "$isCompressed" = "no" ]; then
		local -r logFileName="$downloadsLogsPath"/"$fileName"."$method".log
	else
		local -r logFileName="$downloadsLogsPath"/"$fileName"."$method"_uncompressed.log
	fi
	
	if [ "$method" != "keyring" ]; then
		
		temporaryFileToRemoveOnExit
		local -r publicKeyring="$TMP_FILE"
		# GPG is badly behaved, and creates a back up file we'll need to remove
		addFileToRemoveOnExit "$publicKeyring"~
		
		temporaryFileToRemoveOnExit
		local -r trustDb="$TMP_FILE"
		cat "$gpghomePath"/trustdb.gpg >>"$trustDb"
		
		# gpg mucks with its trustdb when importing, which is a nuisance
		gpg --no-options --no-greeting --no-permission-warning --no-auto-check-trustdb --no-secmem-warning \
		--no-random-seed-file --ignore-time-conflict \
		--no-verbose --quiet --batch --no-tty --exit-on-status-write-error \
		--lock-never --no-auto-check-trustdb --no-sig-cache \
		--homedir "$gpghomePath" --trustdb-name "$trustDb" \
		--no-default-keyring --secret-keyring secring.gpg \
		--primary-keyring "$publicKeyring" --keyring "$publicKeyring" \
		--import "$keyFileOrKeyringFilePath" </dev/null 1>"$logFileName" 2>&1
		
		local -ir exitCode=$?
		if [ $exitCode -ne 0 ]; then
			return $exitCode
		fi
		
	else
		local -r publicKeyring="$keyFileOrKeyringFilePath"
		local -r trustDb="trustdb.gpg"
	fi
	
	gpg --no-options --no-greeting --no-permission-warning --no-auto-check-trustdb --no-secmem-warning \
	--no-random-seed-file --ignore-time-conflict \
	--no-verbose --quiet --batch --no-tty --exit-on-status-write-error \
	--lock-never --no-auto-check-trustdb --no-sig-cache \
	--homedir "$gpghomePath" --trustdb-name "$trustDb" \
	--no-default-keyring --secret-keyring secring.gpg \
	--primary-keyring "$publicKeyring" --keyring "$publicKeyring" \
	--verify "$signaturesPath"/"$signatureFileName" "$toPath"/"$fileName" </dev/null 1>>"$logFileName" 2>&1
	
	return $?
}

function verifyHash()
{
	local -r toPath="$1"
	local -r fileName="$2"
	local -r hashProgram="$3"
	local -r hashValue="$4"
	
	local -r logFile="$downloadsLogsPath"/"$fileName".$hashProgram.log
	pushd "$toPath">/dev/null
		$hashProgram --check --strict <<<"${hashValue}  ${fileName}" 1>"$logFile" 2>&1
		local -ir exitCode=$?
	popd >/dev/null
	
	return $exitCode
}

function verifyKeyringSignature()
{
	local -r toPath="$1"
	local -r fileName="$2"
	local -r keyring="$3"
	local -r signatureFileName="$4"
	local -r isCompressed="$5"
	
	case "$keyring" in
		
		secring.gpg|trustdb.gpg)
			exitError "The keyring $keyring is not a public keyring"
		;;
		
	esac
	
	if [ "${keyring##*.}" != "gpg" ]; then
		exitError "Keyrings must be gpg - $keyring is not"
	fi
	
	gpgVerifySignatureUsingKey "$1" "$2" "$keyringsPath"/"$keyring" "$4" "$5" "keyring"
}

function verifyKeyFileSignature()
{
	gpgVerifySignatureUsingKey "$1" "$2" "$keysPath"/"$3" "$4" "$5" "key"
}

function verifyHkpSignature()
{
	gpgVerifySignatureUsingKey "$1" "$2" "$keysPath"/"$3" "$4" "$5" "hkp"
}

function extractFileForSignatureTest()
{
	local -r decompressionOption="$1"
	local -r fileToDecompress="$2"
	if [ "$decompressionOption" = "" ]; then
		cat $fileToDecompress
	fi
	
	case "$decompressionOption" in
		gzip|compress)
			gzip --decompress --stdout --no-name --quiet -- "$fileToDecompress"
		;;
		
		bzip2)
			bzip2 --decompress --stdout --quiet -- "$fileToDecompress"
		;;
		
		lzop)
			lzop --decompress --stdout --no-name --quiet -- "$fileToDecompress"
		;;
		
		lzip)
			lzip --decompress --quiet --stdout -- "$fileToDecompress"
		;;
		
		lzma)
			xz --format=lzma --decompress --stdout -- "$fileToDecompress"
		;;
		
		xz)
			xz --decompress --stdout --quiet --quiet -- "$fileToDecompress"
		;;
		
		*)
			exitError "Unknown compression option $decompressionOption"
		;;
	esac
}

function tarExtract()
{
	if [ $# -ne 4 ]; then
		exitError "Not enough arguments"
	fi
	local -r tarball="$1"
	local -r tarballFolder="$2"
	local -r tarballCompression="$3"
	local -r isTarbomb="$4"
	
	rm -rf -- "$tarballFolder"
	
	pushd "$(purebash_dirname "$tarball")" >/dev/null
		
	local -r absoluteTarballPath="$(pwd)"/"$(purebash_basename "$tarball")"
		
	popd >/dev/null
	
	if [ "$isTarbomb" = "tarbomb" ]; then
		if [ $UID -eq $LFS_DEPENDENCY_UID ]; then
			mkdir -m 0755 -p "$tarballFolder"
		else
			sudo -u \#${LFS_DEPENDENCY_UID} -g \#${LFS_DEPENDENCY_GID} -- mkdir -m 0755 -p "$tarballFolder"
		fi
		pushd "$tarballFolder" >/dev/null
	fi
		
		if [ -z "$tarballCompression" ]; then
			local -r compressionOption=""
		else
			local -r compressionOption=" --$tarballCompression"
		fi
		
		if [ $UID -eq $LFS_DEPENDENCY_UID ]; then
			tar --extract --numeric-owner --preserve-permissions --no-same-owner --file "$absoluteTarballPath"${compressionOption}
		else
			sudo -u \#${LFS_DEPENDENCY_UID} -g \#${LFS_DEPENDENCY_GID} -- tar --extract --numeric-owner --preserve-permissions --no-same-owner --file "$absoluteTarballPath"${compressionOption}
		fi
	
	if [ "$isTarbomb" = "tarbomb" ]; then
		popd >/dev/null
	fi
}
