set -o errexit +o hashall

essentialProgramCheck getent awk

# Since this file is source'd inside a function, the declare builtin defaults to making variables local!
declare -irg nobodyUid=$(getent passwd nobody | awk -v FS=: 'NR==1 {print $3}')
declare -irg nogroupGid=$(getent group nogroup | awk -v FS=: 'NR==1 {print $3}')

declare_for_chroot -a previousMirrors

declare_for_chroot -A phase_PreviousRecipes
phase_PreviousRecipes+=(['crosscompiler']="" ['toolchain2']="" ['system']="")
declare_for_chroot -A phase_InstallationOrder

declare_for_chroot -a signatures_Mirror
declare_for_chroot -a signatures_RelativePath
declare_for_chroot -a signatures_FileName
declare_for_chroot -a signatures_Compression

declare_for_chroot -a keyrings_Mirror
declare_for_chroot -a keyrings_RelativePath
declare_for_chroot -a keyrings_FileName
declare_for_chroot -a keyrings_Hashes
declare_for_chroot -a keyrings_Compression

declare_for_chroot -a keys_Mirror
declare_for_chroot -a keys_RelativePath
declare_for_chroot -a keys_FileName
declare_for_chroot -a keys_Hashes
declare_for_chroot -a keys_Compression

declare_for_chroot -A dependency_Phase
declare_for_chroot -A dependency_Name
declare_for_chroot -A dependency_Version
declare_for_chroot -A dependency_RecipeHash
declare_for_chroot -A dependency_IncludeHash
declare_for_chroot -A dependency_SettingsHash
declare_for_chroot -A dependency_UidGid
declare_for_chroot -A dependency_SourcePackageIndices
declare_for_chroot -A dependency_PatchIndices
declare_for_chroot -A dependency_Dependencies
declare_for_chroot -A dependency_Path
declare_for_chroot -A dependency_RecipeSettingsDependencies
declare_for_chroot -A dependency_SkipInstall
declare_for_chroot -A dependency_BinaryInstallPaths
declare_for_chroot -A dependency_OtherwiseExecutableBinaryInstallPaths
declare_for_chroot -A dependency_SetuidBinaryInstallPaths
declare_for_chroot -A dependency_SetgidBinaryInstallPaths

declare_for_chroot -a sourcePackages_Name
declare_for_chroot -a sourcePackages_Version
declare_for_chroot -a sourcePackages_Mirror
declare_for_chroot -a sourcePackages_RelativePath
declare_for_chroot -a sourcePackages_Hashes
declare_for_chroot -a sourcePackages_FileName
declare_for_chroot -a sourcePackages_Compression
declare_for_chroot -a sourcePackages_ExtractedTarballFolder
declare_for_chroot -a sourcePackages_IsTarbomb

declare_for_chroot -a patches_Mirror
declare_for_chroot -a patches_RelativePath
declare_for_chroot -a patches_FileName
declare_for_chroot -a patches_Hashes
declare_for_chroot -a patches_Compression
declare_for_chroot -ai patches_SourcePackageIndex

# Since this file is source'd inside a function, the declare builtin defaults to making variables local!
declare -ig nextSystemUid=-1
declare -ig nextSystemGid=-1
declare -ig nextUserUid=-1
declare -ig nextUserGid=-1

declare_for_chroot -a groups_Name
declare_for_chroot -a groups_Gid
declare_for_chroot -a groups_Members

declare_for_chroot -a users_Name
declare_for_chroot -a users_Gecos
declare_for_chroot -a users_Home
declare_for_chroot -a users_Shell
declare_for_chroot -a users_Uid
declare_for_chroot -a users_Gid

# Since this file is source'd inside a function, the declare builtin defaults to making variables local!
declare -ag earlyPathCommands
declare -ag latePathCommands

function progressMessage()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	SECONDS=0
	printf '%s' "$ourName: $1"
}

function progressMessageUpdate()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	printf '%s' " $1"
}

function progressMessageFailed()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	echo " FAILED (in ${SECONDS}s: $1)"
	exit 1
}

function progressMessageSucceeded()
{
	if [ $# -ne 0 ]; then
		exitError "Too many arguments"
	fi
	echo " PASSED (in ${SECONDS}s)"
}

function dependency_key()
{
	# bash has problems with keys containing non-alphanumerics
	# printf so as to avoid tr replacing a trailing \n (as would happen with a heredoc)
	DependencyKey="$(printf '%s:%s:%s' "$1" "$2" "$3" | tr --complement '[:alpha:][:digit:]' '_')"
}

function signature()
{
	local -r ourMirror="$1"
	local -r originalFileRelativePath="$2"
	local -r ourHashesSpaceSeparated="$3"
	
	local hashNameAndValue
	local hashName
	local hashValue
	local hashSignatureFileName
	local hashSignatureRelativePath
	
	local -i index
	for hashNameAndValue in $ourHashesSpaceSeparated
	do
		IFS=':' read -r -d$'\n' hashName hashValue hashSignatureFileName <<<"$hashNameAndValue"
		case "$hashName" in
			KEYRING|KEYFILE|HKP|HKP_UNCOMPRESSED)
				index=${#signatures_Mirror[@]}
				
				if [ -z "$hashSignatureFileName" ]; then
					hashSignatureFileName="$(purebash_basename "$originalFileRelativePath".sig)"
				fi
				hashSignatureRelativePath="$(purebash_dirname "$originalFileRelativePath")"/"$hashSignatureFileName"
				
				signatures_Mirror[$index]="$ourMirror"
				signatures_RelativePath[$index]="$hashSignatureRelativePath"
				signatures_FileName[$index]="$hashSignatureFileName"
				signatures_Compression[$index]=""
				
				case "$hashName" in
					HKP|HKP_UNCOMPRESSED)
						hkp "$hashValue"
					;;
				esac
			;;
		esac
	done
}

function keyring()
{
	if [ $# -ne 3 ]; then
		exitError "Not exactly 3 arguments"
	fi
	
	local -r ourMirror="$1"
	local -r ourRelativePath="$2"
	local -r ourHashes="$3"
	local -r ourFileName="$(purebash_basename "$ourRelativePath")"
	
	if [ "${ourFileName##*.}" != "gpg" ]; then
		exitError "Only gpg keyrings are supported - which is not so for this keyring: $ourMirror $ourRelativePath"
	fi
	
	local -i index
	for index in ${!keyrings_FileName[@]}
	do
		if [ "${keyrings_FileName[$index]}" = "$ourFileName" ]; then
			if [ "${keyrings_Mirror[$index]}" != "$ourMirror" ]; then
				exitError "Attempt to override mirror for keyring $ourFileName to $ourMirror"
			fi
			if [ "${keyrings_RelativePath[$index]}" != "$ourRelativePath" ]; then
				exitError "Attempt to override mirror for keyring $ourFileName to $ourRelativePath"
			fi
			return 0
		fi
	done
	
	index=${#keyrings_Mirror[@]}
	keyrings_Mirror+=("$ourMirror")
	keyrings_RelativePath+=("$ourRelativePath")
	keyrings_FileName+=("$ourFileName")
	keyrings_Hashes+=("${ourHashes//,/ }")
	keyrings_Compression+=("")
	
	signature "$ourMirror" "$ourRelativePath" "${keyrings_Hashes[$index]}"
}

function key()
{
	if [ $# -lt 3 ]; then
		exitError "Not 3 or 4 arguments"
	fi
	if [ $# -gt 4 ]; then
		exitError "Not 3 or 4 arguments"
	fi
	
	local -r ourMirror="$1"
	local -r ourRelativePath="$2"
	
	local -r ourHashes="$3"
	if [ $# -eq 3 ]; then
		local -r ourFileName="$(purebash_basename "$ourRelativePath")"
	else
		local -r ourFileName="$4"
	fi
	
	local -i index
	for index in ${!keys_FileName[@]}
	do
		if [ "${keys_FileName[$index]}" = "$ourFileName" ]; then
			if [ "${keys_Mirror[$index]}" != "$ourMirror" ]; then
				exitError "Attempt to override mirror for key $ourFileName to $ourMirror"
			fi
			if [ "${keys_RelativePath[$index]}" != "$ourRelativePath" ]; then
				exitError "Attempt to override mirror for key $ourFileName to $ourRelativePath"
			fi
			return 0
		fi
	done
	
	index=${#keys_Mirror[@]}
	keys_Mirror+=("$ourMirror")
	keys_RelativePath+=("$ourRelativePath")
	keys_FileName+=("$ourFileName")
	keys_Hashes+=("${ourHashes//,/ }")
	keys_Compression+=("")
	
	signature "$ourMirror" "$ourRelativePath" "${keys_Hashes[$index]}"
}

function hkp()
{
	if [ $# -ne 1 ]; then
		exitError "Not 1 argument"
	fi
	local -r keyId="$1"
	
	key HKPS "$keyId" "" "$keyId"
}

function skip_install()
{
	local -r ourRecipeName="$LFS_RECIPE_NAME"
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"

	dependency_key "$LFS_PHASE" "$ourRecipeName" "$ourRecipeVersion"
	
	local phase
	for phase in "$@"
	do
		if [ "$phase" = "$LFS_PHASE" ]; then
			dependency_SkipInstall["$DependencyKey"]="1"
			return 0
		fi
	done
}

function source_package_alias()
{
	if [ $# -ne 2 ]; then
		exitError "Not 2 arguments"
	fi
	
	if [ -z "$LFS_SOURCE_PACKAGE_NAME" ]; then
		local -r ourSourcePackageName="$LFS_RECIPE_NAME"
		local -r ourRecipeName="$ourSourcePackageName"
	else
		local -r ourSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
		local -r ourRecipeName="$LFS_RECIPE_NAME"
	fi
	
	if [ -z "$LFS_SOURCE_PACKAGE_VERSION" ]; then
		local -r ourSourcePackageVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
		local -r ourRecipeVersion="$ourSourcePackageVersion"
	else
		local -r ourSourcePackageVersion="$LFS_SOURCE_PACKAGE_VERSION"
		local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	fi
	
	local -r aliasSourcePackageName="$1"
	local -r aliasSourcePackageVersion="$2"
	
	dependency_key "$LFS_PHASE" "$ourRecipeName" "$ourRecipeVersion"
	
	local -i index
	for index in ${!sourcePackages_Name[@]}
	do
		if [ "${sourcePackages_Name[$index]}" = "$aliasSourcePackageName" ]; then
			if [ "${sourcePackages_Version[$index]}" = "$aliasSourcePackageVersion" ]; then
				local -r existingSourcePackageIndices="${dependency_SourcePackageIndices["$DependencyKey"]}"
				if [ -z "$existingSourcePackageIndices" ]; then
					dependency_SourcePackageIndices["$DependencyKey"]="$index"
				else
					dependency_SourcePackageIndices["$DependencyKey"]="$existingSourcePackageIndices $index"
				fi
				return 0
			fi
		fi
	done
	
	exitError "Unknown aliased source package $aliasSourcePackageName $aliasSourcePackageVersion"
}

function source_package()
{
	if [ $# -lt 3 ]; then
		exitError "Not enough arguments"
	elif [ $# -gt 6 ]; then
		exitError "Too many arguments"
	fi
	
	if [ -z "$LFS_SOURCE_PACKAGE_NAME" ]; then
		local -r ourSourcePackageName="$LFS_RECIPE_NAME"
		local -r ourRecipeName="$ourSourcePackageName"
	else
		local -r ourSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
		local -r ourRecipeName="$LFS_RECIPE_NAME"
	fi
	
	if [ -z "$LFS_SOURCE_PACKAGE_VERSION" ]; then
		local -r ourSourcePackageVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
		local -r ourRecipeVersion="$ourSourcePackageVersion"
	else
		local -r ourSourcePackageVersion="$LFS_SOURCE_PACKAGE_VERSION"
		local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	fi
	
	local -r ourMirror="$1"
	local -r ourRelativePath="$2"
	local -r ourHashes="$3"
	local -r ourFileName="$(purebash_basename "$ourRelativePath")"
	
	local -r compressionExtension="${ourFileName##*.}"
	
	if [ $# -ge 4 ]; then
		local -r ourExtractedTarballFolder="$4"
	else
		local -r withoutCompressionExtension="${ourFileName%.*}"
		if [ -z "$compressionExtension" ]; then
			local -r ourExtractedTarballFolder="$withoutCompressionExtension"
		else
			case "$compressionExtension" in
				
				# The various abominations are also slackware packages (txz, tgz especially)
				tar|tgz|tbz|tbz2|txz|tlz|tlzma|tz|taz)
					local -r ourExtractedTarballFolder="$withoutCompressionExtension"
				;;
				
				*)
					local -r ourExtractedTarballFolder="${withoutCompressionExtension%.*}"
				;;
				
			esac
		fi
	fi
	
	if [ $# -ge 5 ]; then
		local -r ourCompression="$5"
	else
		case "$compressionExtension" in
			tar)
				local -r ourCompression=''
			;;
			
			gz|tgz)
				local -r ourCompression=gzip
			;;
			
			bz2|bz|tbz2|tbz)
				local -r ourCompression=bzip2
			;;
			
			# Not included in dependencies by default
			# A faster compressor still is lz4
			lzo)
				local -r ourCompression=lzop
			;;
			
			lz|tlz)
				local -r ourCompression=lzip
			;;
			
			lzma|tlzma)
				local -r ourCompression=lzma
			;;
			
			xz|txz)
				local -r ourCompression=xz
			;;
			
			Z|tz|taz)
				# eg gzip downloads
				local -r ourCompression=compress
			;;
			
			*)
				if [ ! -z "$compressionExtension" ]; then
					exitError "Unknown file extension $compressionExtension for $ourSourcePackageName $ourSourcePackageVersion"
				fi
			;;
		esac
	fi
	
	if [ $# -ge 6 ]; then
		local -r isTarbomb="$6"
	else
		local -r isTarbomb="no"
	fi
	
	dependency_key "$LFS_PHASE" "$ourRecipeName" "$ourRecipeVersion"
	local -i index
	for index in ${!sourcePackages_Name[@]}
	do
		if [ "${sourcePackages_Name[$index]}" = "$ourSourcePackageName" ]; then
			if [ "${sourcePackages_Version[$index]}" = "$ourSourcePackageVersion" ]; then
				local -r existingSourcePackageIndices="${dependency_SourcePackageIndices["$DependencyKey"]}"
				if [ -z "$existingSourcePackageIndices" ]; then
					dependency_SourcePackageIndices["$DependencyKey"]="$index"
				else
					dependency_SourcePackageIndices["$DependencyKey"]="$existingSourcePackageIndices $index"
				fi
				return 0
			fi
		fi
	done
	
	index=${#sourcePackages_Name[@]}

	local -r existingSourcePackageIndices="${dependency_SourcePackageIndices["$DependencyKey"]}"
	if [ -z "$existingSourcePackageIndices" ]; then
		dependency_SourcePackageIndices["$DependencyKey"]="$index"
	else
		dependency_SourcePackageIndices["$DependencyKey"]="$existingSourcePackageIndices $index"
	fi
	
	sourcePackages_Name+=("$ourSourcePackageName")
	sourcePackages_Version+=("$ourSourcePackageVersion")
	
	sourcePackages_Mirror+=("$ourMirror")
	sourcePackages_RelativePath+=("$ourRelativePath")
	sourcePackages_Hashes+=("${ourHashes//,/ }")
	sourcePackages_Compression+=("$ourCompression")
	sourcePackages_FileName+=("$ourFileName")
	sourcePackages_ExtractedTarballFolder+=("$ourExtractedTarballFolder")
	sourcePackages_IsTarbomb+=("$isTarbomb")
	signature "$ourMirror" "$ourRelativePath" "${sourcePackages_Hashes[$index]}"
}

function source_patch()
{
	if [ $# -ne 3 ]; then
		exitError "Not enough arguments"
	fi
	
	if [ -z "$LFS_SOURCE_PACKAGE_NAME" ]; then
		local -r ourSourcePackageName="$LFS_RECIPE_NAME"
	else
		local -r ourSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
	fi
	
	if [ -z "$LFS_SOURCE_PACKAGE_VERSION" ]; then
		local -r ourSourcePackageVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	else
		local -r ourSourcePackageVersion="$LFS_SOURCE_PACKAGE_VERSION"
	fi
	
	local -r ourMirror="$1"
	local -r ourRelativePath="$2"
	local -r ourHashes="$3"
	local -r ourFileName="$(purebash_basename "$ourRelativePath")"

	local -i sourcePackageIndex=-1
	for index in ${!sourcePackages_Name[@]}
	do
		if [ "$ourSourcePackageName" = "${sourcePackages_Name[$index]}" ]; then
			if [ "$ourSourcePackageVersion" = "${sourcePackages_Version[$index]}" ]; then
				sourcePackageIndex=$index
				break
			fi
		fi
	done
	
	if [ $sourcePackageIndex -eq -1 ]; then
		exitError "Patch is for unknown source package $ourSourcePackageName $ourSourcePackageVersion"
	fi
	
	dependency_key "$LFS_PHASE" "$ourSourcePackageName" "$ourSourcePackageVersion"
	local -r existingPatchIndices="${dependency_PatchIndices["$DependencyKey"]}"
	local -i index
	for index in ${!patches_RelativePath[@]}
	do
		if [ "${patches_RelativePath[$index]}" = "$ourRelativePath" ]; then
			if [ "${patches_Mirror[$index]}" = "$ourMirror" ]; then
				if [ -z "$existingPatchIndices" ]; then
					dependency_PatchIndices["$DependencyKey"]="$index"
				else
					dependency_PatchIndices["$DependencyKey"]="$existingPatchIndices $index"
				fi
				return 0
			fi
		fi
	done
	
	index=${#patches_Mirror[@]}
	patches_Mirror+=("$ourMirror")
	patches_FileName+=("$ourFileName")
	patches_RelativePath+=("$ourRelativePath")
	patches_Hashes+=("${ourHashes//,/ }")
	patches_Compression+=("")
	patches_SourcePackageIndex+=($sourcePackageIndex)
	
	if [ -z "$existingPatchIndices" ]; then
		dependency_PatchIndices["$DependencyKey"]="$index"
	else
		dependency_PatchIndices["$DependencyKey"]="$existingPatchIndices $index"
	fi
	
	signature "$ourMirror" "$ourRelativePath" "${patches_Hashes[$index]}"
}

function version()
{
	if [ $# -ne 1 ]; then
		exitError "Needs 1 argument"
	fi
	local -r ourRecipeVersion="$1"
	
	local -r previousVersions="${LFS_RECIPE_VERSIONS["${LFS_RECIPE_NAME}"]}"
	if [ -z "$previousVersions" ]; then
		LFS_RECIPE_VERSIONS["${LFS_RECIPE_NAME}"]="$ourRecipeVersion"
	else
		LFS_RECIPE_VERSIONS["${LFS_RECIPE_NAME}"]="$previousVersions $ourRecipeVersion"
	fi
	LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]="$ourRecipeVersion"
	
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	dependency_Phase["$DependencyKey"]="$LFS_PHASE"
	dependency_Name["$DependencyKey"]="$LFS_RECIPE_NAME"
	dependency_Version["$DependencyKey"]="$ourRecipeVersion"
	dependency_RecipeHash["$DependencyKey"]="$LFS_RECIPE_HASH"
	dependency_IncludeHash["$DependencyKey"]="$LFS_RECIPE_INCLUDE_HASH"
	dependency_SettingsHash["$DependencyKey"]="$LFS_RECIPE_SETTINGS_HASH"
	dependency_UidGid["$DependencyKey"]="$LFS_RECIPE_UIDGID"
	dependency_SourcePackageIndices["$DependencyKey"]=""
	dependency_PatchIndices["$DependencyKey"]=""
	dependency_Dependencies["$DependencyKey"]=""
	dependency_Path["$DependencyKey"]=""
	dependency_RecipeSettingsDependencies["$DependencyKey"]=""
	dependency_SkipInstall["$DependencyKey"]="0"
	dependency_BinaryInstallPaths["$DependencyKey"]=""
	dependency_OtherwiseExecutableBinaryInstallPaths["$DependencyKey"]=""
	dependency_SetuidBinaryInstallPaths["$DependencyKey"]=""
	dependency_SetgidBinaryInstallPaths["$DependencyKey"]=""
	
	if [ "$LFS_RECIPE_INCLUDE_HASH" != "0" ]; then
		include "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	fi
}

function include()
{
	if [ $# -ne 2 ]; then
		exitError "Needs 2 arguments"
	fi
	
	local -r includeSourcePackageName="$1"
	local -r includeSourcePackageVersion="$2"
	
	local includeFile="$includesPath"/"$includeSourcePackageName".include
	if [ ! -f "$includeFile" ]; then
		exitError "No include $includeSourcePackageName known in recipe $LFS_RECIPE_NAME"
	fi
	
	LFS_SOURCE_PACKAGE_NAME="$includeSourcePackageName" LFS_SOURCE_PACKAGE_VERSION="$includeSourcePackageVersion" source "$includeFile"
}

function depends()
{
	if [ $# -ne 1 ]; then
		exitError "Needs 1 argument"
	fi
	local -r localSourcePackageName="$1"
	
	local -i alreadySourced=0
	local previousRecipe
	for previousRecipe in ${phase_PreviousRecipes["${LFS_PHASE}"]}
	do
		if [ "$previousRecipe" = "$localSourcePackageName" ]; then
			alreadySourced=1
			break
		fi
	done
	
	if [ $alreadySourced -eq 0 ]; then
		
		local -r recipeFile="$recipesPath"/"$LFS_PHASE"/"$localSourcePackageName".recipe
		
		if [ ! -f "$recipeFile" ]; then
			exitError "recipe $localSourcePackageName ($recipeFile) does not exist or is not a file"
		fi
		
		# Prevent recursion
		phase_PreviousRecipes["${LFS_PHASE}"]="${phase_PreviousRecipes["${LFS_PHASE}"]} $localSourcePackageName"
	
		# set / unset inside includeLeafRecipe
		# Set to blank to avoid bash's associative array bugs with non-existent members (it aliases the last added member)
		LFS_RECIPE_VERSIONS["${localSourcePackageName}"]=""
		
		# Holds the last set version
		LFS_RECIPE_VERSION["${localSourcePackageName}"]=""
		
		local settingsFile="$settingsPath"/"$LFS_PHASE"/"$localSourcePackageName".settings
		if [ -f "$settingsFile" ]; then
			local -r settingsHash="$(sha256sum "$settingsFile" | awk 'NR==1 {print $1}')"
			LFS_RECIPE_NAME="$localSourcePackageName" source "$settingsFile"
		else
			local -r settingsHash="0"
		fi
		
		local includeFile="$includesPath"/"$localSourcePackageName".include
		if [ -f "$includeFile" ]; then
			local -r includeHash="$(sha256sum "$includeFile" | awk 'NR==1 {print $1}')"
		else
			local -r includeHash="0"
			includeFile=""
		fi
		
		local userAndGroupName=lfs-"$localSourcePackageName"
		
		local uidAndGid="$(grep -G "^${localSourcePackageName} " "$recipesPackageUidFile" | awk '{print $2}')"
		if [ -z "$uidAndGid" ]; then
			exitError "Undefined package uid for $localSourcePackageName"
		fi
		
		local -i create=1
		local group
		for group in ${groups_Name[@]}
		do
			if [ "$group" = "$userAndGroupName" ]; then
				create=0
			fi
		done
		
		if [ $create -eq 1 ]; then
			system_group "$userAndGroupName" $uidAndGid
			user "$userAndGroupName" "$userAndGroupName" /dev/null /bin/false $uidAndGid "$userAndGroupName"
		fi
		
		# Weirdly, but usefully, a source'd file has access to our local variables AND can mutate them (it does not run a subshell or stack scope)
		# BUT, and here's the BUT, they won't get passed down to any functions!
		LFS_RECIPE_NAME="$localSourcePackageName" LFS_RECIPE_HASH="$(sha256sum "$recipeFile" | awk 'NR==1 {print $1}')" LFS_RECIPE_INCLUDE_HASH="$includeHash" LFS_RECIPE_SETTINGS_HASH="$settingsHash" LFS_RECIPE_UIDGID=$uidAndGid source "$recipeFile"
	fi
	
	# We currently only do this for the last set version. In future, we might be able to take a directive from above
	# if depends bash is called, which does version 4.2, depends gcc, version 2.5, then once back in 'depends bash':-
	#  LFS_RECIPE_NAME is blank
	# "${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"   is 4.2
	#  localSourcePackageName is gcc
	# "${LFS_RECIPE_VERSION["${localSourcePackageName}"]}"   is 2.5
	
	# Add to parent's dependencies
	# LFS_RECIPE_NAME will be blank for the package listed in the profile
	dependency_key "$LFS_PHASE" "$localSourcePackageName" "${LFS_RECIPE_VERSION["${localSourcePackageName}"]}"
	local -r child="$DependencyKey"
	
	if [ ! -z "$LFS_RECIPE_NAME" ]; then
		dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
		local -r parent="$DependencyKey"
		local -r dependencies="${dependency_Dependencies["$parent"]}"
		if [ -z "$dependencies" ]; then
			dependency_Dependencies["$parent"]="$child"
		else
			dependency_Dependencies["$parent"]="$dependencies $child"
		fi
	fi
	
	local existingInstall
	for existingInstall in "${phase_InstallationOrder["${LFS_PHASE}"]}"
	do
		if [ "$existingInstall" = "$child" ]; then
			return 0
		fi
	done
	
	local -r all="${phase_InstallationOrder["${LFS_PHASE}"]}"
	if [ -z "$all" ]; then
		phase_InstallationOrder["${LFS_PHASE}"]="$child"
	else
		phase_InstallationOrder["${LFS_PHASE}"]="$all $child"
	fi
}

function conflicts()
{
	exitError "Unimplemented"
}

function system_group()
{
	local -r groupName="$1"
	if [ $# -eq 2 ]; then
		local -ir proposedGid=$2
	fi
	
	local -i index
	for index in ${!groups_Name[@]}
	do
		if [ "${groups_Name[$index]}" = "$groupName" ]; then
			if [ $# -eq 2 ]; then
				if [ ${groups_Gid[$index]} -ne $proposedGid ]; then
					exitError "mismatch in group gids for $groupName, $gid (is previously defined as ${groups_Gid[$index]})"
				else
					return 0
				fi
			else
				return 0
			fi
		fi
	done
	
	if [ $# -eq 2 ]; then
		local -ir gid=$proposedGid
	else
		if [ $nextSystemGid -eq -1 ]; then
			nextSystemGid=${settings_integer[LFS_INCLUSIVE_SYSTEM_GID]}
		fi
		local -ir gid=$((nextSystemGid++))
	fi
	
	index=${#groups_Name[@]}
	groups_Name[$index]="$groupName"
	groups_Gid[$index]=$gid
	groups_Members[$index]=""
}

function verifyGroupExists()
{
	local -r groupName="$1"
	local -r userName="$2"
	local group
	for group in ${groups_Name[@]}
	do
		if [ "$group" = "$groupName" ]; then
			return 0
		fi
	done
	exitError "Group with name $groupName does exist for user $userName"
}

function user()
{
	local -r userName="$1"
	local -r gecos="$2"
	local -r home="$3"
	local -r shell="$4"
	
	if [ $# -eq 6 ]; then
		verifyGroupExists $6 "$userName"
	fi
	
	local -i index
	for index in ${!users_Name[@]}
	do
		if [ "${users_Name[$index]}" = "$userName" ]; then
			if [ "${users_Gecos[$index]}" != "$gecos" ]; then
				exitError "gecos redefined for user $userName"
			fi
			if [ "${users_Home[$index]}" != "$home" ]; then
				exitError "home redefined for user $userName"
			fi
			if [ "${users_Shell[$index]}" != "$shell" ]; then
				exitError "shell redefined for user $userName"
			fi
			if [ $# -ge 5 ]; then
				if [ ${users_Uid[$index]} -ne $5 ]; then
					exitError "uid redefined for user $userName"
				fi
			fi
		fi
	done
	
	if [ $# -ge 5 ]; then
		local -ir uid=$5
	else
		if [ "$shell" = "/bin/false" ]; then
			if [ $nextSystemUid -eq -1 ]; then
				nextSystemUid=${settings_integer[LFS_INCLUSIVE_SYSTEM_UID]}
			fi
		else
			if [ $nextUserId -eq -1 ]; then
				nextUserUid=${settings_integer[LFS_INCLUSIVE_USER_UID]}
			fi
			local -ir uid=$((nextUserUid++))
		fi
	fi
	
	# check uid not already in use
	local -i existingUid
	for existingUid in ${users_Uid[@]}
	do
		if [ $existingUid -eq $uid ]; then
			exitError "uid $uid already exists for user $userName"
		fi
	done
	
	if [ $# -eq 6 ]; then
		local -r groupName="$6"
		local -i gid=-1
		for index in ${!groups_Name[@]}
		do
			if [ "${groups_Name[$index]}" = "$groupName" ]; then
				gid=${groups_Gid[$index]}
				break
			fi
		done
		if [ $gid -eq -1 ]; then
			exitError "Group $groupName not defined for user $userName"
		fi
	else
		if [ "$shell" = "/bin/false" ]; then
			local -ir gid=$((nextSystemGid++))
		else
			if [ $nextUserGid -eq -1 ]; then
				nextUserGid=${settings_integer[LFS_INCLUSIVE_USER_GID]}
			fi
			local -ir gid=$((nextUserGid++))
		fi
	fi
	
	# check gid not already in use
	local -i existingGid
	for existingGid in ${users_Gid[@]}
	do
		if [ $existingGid -eq $gid ]; then
			exitError "gid $gid already exists for user $userName"
		fi
	done
		
	local -r ourSourcePackageName="$LFS_RECIPE_NAME"
	
	index=${#users_Name[@]}
	users_Name[$index]="$userName"
	users_Gecos[$index]="$gecos"
	users_Home[$index]="$home"
	users_Shell[$index]="$shell"
	users_Uid[$index]=$uid
	users_Gid[$index]=$gid
	
	LFS_LAST_UID=$uid
	LFS_LAST_GID=$gid
}

function install_binaries_in_paths()
{
	if [ $# -eq 0 ]; then
		return 0
	fi
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local binaryPath
	local existingPaths
	for binaryPath in "$@"
	do
		if [ -z "$binaryPath" ]; then
			continue
		fi
		
		existingPaths="${dependency_BinaryInstallPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_BinaryInstallPaths["$DependencyKey"]="$binaryPath"
		else
			dependency_BinaryInstallPaths["$DependencyKey"]="$existingPaths $binaryPath"
		fi
	done
}

function make_executable_binary()
{
	if [ $# -eq 0 ]; then
		return 0
	fi
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local binaryPath
	local existingPaths
	for binaryPath in "$@"
	do
		if [ -z "$binaryPath" ]; then
			continue
		fi
		
		existingPaths="${dependency_OtherwiseExecutableBinaryInstallPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_OtherwiseExecutableBinaryInstallPaths["$DependencyKey"]="$binaryPath"
		else
			dependency_OtherwiseExecutableBinaryInstallPaths["$DependencyKey"]="$existingPaths $binaryPath"
		fi
	done
}

function make_setuid_binary()
{
	if [ $# -eq 0 ]; then
		return 0
	fi
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local binaryPath
	local existingPaths
	for binaryPath in "$@"
	do
		if [ -z "$binaryPath" ]; then
			continue
		fi
		
		existingPaths="${dependency_SetuidBinaryInstallPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_SetuidBinaryInstallPaths["$DependencyKey"]="$binaryPath"
		else
			dependency_SetuidBinaryInstallPaths["$DependencyKey"]="$existingPaths $binaryPath"
		fi
	done
}

function make_setgid_binary()
{
	if [ $# -eq 0 ]; then
		return 0
	fi
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local binaryPath
	local existingPaths
	for binaryPath in "$@"
	do
		if [ -z "$binaryPath" ]; then
			continue
		fi
		
		existingPaths="${dependency_SetgidBinaryInstallPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_SetgidBinaryInstallPaths["$DependencyKey"]="$binaryPath"
		else
			dependency_SetgidBinaryInstallPaths["$DependencyKey"]="$existingPaths $binaryPath"
		fi
	done
}

function permissions_after()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	local -r extendedAttributesToApplyFirst="$5"
	local -r extendedAttributesToApplyLast="$6"
	
	if [ "${target:0:1}" != "/" ]; then
		exitError "directory target must be absolute, not $target"
	fi
	
	local -i uid=-1
	for index in ${!users_Name[@]}
	do
		if [ "${users_Name[$index]}" = "$userName" ]; then
			uid=${users_Uid[$index]}
			break
		fi
	done
	if [ $uid -eq -1 ]; then
		exitError "User $userName not defined for target $target"
	fi
	
	local -i gid=-1
	for index in ${!groups_Name[@]}
	do
		if [ "${groups_Name[$index]}" = "$groupName" ]; then
			gid=${groups_Gid[$index]}
			break
		fi
	done
	if [ $gid -eq -1 ]; then
		exitError "Group $groupName not defined for target $target"
	fi
	
	# Listed in reverse-order!
	if [ ! -z "$extendedAttributesToApplyLast" ]; then
		latePathCommands+=("chattr +"\'"$extendedAttributesToApplyLast"\'" -- "\'"${LFS}${target}"\')
	fi
	if [ ! -z "$extendedAttributesToApplyFirst" ]; then
		latePathCommands+=("chattr +"\'"$extendedAttributesToApplyFirst"\'" -- "\'"${LFS}${target}"\')
	fi
	latePathCommands+=("chown $uid:$gid -- "\'"${LFS}${target}"\')
	latePathCommands+=("chmod "\'"$mode"\'" -- "\'"${LFS}${target}"\')
}

function recurse()
{
	local -r target="$1"
	local -ir mindepth=$2
	local -ir maxdepth=$3
	local -r fileTypeCode="$4"
	local -r callback="$5"
	shift 5
	
	find -P "${LFS}${target}" -depth -mindepth $mindepth -maxdepth $maxdepth -type "$fileTypeCode" -print0 | while IFS= read -r -d $'\0' file
	do
		$callback "$file" "$@"
	done
}

function recurse_callback_permissions()
{
	local -r target="$1"
	local -r mode="$2"
	local -r uid=$3
	local -r gid=$4
	local -r extendedAttributesToApplyFirst="$5"
	local -r extendedAttributesToApplyLast="$6"
	
	chmod "$mode" -- "$target"
	chown $uid:$gid -- "$target"
	if [ ! -z "$extendedAttributesToApplyFirst" ]; then
		chattr +"$extendedAttributesToApplyFirst" "$target"
	fi
	if [ ! -z "$extendedAttributesToApplyLast" ]; then
		chattr +"$extendedAttributesToApplyLast" "$target"
	fi
}

function permissions_after_recursive()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	local -r extendedAttributesToApplyFirst="$5"
	local -r extendedAttributesToApplyLast="$6"
	local -ir mindepth=$7
	local -ir maxdepth=$8
	# eg directory => d, file => f
	local -r fileTypeCode="${9:0:1}"
	
	if [ "${target:0:1}" != "/" ]; then
		exitError "directory target must be absolute, not $target"
	fi
	
	local -i uid=-1
	for index in ${!users_Name[@]}
	do
		if [ "${users_Name[$index]}" = "$userName" ]; then
			uid=${users_Uid[$index]}
			break
		fi
	done
	if [ $uid -eq -1 ]; then
		exitError "User $userName not defined for target $target"
	fi
	
	local -i gid=-1
	for index in ${!groups_Name[@]}
	do
		if [ "${groups_Name[$index]}" = "$groupName" ]; then
			gid=${groups_Gid[$index]}
			break
		fi
	done
	if [ $gid -eq -1 ]; then
		exitError "Group $groupName not defined for target $target"
	fi
	
	latePathCommands+=("recurse "\'"$target"\'" $mindepth $maxdepth "\'"$fileTypeCode"\'" recurse_callback_permissions "\'"$mode"\'" $uid $gid "\'"$extendedAttributesToApplyFirst"\'" "\'"$extendedAttributesToApplyLast"\')
}

function permissions_before()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	local -r extendedAttributesToApplyFirst="$5"
	
	if [ "${target:0:1}" != "/" ]; then
		exitError "directory target must be absolute, not $target"
	fi
	
	local -i uid=-1
	for index in ${!users_Name[@]}
	do
		if [ "${users_Name[$index]}" = "$userName" ]; then
			uid=${users_Uid[$index]}
			break
		fi
	done
	if [ $uid -eq -1 ]; then
		exitError "User $userName not defined for target $target"
	fi
	
	local -i gid=-1
	for index in ${!groups_Name[@]}
	do
		if [ "${groups_Name[$index]}" = "$groupName" ]; then
			gid=${groups_Gid[$index]}
			break
		fi
	done
	if [ $gid -eq -1 ]; then
		exitError "Group $groupName not defined for target $target"
	fi
	
	earlyPathCommands+=("chmod "\'"$mode"\'" -- "\'"${LFS}${target}"\')
	earlyPathCommands+=("chown $uid:$gid -- "\'"${LFS}${target}"\')
	if [ ! -z "$extendedAttributesToApplyFirst" ]; then
		earlyPathCommands+=("chattr +"\'"$extendedAttributesToApplyFirst"\'" -- "\'"${LFS}${target}"\')
	fi
}

function directory()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	local -r extendedAttributesToApplyFirst="$5"
	local -r extendedAttributesToApplyLast="$6"
	
	permissions_after "$target" "$mode" "$userName" "$groupName" "$extendedAttributesToApplyFirst" "$extendedAttributesToApplyLast"
	
	earlyPathCommands+=("mkdir -p -m "\'"$mode"\'" -- "\'"${LFS}${target}"\')
	
	permissions_before "$target" "$mode" "$userName" "$groupName" "$extendedAttributesToApplyFirst"
}

function symlink()
{
	local -r target="$1"
	local -r contents="$2"
	if [ "${target:0:1}" != "/" ]; then
		exitError "symlink target must be absolute, not $target"
	fi
	
	earlyPathCommands+=("ln -s "\'"$contents"\'" "\'"${LFS}${target}"\')
}

function touch_file()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	local -r extendedAttributesToApplyFirst="$5"
	local -r extendedAttributesToApplyLast="$6"
	
	permissions_after "$target" "$mode" "$userName" "$groupName" "$extendedAttributesToApplyFirst" "$extendedAttributesToApplyLast"
	
	earlyPathCommands+=("touch "\'"${LFS}${target}"\')
	
	permissions_before "$target" "$mode" "$userName" "$groupName" "$extendedAttributesToApplyFirst"
}

function make_character_device()
{
	local -r target="$1"
	local -r deviceMajor="$2"
	local -r deviceMinor="$3"
	local -r mode="$4"
	local -r userName="$5"
	local -r groupName="$6"
	
	permissions_after "$target" "$mode" "$userName" "$groupName" "" ""
	
	earlyPathCommands+=("mknod -m "\'"$mode"\'" "\'"${LFS}${target}"\'" c "\'"$deviceMajor"\'" "\'"$deviceMinor"\')
	
	permissions_before "$target" "$mode" "$userName" "$groupName" ""
}

function make_block_device()
{
	local -r target="$1"
	local -r deviceMajor="$2"
	local -r deviceMinor="$3"
	local -r mode="$4"
	local -r userName="$5"
	local -r groupName="$6"
	
	permissions_after "$target" "$mode" "$userName" "$groupName" "" ""
	
	earlyPathCommands+=("mknod -m "\'"$mode"\'" "\'"${LFS}${target}"\'" b "\'"$deviceMajor"\'" "\'"$deviceMinor"\')
	
	permissions_before "$target" "$mode" "$userName" "$groupName" ""
}

function make_fifo()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	
	permissions_after "$target" "$mode" "$userName" "$groupName" "" ""
	
	earlyPathCommands+=("mknod -m "\'"$mode"\'" "\'"${LFS}${target}"\'" p")
	
	permissions_before "$target" "$mode" "$userName" "$groupName" ""
}

function include_mirror()
{
	if [ $# -ne 1 ]; then
		exitError "Not exactly 1 argument"
	fi
	
	local -r localMirror="$1"
	
	local previousMirror
	for previousMirror in "${previousMirrors[@]}"
	do
		if [ "$previousMirror" = "$localMirror" ]; then
			exitError "Recursion of mirrors - trying to use $localMirror after mirror stack of $previousMirrors"
		fi
	done
	previousMirrors+=("$localMirror")
	
	if [ -f "$mirrorsPath"/"$localMirror".mirrors ]; then
		source "$mirrorsPath"/"$localMirror".mirrors
	else
		exitError "mirrors $localMirror.mirrors does not exist in mirrors path $mirrorsPath or is not a file"
	fi
}

function dependencyPath()
{
	local -r dependencyName="$1"
	for dependencyKey in "${!dependency_Name[@]}"
	do
		if [ "${dependency_Name["$dependencyKey"]}" = "$dependencyName" ]; then
			if [ "${dependency_Phase["$dependencyKey"]}" = "$LFS_PHASE" ]; then
				echo -n "${dependency_Path["$dependencyKey"]}"
				return 0
			fi
		fi
	done
}

function installPackagePrototype()
{
	./configure --prefix=/"$LFS_TOOLS" $@
	
	make
	
	#make check
	
	make install
}

function pushdDependencyFolder()
{
	pushd "$LFS_DEPENDENCY_NAME" >/dev/null
}

function popdDepdendencyFolder()
{
	popd >/dev/null
}

function createBuildFolderAndPushd()
{
	local -r buildFolder=../"$LFS_DEPENDENCY_NAME"-build
	mkdir -m 0755 -p "$buildFolder"
	pushd "$buildFolder" >/dev/null
}

function popdBuildFolder()
{
	popd >/dev/null
}

function setLfsSourcePackageVariables()
{
	LFS_SOURCE_PACKAGE_NAME="${sourcePackages_Name[$1]}"
	LFS_SOURCE_PACKAGE_VERSION="${sourcePackages_Version[$1]}"
	LFS_SOURCE_PACKAGE_COMPRESSION="${sourcePackages_Compression[$1]}"
	LFS_SOURCE_PACKAGE_FILENAME="${sourcePackages_FileName[$1]}"
	LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER="${sourcePackages_ExtractedTarballFolder[$1]}"
	LFS_SOURCE_PACKAGE_IS_TARBOMB="${sourcePackages_IsTarbomb[$1]}"
	LFS_SOURCE_PACKAGE_MIRROR="${sourcePackages_Mirror[$1]}"
	LFS_SOURCE_PACKAGE_RELATIVE_PATH="${sourcePackages_RelativePath[$1]}"
}

# Perl (CPAN)
# Python (Pip)
# Ruby (Gem)
# NodeJS (NPM)
# Lua (LuaRocks,LuaDist)
# PHP (PEAR/PECL, PEAR package manager)
# Haskell (Cabal)
# Go (goinstall)
# OCaml (OPAM)
# D (?DUB / http://code.dlang.org/)
# Clojure (?)
# Tcl (?)
# R / GNU S (r-cran)
# Mono (nuget), but not clearly great
# Erlang - not really; uses releases, ie everything bundled up. There is rebar.
# Java - maven sort of, but most applications are designed like Erlang - ship with their required libraries

# Other possibilities
# ttf-* font data
# xfonts
# CA certificates
# ? bad ssh keys
# locale installers
# xmms2 plugins




