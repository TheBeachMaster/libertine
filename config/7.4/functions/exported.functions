set -o errexit +o hashall

declare_for_chroot -a signatures_Mirror
declare_for_chroot -a signatures_RelativePath
declare_for_chroot -a signatures_FileName
declare_for_chroot -a signatures_Compression

declare_for_chroot -a keyrings_Mirror
declare_for_chroot -a keyrings_RelativePath
declare_for_chroot -a keyrings_FileName
declare_for_chroot -a keyrings_Hashes
declare_for_chroot -a keyrings_Compression

declare_for_chroot -a keys_Mirror
declare_for_chroot -a keys_RelativePath
declare_for_chroot -a keys_FileName
declare_for_chroot -a keys_Hashes
declare_for_chroot -a keys_Compression

declare -i nextSystemUid=-1
declare -i nextSystemGid=-1
declare -i nextUserUid=-1
declare -i nextUserGid=-1

declare_for_chroot -a groups_Name
declare_for_chroot -a groups_Gid
declare_for_chroot -a groups_Members

declare_for_chroot -a users_Name
declare_for_chroot -a users_Gecos
declare_for_chroot -a users_Home
declare_for_chroot -a users_Shell
declare_for_chroot -a users_Uid
declare_for_chroot -a users_Gid

declare -a earlyPathCommands
declare -a latePathCommands

declare_for_chroot -a previousMirrors
declare_for_chroot -a previousProfiles

function progressMessage()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	SECONDS=0
	printf '%s' "$ourName: $1"
}

function progressMessageUpdate()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	printf '%s' " $1"
}

function progressMessageFailed()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	echo " FAILED (in ${SECONDS}s: $1)"
	exit 1
}

function progressMessageSucceeded()
{
	if [ $# -ne 0 ]; then
		exitError "Too many arguments"
	fi
	echo " PASSED (in ${SECONDS}s)"
}

function dependency_key()
{
	# bash has problems with keys containing non-alphanumerics
	# printf so as to avoid tr replacing a trailing \n (as would happen with a heredoc)
	DependencyKey="$(printf '%s:%s:%s' "$1" "$2" "$3" | tr --complement '[:alpha:][:digit:]' '_')"
}

function signature()
{
	set -x
	local -r ourMirror="$1"
	local -r originalFileRelativePath="$2"
	local -r ourHashesSpaceSeparated="$3"
	
	local hashNameAndValue
	local hashName
	local hashValue
	local hashSignatureFileName
	local hashSignatureRelativePath
	
	local -i signatureNumber
	for hashNameAndValue in $ourHashesSpaceSeparated
	do
		IFS=':' read -r -d$'\n' hashName hashValue hashSignatureFileName <<<"$hashNameAndValue"
		case "$hashName" in
			KEYRING|KEYFILE|HKP|HKP_UNCOMPRESSED)
				signatureNumber=${#signatures_Mirror[@]}
				
				if [ -z "$hashSignatureFileName" ]; then
					hashSignatureFileName="$(purebash_basename "$originalFileRelativePath".sig)"
				fi
				hashSignatureRelativePath="$(purebash_dirname "$originalFileRelativePath")"/"$hashSignatureFileName"
				
				signatures_Mirror[$signatureNumber]="$ourMirror"
				signatures_RelativePath[$signatureNumber]="$hashSignatureRelativePath"
				signatures_FileName[$signatureNumber]="$hashSignatureFileName"
				signatures_Compression[$signatureNumber]=""
				
				case "$hashName" in
					HKP|HKP_UNCOMPRESSED)
						hkp "$hashValue"
					;;
				esac
			;;
		esac
	done
	set +x
}

function keyring()
{
	if [ $# -ne 3 ]; then
		exitError "Not exactly 3 arguments"
	fi
	
	local -r ourMirror="$1"
	local -r ourRelativePath="$2"
	local -r ourHashes="$3"
	local -r ourFileName="$(purebash_basename "$ourRelativePath")"
	
	if [ "${ourFileName##*.}" != "gpg" ]; then
		exitError "Only gpg keyrings are supported - which is not so for this keyring: $ourMirror $ourRelativePath"
	fi
	
	local -i existingKeyringNumber
	for existingKeyringNumber in ${!keyrings_FileName[@]}
	do
		if [ "${keyrings_FileName[$existingKeyringNumber]}" = "$ourFileName" ]; then
			if [ "${keyrings_Mirror[$existingKeyringNumber]}" != "$ourMirror" ]; then
				exitError "Attempt to override mirror for keyring $ourFileName to $ourMirror"
			fi
			if [ "${keyrings_RelativePath[$existingKeyringNumber]}" != "$ourRelativePath" ]; then
				exitError "Attempt to override mirror for keyring $ourFileName to $ourRelativePath"
			fi
			return 0
		fi
	done
	
	local -ir keyringNumber=${#keyrings_Mirror[@]}
	keyrings_Mirror[$keyringNumber]="$ourMirror"
	keyrings_RelativePath[$keyringNumber]="$ourRelativePath"
	keyrings_FileName[$keyringNumber]="$ourFileName"
	keyrings_Hashes[$keyringNumber]="${ourHashes//,/ }"
	keyrings_Compression[$keyringNumber]=""
	
	signature "$ourMirror" "$ourRelativePath" "${keyrings_Hashes[$patchNumber]}"
}

function key()
{
	if [ $# -lt 3 ]; then
		exitError "Not 3 or 4 arguments"
	fi
	if [ $# -gt 4 ]; then
		exitError "Not 3 or 4 arguments"
	fi
	
	local -r ourMirror="$1"
	local -r ourRelativePath="$2"
	
	local -r ourHashes="$3"
	if [ $# -eq 3 ]; then
		local -r ourFileName="$(purebash_basename "$ourRelativePath")"
	else
		local -r ourFileName="$4"
	fi
	
	local -i existingKeyNumber
	for existingKeyNumber in ${!keys_FileName[@]}
	do
		if [ "${keys_FileName[$existingKeyNumber]}" = "$ourFileName" ]; then
			if [ "${keys_Mirror[$existingKeyNumber]}" != "$ourMirror" ]; then
				exitError "Attempt to override mirror for key $ourFileName to $ourMirror"
			fi
			if [ "${keys_RelativePath[$existingKeyNumber]}" != "$ourRelativePath" ]; then
				exitError "Attempt to override mirror for key $ourFileName to $ourRelativePath"
			fi
			return 0
		fi
	done
	
	local -ir keyNumber=${#keys_Mirror[@]}
	keys_Mirror[$keyNumber]="$ourMirror"
	keys_RelativePath[$keyNumber]="$ourRelativePath"
	keys_FileName[$keyNumber]="$ourFileName"
	keys_Hashes[$keyNumber]="${ourHashes//,/ }"
	keys_Compression[$keyNumber]=""
	
	signature "$ourMirror" "$ourRelativePath" "${keys_Hashes[$keyNumber]}"
}

function hkp()
{
	if [ $# -ne 1 ]; then
		exitError "Not 1 argument"
	fi
	local -r keyId="$1"
	
	key HKPS "$keyId" "" "$keyId"
}

declare_for_chroot -A dependency_Phase
declare_for_chroot -A dependency_Name
declare_for_chroot -A dependency_Version
declare_for_chroot -A dependency_RecipeHash
declare_for_chroot -Ai dependency_SourcePackageIndex
declare_for_chroot -A dependency_PatchIndices
declare_for_chroot -A dependency_Dependencies
declare_for_chroot -A dependency_Path
declare_for_chroot -Ai dependency_SkipInstall

declare_for_chroot -a sourcePackages_Name
declare_for_chroot -a sourcePackages_Version
declare_for_chroot -a sourcePackages_Mirror
declare_for_chroot -a sourcePackages_RelativePath
declare_for_chroot -a sourcePackages_Hashes
declare_for_chroot -a sourcePackages_FileName
declare_for_chroot -a sourcePackages_Compression
declare_for_chroot -a sourcePackages_ExtractedTarballFolder
declare_for_chroot -a sourcePackages_IsTarbomb

declare_for_chroot -a patches_Mirror
declare_for_chroot -a patches_RelativePath
declare_for_chroot -a patches_FileName
declare_for_chroot -a patches_Hashes
declare_for_chroot -a patches_Compression

function source_package_skip_install()
{
	local phase
	for phase in "$@"
	do
		if [ "$phase" = "$LFS_PHASE" ]; then
			dependency_key "$LFS_PHASE" "$LFS_SOURCE_PACKAGE_NAME" "${LFS_SOURCE_PACKAGE_VERSION["${LFS_SOURCE_PACKAGE_NAME}"]}"
			dependency_SkipInstall["$DependencyKey"]=1
			return 0
		fi
	done
}

function source_package_alias()
{
	local -r aliasSourcePackageName="$1"
	local -r aliasSourcePackageVersion="$2"
	
	dependency_key "$LFS_PHASE" "$LFS_SOURCE_PACKAGE_NAME" "${LFS_SOURCE_PACKAGE_VERSION["${LFS_SOURCE_PACKAGE_NAME}"]}"
	
	local -i index
	for index in ${!sourcePackages_Name[@]}
	do
		if [ "${sourcePackages_Name[$index]}" = "$aliasSourcePackageName" ]; then
			if [ "${sourcePackages_Version[$index]}" = "$aliasSourcePackageVersion" ]; then
				dependency_SourcePackageIndex["$DependencyKey"]=$index
				return 0
			fi
		fi
	done
	
	exitError "Unknown aliased source package $aliasSourcePackageName $aliasSourcePackageVersion"
}

function source_package()
{
	if [ $# -lt 3 ]; then
		exitError "Not enough arguments"
	elif [ $# -gt 6 ]; then
		exitError "Too many arguments"
	fi
	
	local -r ourSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
	local -r ourSourcePackageVersion="${LFS_SOURCE_PACKAGE_VERSION["${LFS_SOURCE_PACKAGE_NAME}"]}"
	local -r ourMirror="$1"
	local -r ourRelativePath="$2"
	local -r ourHashes="$3"
	local -r ourFileName="$(purebash_basename "$ourRelativePath")"
	
	local -r compressionExtension="${ourFileName##*.}"
	
	if [ $# -ge 4 ]; then
		local -r ourExtractedTarballFolder="$4"
	else
		local -r withoutCompressionExtension="${ourFileName%.*}"
		if [ -z "$compressionExtension" ]; then
			local -r ourExtractedTarballFolder="$withoutCompressionExtension"
		else
			case "$compressionExtension" in
				
				# The various abominations are also slackware packages (txz, tgz especially)
				tar|tgz|tbz|tbz2|txz|tlz|tlzma|tz|taz)
					local -r ourExtractedTarballFolder="$withoutCompressionExtension"
				;;
				
				*)
					local -r ourExtractedTarballFolder="${withoutCompressionExtension%.*}"
				;;
				
			esac
		fi
	fi
	
	if [ $# -ge 5 ]; then
		local -r ourCompression="$5"
	else
		case "$compressionExtension" in
			tar)
				local -r ourCompression=''
			;;
			
			gz|tgz)
				local -r ourCompression=gzip
			;;
			
			bz2|bz|tbz2|tbz)
				local -r ourCompression=bzip2
			;;
			
			# Not included in dependencies by default
			# A faster compressor still is lz4
			lzo)
				local -r ourCompression=lzop
			;;
			
			lz|tlz)
				local -r ourCompression=lzip
			;;
			
			lzma|tlzma)
				local -r ourCompression=lzma
			;;
			
			xz|txz)
				local -r ourCompression=xz
			;;
			
			Z|tz|taz)
				# eg gzip downloads
				local -r ourCompression=compress
			;;
			
			*)
				if [ ! -z "$compressionExtension" ]; then
					exitError "Unknown file extension $compressionExtension for $ourSourcePackageName $ourSourcePackageVersion"
				fi
			;;
		esac
	fi
	
	if [ $# -ge 6 ]; then
		local -r isTarbomb="$6"
	else
		local -r isTarbomb="no"
	fi
	
	dependency_key "$LFS_PHASE" "$LFS_SOURCE_PACKAGE_NAME" "$ourSourcePackageVersion"
	local -i index
	for index in ${!sourcePackages_Name[@]}
	do
		if [ "${sourcePackages_Name[$index]}" = "$LFS_SOURCE_PACKAGE_NAME" ]; then
			if [ "${sourcePackages_Version[$index]}" = "$ourSourcePackageVersion" ]; then
				dependency_SourcePackageIndex["$DependencyKey"]=$index
				return 0
			fi
		fi
	done
	
	index=${#sourcePackages_Name[@]}
	dependency_SourcePackageIndex["$DependencyKey"]=$index
	
	sourcePackages_Name+=("$LFS_SOURCE_PACKAGE_NAME")
	sourcePackages_Version+=("$ourSourcePackageVersion")
	sourcePackages_Mirror+=("$ourMirror")
	sourcePackages_RelativePath+=("$ourRelativePath")
	sourcePackages_Hashes+=("${ourHashes//,/ }")
	sourcePackages_Compression+=("$ourCompression")
	sourcePackages_FileName+=("$ourFileName")
	sourcePackages_ExtractedTarballFolder+=("$ourExtractedTarballFolder")
	sourcePackages_IsTarbomb+=("$isTarbomb")
	
	signature "$ourMirror" "$ourRelativePath" "${sourcePackages_Hashes[$index]}"
}

function source_patch()
{
	dependency_key "$LFS_PHASE" "$LFS_SOURCE_PACKAGE_NAME" "$localSourcePackageVersion"
	
	if [ $# -ne 3 ]; then
		exitError "Not enough arguments"
	fi
	
	local -r ourSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
	local -r ourVersion="${LFS_SOURCE_PACKAGE_VERSION["${LFS_SOURCE_PACKAGE_NAME}"]}"
	local -r ourMirror="$1"
	local -r ourRelativePath="$2"
	local -r ourHashes="$3"
	local -r ourFileName="$(purebash_basename "$ourRelativePath")"
	
	dependency_key "$LFS_PHASE" "$LFS_SOURCE_PACKAGE_NAME" "$ourSourcePackageVersion"
	local -r existingPatchIndices="${dependency_PatchIndices["$DependencyKey"]}"
	local -i index
	for index in ${patches_RelativePath["${key}"]}
	do
		if [ "${patches_RelativePath[$index]}" = "$ourRelativePath" ]; then
			if [ "${patches_Mirror[$index]}" = "$ourMirror" ]; then
				if [ -z "$existingPatchIndices" ]; then
					dependency_PatchIndices["$DependencyKey"]="$index"
				else
					dependency_PatchIndices["$DependencyKey"]="$existingPatchIndices $index"
				fi
				return 0
			fi
		fi
	done
	
	local -ir index=${#patches_Mirror[@]}
	patches_Mirror[$index]="$ourMirror"
	patches_FileName[$index]="$ourFileName"
	patches_RelativePath[$index]="$ourRelativePath"
	patches_Hashes[$index]="${ourHashes//,/ }"
	patches_Compression[$index]=""
	
	if [ -z "$existingPatchIndices" ]; then
		dependency_PatchIndices["$DependencyKey"]="$index"
	else
		dependency_PatchIndices["$DependencyKey"]="$existingPatchIndices $index"
	fi
	
	signature "$ourMirror" "$ourRelativePath" "${patches_Hashes[$index]}"
}

function version()
{
	if [ $# -ne 1 ]; then
		exitError "Needs 1 argument"
	fi
	local -r localSourcePackageVersion="$1"
	
	local -r previousVersions="${LFS_SOURCE_PACKAGE_VERSIONS["${LFS_SOURCE_PACKAGE_NAME}"]}"
	if [ -z "$previousVersions" ]; then
		LFS_SOURCE_PACKAGE_VERSIONS["${LFS_SOURCE_PACKAGE_NAME}"]="$localSourcePackageVersion"
	else
		LFS_SOURCE_PACKAGE_VERSIONS["${LFS_SOURCE_PACKAGE_NAME}"]="$previousVersions $localSourcePackageVersion"
	fi
	LFS_SOURCE_PACKAGE_VERSION["${LFS_SOURCE_PACKAGE_NAME}"]="$localSourcePackageVersion"
	
	dependency_key "$LFS_PHASE" "$LFS_SOURCE_PACKAGE_NAME" "$localSourcePackageVersion"
	dependency_Phase["$DependencyKey"]="$LFS_PHASE"
	dependency_Name["$DependencyKey"]="$LFS_SOURCE_PACKAGE_NAME"
	dependency_Version["$DependencyKey"]="$localSourcePackageVersion"
	dependency_RecipeHash["$DependencyKey"]="$LFS_RECIPE_HASH"
	dependency_IncludeHash["$DependencyKey"]="$LFS_INCLUDE_HASH"
	dependency_SourcePackageIndex["$DependencyKey"]=-1
	dependency_PatchIndices["$DependencyKey"]=""
	dependency_Dependencies["$DependencyKey"]=""
	dependency_Path["$DependencyKey"]=""
	dependency_SkipInstall["$DependencyKey"]=0
	
	if [ -f "$LFS_INCLUDE_FILE" ]; then
		source "$LFS_INCLUDE_FILE"
	fi
}

declare_for_chroot -A phase_PreviousRecipes
phase_PreviousRecipes+=(['toolchain1']="" ['toolchain2']="" ['system']="")
declare_for_chroot -A phase_InstallationOrder

function depends()
{
	if [ $# -ne 1 ]; then
		exitError "Needs 1 argument"
	fi
	
	local -r localSourcePackageName="$1"
	
	local -i alreadySourced=0
	local previousRecipe
	for previousRecipe in ${phase_PreviousRecipes["${LFS_PHASE}"]}
	do
		if [ "$previousRecipe" = "$localSourcePackageName" ]; then
			alreadySourced=1
			break
		fi
	done
	
	if [ $alreadySourced -eq 0 ]; then
		
		local -r recipeFile="$recipesPath"/"$LFS_PHASE"/"$localSourcePackageName".recipe
		
		if [ ! -f "$recipeFile" ]; then
			exitError "recipe $localSourcePackageName ($recipeFile) does not exist or is not a file"
		fi
		
		# Prevent recursion
		phase_PreviousRecipes["${LFS_PHASE}"]="${phase_PreviousRecipes["${LFS_PHASE}"]} $localSourcePackageName"
	
		# set / unset inside include_phase
		# Set to blank to avoid bash's associative array bugs with non-existent members (it aliases the last added member)
		LFS_SOURCE_PACKAGE_VERSIONS["${localSourcePackageName}"]=""
		
		# Holds the last set version
		LFS_SOURCE_PACKAGE_VERSION["${localSourcePackageName}"]=""
	
		local -r includeFile="$includesPath"/"$LFS_SOURCE_PACKAGE_NAME".include
		if [ -f "$includeFile" ]; then
			local -r includeHash="$(sha512sum "$includeFile" | awk 'NR==1 {print $1}')"
		else
			local -r includeHash="0"
		fi
		
		# Weirdly, but usefully, a source'd file has access to our local variables AND can mutate them (it does not run a subshell or stack scope)
		# BUT, and here's the BUT, they won't get passed down to any functions! Darn!
		LFS_SOURCE_PACKAGE_NAME="$localSourcePackageName" LFS_RECIPE_HASH="$(sha512sum "$recipeFile" | awk 'NR==1 {print $1}')" LFS_INCLUDE_HASH="$includeHash" LFS_INCLUDE_FILE="$includeFile" source "$recipeFile"
	fi
	
	# We currently only do this for the last set version. In future, we might be able to take a directive from above
	# if depends bash is called, which does version 4.2, depends gcc, version 2.5, then once back in 'depends bash':-
	#  LFS_SOURCE_PACKAGE_NAME is blank
	# "${LFS_SOURCE_PACKAGE_VERSION["${LFS_SOURCE_PACKAGE_NAME}"]}"   is 4.2
	#  localSourcePackageName is gcc
	# "${LFS_SOURCE_PACKAGE_VERSION["${localSourcePackageName}"]}"   is 2.5
	
	# Add to parent's dependencies
	# LFS_SOURCE_PACKAGE_NAME will be blank for the package listed in the profile
	dependency_key "$LFS_PHASE" "$localSourcePackageName" "${LFS_SOURCE_PACKAGE_VERSION["${localSourcePackageName}"]}"
	local -r child="$DependencyKey"
	
	if [ ! -z "$LFS_SOURCE_PACKAGE_NAME" ]; then
		dependency_key "$LFS_PHASE" "$LFS_SOURCE_PACKAGE_NAME" "${LFS_SOURCE_PACKAGE_VERSION["${LFS_SOURCE_PACKAGE_NAME}"]}"
		local -r parent="$DependencyKey"
		local -r dependencies="${dependency_Dependencies["$parent"]}"
		if [ -z "$dependencies" ]; then
			dependency_Dependencies["$parent"]="$child"
		else
			dependency_Dependencies["$parent"]="$dependencies $child"
		fi
	fi
	
	local existingInstall
	for existingInstall in "${phase_InstallationOrder["${LFS_PHASE}"]}"
	do
		if [ "$existingInstall" = "$child" ]; then
			return 0
		fi
	done
	
	local -r all="${phase_InstallationOrder["${LFS_PHASE}"]}"
	if [ -z "$all" ]; then
		phase_InstallationOrder["${LFS_PHASE}"]="$child"
	else
		phase_InstallationOrder["${LFS_PHASE}"]="$all $child"
	fi
}

function conflicts()
{
	exitError "Unimplemented"
}

function system_group()
{
	local -r groupName="$1"
	if [ $# -eq 2 ]; then
		local -ir proposedGid=$2
	fi
	
	local -i index
	for index in ${!groups_Name[@]}
	do
		if [ "${groups_Name[$index]}" = "$groupName" ]; then
			if [ $# -eq 2 && ${groups_Gid[$index]} -ne $proposedGid ]; then
				exitError "mismatch in group gids for $groupName, $gid (is previously defined as ${groups_Gid[$index]})"
			else
				return 0
			fi
		fi
	done
	
	if [ $# -eq 2 ]; then
		local -ir gid=$proposedGid
	else
		if [ $nextSystemGid -eq -1 ]; then
			nextSystemGid=${settings_integer[LFS_INCLUSIVE_SYSTEM_GID]}
		fi
		local -ir gid=$((nextSystemGid++))
	fi
	
	index=${#groups_Name[@]}
	groups_Name[$index]="$groupName"
	groups_Gid[$index]=$gid
	groups_Members[$index]=""
}

function verifyGroupExists()
{
	local -r groupName="$1"
	local -r userName="$2"
	local group
	for group in ${groups_Name[@]}
	do
		if [ "$group" = "$groupName" ]; then
			return 0
		fi
	done
	exitError "Group with name $groupName does exist for user $userName"
}

function user()
{
	local -r userName="$1"
	local -r gecos="$2"
	local -r home="$3"
	local -r shell="$4"
	
	if [ $# -eq 6 ]; then
		verifyGroupExists $6 "$userName"
	fi
	
	local -i index
	for index in ${!users_Name[@]}
	do
		if [ "${users_Name[$index]}" = "$userName" ]; then
			if [ "${users_Gecos[$index]}" != "$gecos" ]; then
				exitError "gecos redefined for user $userName"
			fi
			if [ "${users_Home[$index]}" != "$home" ]; then
				exitError "home redefined for user $userName"
			fi
			if [ "${users_Shell[$index]}" != "$shell" ]; then
				exitError "shell redefined for user $userName"
			fi
			if [ $# -ge 5 ]; then
				if [ ${users_Uid[$index]} -ne $5 ]; then
					exitError "uid redefined for user $userName"
				fi
			fi
		fi
	done
	
	if [ $# -ge 5 ]; then
		local -ir uid=$5
	else
		if [ "$shell" = "/bin/false" ]; then
			if [ $nextSystemUid -eq -1 ]; then
				nextSystemUid=${settings_integer[LFS_INCLUSIVE_SYSTEM_UID]}
			fi
			local -ir uid=$((nextSystemUid++))
		else
			if [ $nextUserId -eq -1 ]; then
				nextUserUid=${settings_integer[LFS_INCLUSIVE_USER_UID]}
			fi
			local -ir uid=$((nextUserUid++))
		fi
	fi
	
	# check uid not already in use
	local -i existingUid
	for existingUid in ${users_Uid[@]}
	do
		if [ $existingUid -eq $uid ]; then
			exitError "uid $uid already exists for user $userName"
		fi
	done
	
	if [ $# -eq 6 ]; then
		local -r groupName="$6"
		local -i gid=-1
		for index in ${!groups_Name[@]}
		do
			if [ "${groups_Name[$index]}" = "$groupName" ]; then
				gid=${groups_Gid[$index]}
				break
			fi
		done
		if [ $gid -eq -1 ]; then
			exitError "Group $groupName not defined for user $userName"
		fi
	else
		if [ "$shell" = "/bin/false" ]; then
			local -ir gid=$((nextSystemGid++))
		else
			if [ $nextUserGid -eq -1 ]; then
				nextUserGid=${settings_integer[LFS_INCLUSIVE_USER_GID]}
			fi
			local -ir gid=$((nextUserGid++))
		fi
	fi
	
	# check gid not already in use
	local -i existingGid
	for existingGid in ${users_Gid[@]}
	do
		if [ $existingGid -eq $gid ]; then
			exitError "gid $gid already exists for user $userName"
		fi
	done
		
	local -r ourSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
	
	index=${#users_Name[@]}
	users_Name[$index]="$userName"
	users_Gecos[$index]="$gecos"
	users_Home[$index]="$home"
	users_Shell[$index]="$shell"
	users_Uid[$index]=$uid
	users_Gid[$index]=$gid
	
	#printf "$userName:x:$uid:$gid:$gecos:$home:$shell"
}

function permissions_after()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	local -r extendedAttributesToApplyFirst="$5"
	local -r extendedAttributesToApplyLast="$6"
	
	if [ "${target:0:1}" != "/" ]; then
		exitError "directory target must be absolute, not $target"
	fi
	
	local -i uid=-1
	for index in ${!users_Name[@]}
	do
		if [ "${users_Name[$index]}" = "$userName" ]; then
			uid=${users_Uid[$index]}
			break
		fi
	done
	if [ $uid -eq -1 ]; then
		exitError "User $userName not defined for target $target"
	fi
	
	local -i gid=-1
	for index in ${!groups_Name[@]}
	do
		if [ "${groups_Name[$index]}" = "$groupName" ]; then
			gid=${groups_Gid[$index]}
			break
		fi
	done
	if [ $gid -eq -1 ]; then
		exitError "Group $groupName not defined for target $target"
	fi
	
	# Listed in reverse-order!
	if [ ! -z "$extendedAttributesToApplyLast" ]; then
		latePathCommands+=("chattr +"\'"$extendedAttributesToApplyLast"\'" -- "\'"${LFS}${target}"\')
	fi
	if [ ! -z "$extendedAttributesToApplyFirst" ]; then
		latePathCommands+=("chattr +"\'"$extendedAttributesToApplyFirst"\'" -- "\'"${LFS}${target}"\')
	fi
	latePathCommands+=("chown $uid:$gid -- "\'"${LFS}${target}"\')
	latePathCommands+=("chmod "\'"$mode"\'" -- "\'"${LFS}${target}"\')
}

function recurse()
{
	local -r target="$1"
	local -ir mindepth=$2
	local -ir maxdepth=$3
	local -r fileTypeCode="$4"
	local -r callback="$5"
	shift 5
	
	find -P "${LFS}${target}" -depth -mindepth $mindepth -maxdepth $maxdepth -type "$fileTypeCode" -print0 | while IFS= read -r -d $'\0' file
	do
		$callback "$file" "$@"
	done
}

function recurse_callback_permissions()
{
	local -r target="$1"
	local -r mode="$2"
	local -r uid=$3
	local -r gid=$4
	local -r extendedAttributesToApplyFirst="$5"
	local -r extendedAttributesToApplyLast="$6"
	
	chmod "$mode" -- "$target"
	chown $uid:$gid -- "$target"
	if [ ! -z "$extendedAttributesToApplyFirst" ]; then
		chattr +"$extendedAttributesToApplyFirst" "$target"
	fi
	if [ ! -z "$extendedAttributesToApplyLast" ]; then
		chattr +"$extendedAttributesToApplyLast" "$target"
	fi
}

function permissions_after_recursive()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	local -r extendedAttributesToApplyFirst="$5"
	local -r extendedAttributesToApplyLast="$6"
	local -ir mindepth=$7
	local -ir maxdepth=$8
	# eg directory => d, file => f
	local -r fileTypeCode="${9:0:1}"
	
	if [ "${target:0:1}" != "/" ]; then
		exitError "directory target must be absolute, not $target"
	fi
	
	local -i uid=-1
	for index in ${!users_Name[@]}
	do
		if [ "${users_Name[$index]}" = "$userName" ]; then
			uid=${users_Uid[$index]}
			break
		fi
	done
	if [ $uid -eq -1 ]; then
		exitError "User $userName not defined for target $target"
	fi
	
	local -i gid=-1
	for index in ${!groups_Name[@]}
	do
		if [ "${groups_Name[$index]}" = "$groupName" ]; then
			gid=${groups_Gid[$index]}
			break
		fi
	done
	if [ $gid -eq -1 ]; then
		exitError "Group $groupName not defined for target $target"
	fi
	
	latePathCommands+=("recurse "\'"$target"\'" $mindepth $maxdepth "\'"$fileTypeCode"\'" recurse_callback_permissions "\'"$mode"\'" $uid $gid "\'"$extendedAttributesToApplyFirst"\'" "\'"$extendedAttributesToApplyLast"\')
}

function permissions_before()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	local -r extendedAttributesToApplyFirst="$5"
	
	if [ "${target:0:1}" != "/" ]; then
		exitError "directory target must be absolute, not $target"
	fi
	
	local -i uid=-1
	for index in ${!users_Name[@]}
	do
		if [ "${users_Name[$index]}" = "$userName" ]; then
			uid=${users_Uid[$index]}
			break
		fi
	done
	if [ $uid -eq -1 ]; then
		exitError "User $userName not defined for target $target"
	fi
	
	local -i gid=-1
	for index in ${!groups_Name[@]}
	do
		if [ "${groups_Name[$index]}" = "$groupName" ]; then
			gid=${groups_Gid[$index]}
			break
		fi
	done
	if [ $gid -eq -1 ]; then
		exitError "Group $groupName not defined for target $target"
	fi
	
	earlyPathCommands+=("chmod "\'"$mode"\'" -- "\'"${LFS}${target}"\')
	earlyPathCommands+=("chown $uid:$gid -- "\'"${LFS}${target}"\')
	if [ ! -z "$extendedAttributesToApplyFirst" ]; then
		earlyPathCommands+=("chattr +"\'"$extendedAttributesToApplyFirst"\'" -- "\'"${LFS}${target}"\')
	fi
}

function directory()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	local -r extendedAttributesToApplyFirst="$5"
	local -r extendedAttributesToApplyLast="$6"
	
	permissions_after "$target" "$mode" "$userName" "$groupName" "$extendedAttributesToApplyFirst" "$extendedAttributesToApplyLast"
	
	earlyPathCommands+=("mkdir -p -m "\'"$mode"\'" -- "\'"${LFS}${target}"\')
	
	permissions_before "$target" "$mode" "$userName" "$groupName" "$extendedAttributesToApplyFirst"
}

function symlink()
{
	local -r target="$1"
	local -r contents="$2"
	if [ "${target:0:1}" != "/" ]; then
		exitError "symlink target must be absolute, not $target"
	fi
	
	earlyPathCommands+=("ln -s "\'"$contents"\'" "\'"${LFS}${target}"\')
}

function touch_file()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	local -r extendedAttributesToApplyFirst="$5"
	local -r extendedAttributesToApplyLast="$6"
	
	permissions_after "$target" "$mode" "$userName" "$groupName" "$extendedAttributesToApplyFirst" "$extendedAttributesToApplyLast"
	
	earlyPathCommands+=("touch "\'"${LFS}${target}"\')
	
	permissions_before "$target" "$mode" "$userName" "$groupName" "$extendedAttributesToApplyFirst"
}

function make_character_device()
{
	local -r target="$1"
	local -r deviceMajor="$2"
	local -r deviceMinor="$3"
	local -r mode="$4"
	local -r userName="$5"
	local -r groupName="$6"
	
	permissions_after "$target" "$mode" "$userName" "$groupName" "" ""
	
	earlyPathCommands+=("mknod -m "\'"$mode"\'" "\'"${LFS}${target}"\'" c "\'"$deviceMajor"\'" "\'"$deviceMinor"\')
	
	permissions_before "$target" "$mode" "$userName" "$groupName" ""
}

function make_block_device()
{
	local -r target="$1"
	local -r deviceMajor="$2"
	local -r deviceMinor="$3"
	local -r mode="$4"
	local -r userName="$5"
	local -r groupName="$6"
	
	permissions_after "$target" "$mode" "$userName" "$groupName" "" ""
	
	earlyPathCommands+=("mknod -m "\'"$mode"\'" "\'"${LFS}${target}"\'" b "\'"$deviceMajor"\'" "\'"$deviceMinor"\')
	
	permissions_before "$target" "$mode" "$userName" "$groupName" ""
}

function make_fifo()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	
	permissions_after "$target" "$mode" "$userName" "$groupName" "" ""
	
	earlyPathCommands+=("mknod -m "\'"$mode"\'" "\'"${LFS}${target}"\'" p")
	
	permissions_before "$target" "$mode" "$userName" "$groupName" ""
}

function include_mirror()
{
	if [ $# -ne 1 ]; then
		exitError "Not exactly 1 argument"
	fi
	
	local -r localMirror="$1"
	
	local previousMirror
	for previousMirror in "${previousMirrors[@]}"
	do
		if [ "$previousMirror" = "$localMirror" ]; then
			exitError "Recursion of mirrors - trying to use $localMirror after mirror stack of $previousMirrors"
		fi
	done
	previousMirrors+=("$localMirror")
	
	if [ -f "$mirrorsPath"/"$localMirror".mirrors ]; then
		source "$mirrorsPath"/"$localMirror".mirrors
	else
		exitError "mirrors $localMirror.mirrors does not exist in mirrors path $mirrorsPath or is not a file"
	fi
}

function include_profile()
{
	if [ $# -ne 1 ]; then
		exitError "Not exactly 1 argument"
	fi
	
	local -r localProfile="$1"
	local previousProfile
	for previousProfile in "${previousProfiles[@]}"
	do
		if [ "$previousProfile" = "$localProfile" ]; then
			# Allowed (but ignored)
			return 0
		fi
	done
	previousProfiles+=("$localProfile")
	
	if [ -f "$profilesPath"/"$localProfile".profile ]; then
		source "$profilesPath"/"$localProfile".profile
	else
		exitError "profile $localProfile.profile does not exist in profile path $profilesPath or is not a file"
	fi
}

function tarExtract()
{
	if [ $# -ne 4 ]; then
		exitError "Not enough arguments"
	fi
	
	local -r tarball="$1"
	local -r tarballFolder="$2"
	local -r tarballCompression="$3"
	local -r isTarbomb="$4"
	
	rm -rf -- "$tarballFolder"
	
	pushd "$(purebash_dirname "$tarball")" >/dev/null
		
		local -r absoluteTarballPath="$(pwd)"/"$(purebash_basename "$tarball")"
		
	popd >/dev/null
	
	if [ "$isTarbomb" = "tarbomb" ]; then
		mkdir -m 0755 -p "$tarballFolder"
		pushd "$tarballFolder" >/dev/null
	fi
	
		if [ -z "$ourCompression" ]; then
			tar --extract --file "$absoluteTarballPath"
		else
			tar --extract --file "$absoluteTarballPath" --$tarballCompression
		fi
	
	if [ "$isTarbomb" = "tarbomb" ]; then
		popd >/dev/null
	fi
}

# Assumes it is in the build folder
function extractDependencyIntoBuildFolder()
{
	if [ $# -ne 1 ]; then
		exitError "Needs 1 argument"
	fi
	
	local -r localSourcePackageName="$1"
	
	dependency_key "$LFS_PHASE" "$LFS_SOURCE_PACKAGE_NAME" "$LFS_SOURCE_PACKAGE_VERSION"
	local dependency
	for dependency in dependency_Dependencies["$DependencyKey"]
	do
		if [ "${dependency_Name["$dependency"]}" = "$localSourcePackageName" ]; then
			local -r localVersion="${dependency_Version["$dependency"]}"
			break
		fi
	done
	
	if [ -z "$localVersion" ]; then
		exitError "$dependencySourcePackageName not known"
	fi
	
	dependency_key "$LFS_PHASE" "$localSourcePackageName" "$localVersion"
	
	local -r localFileName="${sourcePackages_FileName["$DependencyKey"]}"
	local -r localExtractedTarballFolder="${sourcePackages_ExtractedTarballFolder["$DependencyKey"]}"
	local -r localCompression="${sourcePackages_Compression["$DependencyKey"]}"
	local -r localIsTarbomb="${sourcePackages_IsTarbomb["$DependencyKey"]}"
	
	if [ -z "$localFileName" ]; then
		progressMessageFailed "No known source package definition for dependency $localSourcePackageName $localVersion"
	fi
	
	if [ -z "$localExtractedTarballFolder" ]; then
		progressMessageFailed "No tarball for $localSourcePackageName $localVersion"
	fi
	
	tarExtract ../"$localFileName" "$localExtractedTarballFolder" "$localCompression" "$localIsTarbomb"
	mv -v "$localExtractedTarballFolder" "$localSourcePackageName"
}

function installPackagePrototype()
{
	./configure --prefix=/"$LFS_TOOLS" $@
	
	make
	
	#make check
	
	make install
}

function createBuildFolderAndPushd()
{
	if [ $# -gt 2 ]; then
		exitError "Too many arguments"
	fi
	
	if [ $# -eq 0 ]; then
		local -r buildFolder=../"$LFS_SOURCE_PACKAGE_NAME"-"$LFS_SOURCE_PACKAGE_VERSION"-build
		rm -rf -- "$buildFolder"
	elif [ $# -eq 2 ]; then
		local -r ourSourcePackageName="$1"
		local -r ourSourcePackageVersion="$2"
		local -r buildFolder=../"$ourSourcePackageName"-"$ourSourcePackageVersion"-build
	else
		exitError "Needs 0 or 2 arguments"
	fi
	
	mkdir -m 0755 -p "$buildFolder"
	pushd "$buildFolder" >/dev/null
}

function popdBuildFolder()
{
	if [ $# -ne 0 ]; then
		exitError "Too many arguments"
	fi
	
	local -r buildFolder=../"$LFS_SOURCE_PACKAGE_NAME"-build
	popd >/dev/null
	#rm -rf -- "$buildFolder"
}
