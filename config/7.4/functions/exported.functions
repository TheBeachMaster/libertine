set -o errexit +o hashall

declare_for_chroot -a signatures_Url
declare_for_chroot -a signatures_FileName
declare_for_chroot -a signatures_Compression

declare_for_chroot -a keyrings_Url
declare_for_chroot -a keyrings_FileName
declare_for_chroot -a keyrings_Hashes
declare_for_chroot -a keyrings_Compression

declare_for_chroot -a keys_Url
declare_for_chroot -a keys_FileName
declare_for_chroot -a keys_Hashes
declare_for_chroot -a keys_Compression

declare -i nextSystemUid=-1
declare -i nextSystemGid=-1
declare -i nextUserUid=-1
declare -i nextUserGid=-1

declare_for_chroot -a groups_Name
declare_for_chroot -a groups_Gid
declare_for_chroot -a groups_Members

declare_for_chroot -a users_Name
declare_for_chroot -a users_Gecos
declare_for_chroot -a users_Home
declare_for_chroot -a users_Shell
declare_for_chroot -a users_Uid
declare_for_chroot -a users_Gid

declare -a earlyPathCommands
declare -a latePathCommands

# Exists because ${!sourcePackages_XXXX[@]} returns INDICES not KEYS; we can also use indices it seems against associative arrays
declare_for_chroot -a sourcePackages_IndicesToKeys
declare_for_chroot -A sourcePackages_SourcePackageName
declare_for_chroot -A sourcePackages_Version
declare_for_chroot -A sourcePackages_Url
declare_for_chroot -A sourcePackages_Compression
declare_for_chroot -A sourcePackages_FileName
declare_for_chroot -A sourcePackages_ExtractedTarballFolder
declare_for_chroot -A sourcePackages_Hashes
declare_for_chroot -A sourcePackages_Patches
declare_for_chroot -A sourcePackages_RecipeHash

declare_for_chroot -a patches_Url
declare_for_chroot -a patches_FileName
declare_for_chroot -a patches_Hashes
declare_for_chroot -a patches_Compression

declare_for_chroot -a previousMirrors
declare_for_chroot -a previousProfiles

declare_for_chroot -A phase_PreviousRecipes
phase_PreviousRecipes+=(['toolchain1']="" ['toolchain2']="" ['system']="")
declare_for_chroot -A phase_InstallationOrder

function progressMessage()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	SECONDS=0
	printf "$ourName: $1"
}

function progressMessageUpdate()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	printf " $1"
}

function progressMessageFailed()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	echo " FAILED (in ${SECONDS}s: $1)"
	exit 1
}

function progressMessageSucceeded()
{
	if [ $# -ne 0 ]; then
		exitError "Too many arguments"
	fi
	echo " PASSED (in ${SECONDS}s)"
}

function printKey()
{
	if [ $# -ne 2 ]; then
		exitError "Too many arguments"
	fi
	
	local -r localSourcePackageName="$1"
	local -r localVersion="$2"
	# bash has problems with keys containing non-alphanumerics when the key has not previously been added to an associative array
	# this is a problem for existence checks
	# printf so as to avoid tr replacing a trailing \n (as would happen with a heredoc)
	printf '%s' "${localSourcePackageName}:${localVersion}" | tr --complement '[:alpha:][:digit:]' '_'
}

function printDistributionVersionKey()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	local -r localDistributionVersion="$1"
	printf '%s' "${localDistributionVersion}" | tr --complement '[:alpha:][:digit:]' '_'
}

function sourcePackagesKeyExists()
{
	if [ $# -ne 1 ]; then
		exitError "Too many arguments"
	fi
	
	local -r key="$1"
	local -i index
	for index in ${!sourcePackages_IndicesToKeys[@]}
	do
		if [ "$key" = "${sourcePackages_IndicesToKeys[$index]}" ]; then
			# key already exists
			return 0
		fi
	done
	return 1
}

function signature()
{
	local -r ourUnsignedUrl="$1"
	local -r ourHashesSpaceSeparated="$2"
	
	local hashNameAndValue
	local hashName
	local hashValue
	local hashSignatureFileName
	local hashSignatureUrl
	
	local -i signatureNumber
	for hashNameAndValue in $ourHashesSpaceSeparated
	do
		IFS=':' read -r -d$'\n' hashName hashValue hashSignatureFileName <<<"$hashNameAndValue"
		case "$hashName" in
			KEYRING|KEYFILE|HKP|HKP_UNCOMPRESSED)
				signatureNumber=${#signatures_Url[@]}
				
				if [ -z "$hashSignatureFileName" ]; then
					hashSignatureFileName="$(purebash_basename "$ourUnsignedUrl".sig)"
				fi
				hashSignatureUrl="$(purebash_dirname "$ourUnsignedUrl")"/"$hashSignatureFileName"
				
				signatures_Url[$signatureNumber]="$hashSignatureUrl"
				signatures_FileName[$signatureNumber]="$hashSignatureFileName"
				signatures_Compression[$signatureNumber]=""
				
				case "$hashName" in
					HKP|HKP_UNCOMPRESSED)
						hkp "$hashValue"
					;;
				esac
			;;
		esac
	done
}

function keyring()
{
	if [ $# -ne 3 ]; then
		exitError "Not exactly 3 arguments"
	fi
	
	local -r ourMirror="$1"
	local -r ourRelativePath="$2"
	local -r ourUrl="${ourMirror}${ourRelativePath}"
	local -r ourHashes="$3"
	local -r ourFileName="$(purebash_basename "$ourUrl")"
	
	if [ "${ourFileName##*.}" != "gpg" ]; then
		exitError "Only gpg keyrings are supported - which is not so for this url: $ourUrl"
	fi
	
	local -i existingKeyringNumber
	for existingKeyringNumber in ${!keyrings_FileName[@]}
	do
		if [ ${keyrings_FileName[$existingKeyringNumber]} = "$ourFileName" ]; then
			if [ ${keyrings_FileName[$existingPatchNumber]} != "$ourUrl" ]; then
				warning "Attempt to override URL IGNORED for keyring $ourFileName to $ourUrl"
			fi
			return 0
		fi
	done
	
	local -ir keyringNumber=${#patches_Url[@]}
	keyrings_Url[$keyringNumber]="$ourUrl"
	keyrings_FileName[$keyringNumber]="$ourFileName"
	keyrings_Hashes[$keyringNumber]="${ourHashes//,/ }"
	keyrings_Compression[$keyringNumber]=""
	
	signature "$ourUrl" "${keyrings_Hashes[$patchNumber]}"
}

function key()
{
	if [ $# -lt 3 ]; then
		exitError "Not 3 or 4 arguments"
	fi
	if [ $# -gt 4 ]; then
		exitError "Not 3 or 4 arguments"
	fi
	
	local -r ourMirror="$1"
	local -r ourRelativePath="$2"
	local -r ourUrl="${ourMirror}${ourRelativePath}"
	
	local -r ourHashes="$3"
	if [ $# -eq 3 ]; then
		local -r ourFileName="$(purebash_basename "$ourUrl")"
	else
		local -r ourFileName="$4"
	fi
	
	local -i existingKeyNumber
	for existingKeyNumber in ${!keys_FileName[@]}
	do
		if [ ${keys_FileName[$existingKeyNumber]} = "$ourFileName" ]; then
			if [ ${keys_Url[$existingKeyNumber]} != "$ourUrl" ]; then
				warning "Attempt to override URL IGNORED for key $ourFileName to $ourUrl"
			fi
			return 0
		fi
	done
	
	local -ir keyNumber=${#keys_Url[@]}
	keys_Url[$keyNumber]="$ourUrl"
	keys_FileName[$keyNumber]="$ourFileName"
	keys_Hashes[$keyNumber]="${ourHashes//,/ }"
	keys_Compression[$keyNumber]=""
	
	signature "$ourUrl" "${keys_Hashes[$keyNumber]}"
}

function hkp()
{
	local -r keyId="$1"
	if [ $# -eq 1 ]; then
		local -r hkpUrlTemplate="$LFS_MIRROR_HKPS"
	elif [ $# -eq 2 ]; then
		local -r hkpUrlTemplate="$2"
	else
		exitError "Not 1 or 2 arguments"
	fi
	
	key "${hkpUrlTemplate}" "${keyId}" "" "$keyId"
}

function system_group()
{
	local -r groupName="$1"
	if [ $# -eq 2 ]; then
		local -ir proposedGid=$2
	fi
	
	local -i index
	for index in ${!groups_Name[@]}
	do
		if [ "${groups_Name[$index]}" = "$groupName" ]; then
			if [ $# -eq 2 && ${groups_Gid[$index]} -ne $proposedGid ]; then
				exitError "mismatch in group gids for $groupName, $gid (is previously defined as ${groups_Gid[$index]})"
			else
				return 0
			fi
		fi
	done
	
	if [ $# -eq 2 ]; then
		local -ir gid=$proposedGid
	else
		if [ $nextSystemGid -eq -1 ]; then
			nextSystemGid=${settings_integer[LFS_INCLUSIVE_SYSTEM_GID]}
		fi
		local -ir gid=$((nextSystemGid++))
	fi
	
	index=${#groups_Name[@]}
	groups_Name[$index]="$groupName"
	groups_Gid[$index]=$gid
	groups_Members[$index]=""
}

function verifyGroupExists()
{
	local -r groupName="$1"
	local -r userName="$2"
	local group
	for group in ${groups_Name[@]}
	do
		if [ "$group" = "$groupName" ]; then
			return 0
		fi
	done
	exitError "Group with name $groupName does exist for user $userName"
}

function user()
{
	local -r userName="$1"
	local -r gecos="$2"
	local -r home="$3"
	local -r shell="$4"
	
	if [ $# -eq 6 ]; then
		verifyGroupExists $6 "$userName"
	fi
	
	local -i index
	for index in ${!users_Name[@]}
	do
		if [ "${users_Name[$index]}" = "$userName" ]; then
			if [ "${users_Gecos[$index]}" != "$gecos" ]; then
				exitError "gecos redefined for user $userName"
			fi
			if [ "${users_Home[$index]}" != "$home" ]; then
				exitError "home redefined for user $userName"
			fi
			if [ "${users_Shell[$index]}" != "$shell" ]; then
				exitError "shell redefined for user $userName"
			fi
			if [ $# -ge 5 ]; then
				if [ ${users_Uid[$index]} -ne $5 ]; then
					exitError "uid redefined for user $userName"
				fi
			fi
		fi
	done
	
	if [ $# -ge 5 ]; then
		local -ir uid=$5
	else
		if [ "$shell" = "/bin/false" ]; then
			if [ $nextSystemUid -eq -1 ]; then
				nextSystemUid=${settings_integer[LFS_INCLUSIVE_SYSTEM_UID]}
			fi
			local -ir uid=$((nextSystemUid++))
		else
			if [ $nextUserId -eq -1 ]; then
				nextUserUid=${settings_integer[LFS_INCLUSIVE_USER_UID]}
			fi
			local -ir uid=$((nextUserUid++))
		fi
	fi
	
	# check uid not already in use
	local -i existingUid
	for existingUid in ${users_Uid[@]}
	do
		if [ $existingUid -eq $uid ]; then
			exitError "uid $uid already exists for user $userName"
		fi
	done
	
	if [ $# -eq 6 ]; then
		local -r groupName="$6"
		local -i gid=-1
		for index in ${!groups_Name[@]}
		do
			if [ "${groups_Name[$index]}" = "$groupName" ]; then
				gid=${groups_Gid[$index]}
				break
			fi
		done
		if [ $gid -eq -1 ]; then
			exitError "Group $groupName not defined for user $userName"
		fi
	else
		if [ "$shell" = "/bin/false" ]; then
			local -ir gid=$((nextSystemGid++))
		else
			if [ $nextUserGid -eq -1 ]; then
				nextUserGid=${settings_integer[LFS_INCLUSIVE_USER_GID]}
			fi
			local -ir gid=$((nextUserGid++))
		fi
	fi
	
	# check gid not already in use
	local -i existingGid
	for existingGid in ${users_Gid[@]}
	do
		if [ $existingGid -eq $gid ]; then
			exitError "gid $gid already exists for user $userName"
		fi
	done
		
	local -r ourSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
	
	index=${#users_Name[@]}
	users_Name[$index]="$userName"
	users_Gecos[$index]="$gecos"
	users_Home[$index]="$home"
	users_Shell[$index]="$shell"
	users_Uid[$index]=$uid
	users_Gid[$index]=$gid
	
	#printf "$userName:x:$uid:$gid:$gecos:$home:$shell"
}

function permissions_after()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	local -r extendedAttributesToApplyFirst="$5"
	local -r extendedAttributesToApplyLast="$6"
	
	if [ "${target:0:1}" != "/" ]; then
		exitError "directory target must be absolute, not $target"
	fi
	
	local -i uid=-1
	for index in ${!users_Name[@]}
	do
		if [ "${users_Name[$index]}" = "$userName" ]; then
			uid=${users_Uid[$index]}
			break
		fi
	done
	if [ $uid -eq -1 ]; then
		exitError "User $userName not defined for target $target"
	fi
	
	local -i gid=-1
	for index in ${!groups_Name[@]}
	do
		if [ "${groups_Name[$index]}" = "$groupName" ]; then
			gid=${groups_Gid[$index]}
			break
		fi
	done
	if [ $gid -eq -1 ]; then
		exitError "Group $groupName not defined for target $target"
	fi
	
	# Listed in reverse-order!
	if [ ! -z "$extendedAttributesToApplyLast" ]; then
		latePathCommands+=("chattr +"\'"$extendedAttributesToApplyLast"\'" -- "\'"${LFS}${target}"\')
	fi
	if [ ! -z "$extendedAttributesToApplyFirst" ]; then
		latePathCommands+=("chattr +"\'"$extendedAttributesToApplyFirst"\'" -- "\'"${LFS}${target}"\')
	fi
	latePathCommands+=("chown $uid:$gid -- "\'"${LFS}${target}"\')
	latePathCommands+=("chmod "\'"$mode"\'" -- "\'"${LFS}${target}"\')
}

function recurse()
{
	local -r target="$1"
	local -ir mindepth=$2
	local -ir maxdepth=$3
	local -r fileTypeCode="$4"
	local -r callback="$5"
	shift 5
	
	find -P "${LFS}${target}" -depth -mindepth $mindepth -maxdepth $maxdepth -type "$fileTypeCode" -print0 | while IFS= read -r -d $'\0' file
	do
		$callback "$file" "$@"
	done
}

function recurse_callback_permissions()
{
	local -r target="$1"
	local -r mode="$2"
	local -r uid=$3
	local -r gid=$4
	local -r extendedAttributesToApplyFirst="$5"
	local -r extendedAttributesToApplyLast="$6"
	
	chmod "$target" "$mode" -- "$target"
	chown $uid:$gid -- "$target"
	if [ ! -z "$extendedAttributesToApplyFirst" ]; then
		chattr +"$extendedAttributesToApplyFirst" "$target"
	fi
	if [ ! -z "$extendedAttributesToApplyLast" ]; then
		chattr +"$extendedAttributesToApplyLast" "$target"
	fi
}

function permissions_after_recursive()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	local -r extendedAttributesToApplyFirst="$5"
	local -r extendedAttributesToApplyLast="$6"
	local -ir mindepth=$7
	local -ir maxdepth=$8
	# eg directory => d, file => f
	local -r fileTypeCode="${9:0:1}"
	
	if [ "${target:0:1}" != "/" ]; then
		exitError "directory target must be absolute, not $target"
	fi
	
	local -i uid=-1
	for index in ${!users_Name[@]}
	do
		if [ "${users_Name[$index]}" = "$userName" ]; then
			uid=${users_Uid[$index]}
			break
		fi
	done
	if [ $uid -eq -1 ]; then
		exitError "User $userName not defined for target $target"
	fi
	
	local -i gid=-1
	for index in ${!groups_Name[@]}
	do
		if [ "${groups_Name[$index]}" = "$groupName" ]; then
			gid=${groups_Gid[$index]}
			break
		fi
	done
	if [ $gid -eq -1 ]; then
		exitError "Group $groupName not defined for target $target"
	fi
	
	latePathCommands+=("recurse "\'"$target"\'" $mindepth $maxdepth "\'"$fileTypeCode"\'" recurse_callback_permissions "\'"$mode"\'" $uid $gid "\'"$extendedAttributesToApplyFirst"\'" "\'"$extendedAttributesToApplyLast"\')
}

function permissions_before()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	local -r extendedAttributesToApplyFirst="$5"
	
	if [ "${target:0:1}" != "/" ]; then
		exitError "directory target must be absolute, not $target"
	fi
	
	local -i uid=-1
	for index in ${!users_Name[@]}
	do
		if [ "${users_Name[$index]}" = "$userName" ]; then
			uid=${users_Uid[$index]}
			break
		fi
	done
	if [ $uid -eq -1 ]; then
		exitError "User $userName not defined for target $target"
	fi
	
	local -i gid=-1
	for index in ${!groups_Name[@]}
	do
		if [ "${groups_Name[$index]}" = "$groupName" ]; then
			gid=${groups_Gid[$index]}
			break
		fi
	done
	if [ $gid -eq -1 ]; then
		exitError "Group $groupName not defined for target $target"
	fi
	
	earlyPathCommands+=("chmod "\'"$mode"\'" -- "\'"${LFS}${target}"\')
	earlyPathCommands+=("chown $uid:$gid -- "\'"${LFS}${target}"\')
	if [ ! -z "$extendedAttributesToApplyFirst" ]; then
		earlyPathCommands+=("chattr +"\'"$extendedAttributesToApplyFirst"\'" -- "\'"${LFS}${target}"\')
	fi
}

function directory()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	local -r extendedAttributesToApplyFirst="$5"
	local -r extendedAttributesToApplyLast="$6"
	
	permissions_after "$target" "$mode" "$userName" "$groupName" "$extendedAttributesToApplyFirst" "$extendedAttributesToApplyLast"
	
	earlyPathCommands+=("mkdir -p -m "\'"$mode"\'" -- "\'"${LFS}${target}"\')
	
	permissions_before "$target" "$mode" "$userName" "$groupName" "$extendedAttributesToApplyFirst"
}

function symlink()
{
	local -r target="$1"
	local -r contents="$2"
	if [ "${target:0:1}" != "/" ]; then
		exitError "symlink target must be absolute, not $target"
	fi
	
	earlyPathCommands+=("ln -s "\'"$contents"\'" "\'"${LFS}${target}"\')
}

function touch_file()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	local -r extendedAttributesToApplyFirst="$5"
	local -r extendedAttributesToApplyLast="$6"
	
	permissions_after "$target" "$mode" "$userName" "$groupName" "$extendedAttributesToApplyFirst" "$extendedAttributesToApplyLast"
	
	earlyPathCommands+=("touch "\'"${LFS}${target}"\')
	
	permissions_before "$target" "$mode" "$userName" "$groupName" "$extendedAttributesToApplyFirst"
}

function make_character_device()
{
	local -r target="$1"
	local -r deviceMajor="$2"
	local -r deviceMinor="$3"
	local -r mode="$4"
	local -r userName="$5"
	local -r groupName="$6"
	
	permissions_after "$target" "$mode" "$userName" "$groupName" "" ""
	
	earlyPathCommands+=("mknod -m "\'"$mode"\'" "\'"${LFS}${target}"\'" c "\'"$deviceMajor"\'" "\'"$deviceMinor"\')
	
	permissions_before "$target" "$mode" "$userName" "$groupName" ""
}

function make_block_device()
{
	local -r target="$1"
	local -r deviceMajor="$2"
	local -r deviceMinor="$3"
	local -r mode="$4"
	local -r userName="$5"
	local -r groupName="$6"
	
	permissions_after "$target" "$mode" "$userName" "$groupName" "" ""
	
	earlyPathCommands+=("mknod -m "\'"$mode"\'" "\'"${LFS}${target}"\'" b "\'"$deviceMajor"\'" "\'"$deviceMinor"\')
	
	permissions_before "$target" "$mode" "$userName" "$groupName" ""
}

function make_fifo()
{
	local -r target="$1"
	local -r mode="$2"
	local -r userName="$3"
	local -r groupName="$4"
	
	permissions_after "$target" "$mode" "$userName" "$groupName" "" ""
	
	earlyPathCommands+=("mknod -m "\'"$mode"\'" "\'"${LFS}${target}"\'" p")
	
	permissions_before "$target" "$mode" "$userName" "$groupName" ""
}

function source_package_without_download()
{
	case $# in
		1|5)
			:
		;;
		
		*)
			exitError "Needs 1 or 5 arguments"
		;;
	esac
	
	if [ $# -eq 1 ]; then
		local -r ourSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
		local -r ourSourcePackageVersion="$1"
	else
		local -r ourSourcePackageName="$1"
		local -r ourSourcePackageVersion="$2"
	fi
	
	local -r key="$(printKey "$ourSourcePackageName" "$ourSourcePackageVersion")"
	
	# There are very nasty bugs in bash that mean a key can 'already exist' but with the previously added key's value!
	if sourcePackagesKeyExists "$key"; then
		return 0
	fi
	sourcePackages_IndicesToKeys["${#sourcePackages_IndicesToKeys[@]}"]="$key"
	sourcePackages_SourcePackageName["${key}"]="$ourSourcePackageName"
	sourcePackages_Version["${key}"]="$ourSourcePackageVersion"
	sourcePackages_RecipeHash["${key}"]="$LFS_RECIPE_HASH_VALUE"
	
	if [ $# -eq 5 ]; then
		sourcePackages_Compression["${key}"]="$3"
		sourcePackages_FileName["${key}"]="$4"
		sourcePackages_ExtractedTarballFolder["${key}"]="$5"
	fi
}

function source_package_with_download()
{
	if [ $# -lt 3 ]; then
		exitError "Not enough arguments"
	elif [ $# -gt 5 ]; then
		exitError "Too many arguments"
	fi
	
	local -r ourSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
	local -r ourSourcePackageVersion="${LFS_SOURCE_PACKAGE_VERSION["${LFS_SOURCE_PACKAGE_NAME}"]}"
	local -r ourMirror="$1"
	local -r ourRelativePath="$2"
	local -r ourUrl="${ourMirror}${ourRelativePath}"
	local -r ourHashes="$3"
	local -r ourFileName="$(purebash_basename "$ourUrl")"
	
	local -r compressionExtension="${ourFileName##*.}"
	
	if [ $# -ge 4 ]; then
		local -r LFS_EXTRACTED_TARBALL_FOLDER="$4"
	else
		local -r withoutCompressionExtension="${ourFileName%.*}"
		if [ -z "$compressionExtension" ]; then
			local -r LFS_EXTRACTED_TARBALL_FOLDER="$withoutCompressionExtension"
		else
			case "$compressionExtension" in
				
				# The various abominations are also slackware packages (txz, tgz especially)
				tar|tgz|tbz|tbz2|txz|tlz|tlzma|tz|taz)
					local -r LFS_EXTRACTED_TARBALL_FOLDER="$withoutCompressionExtension"
				;;
				
				*)
					local -r LFS_EXTRACTED_TARBALL_FOLDER="${withoutCompressionExtension%.*}"
				;;
				
			esac
		fi
	fi
	
	# TODO:  cpio/cpgz  zip/jar/war/ear  ar/deb  shar  rpm (using rpm2cpio, so we can think of rpm as a compressed cpio file)
	# TODO: support non-tar formats, eg cpio/rpm, zip, ar/deb
	# TODO: split compression from tar for non-tar formats
	#
	
	if [ $# -eq 5 ]; then
		local -r ourCompression="$5"
	else
		case "$compressionExtension" in
			tar)
				local -r ourCompression=''
			;;
			
			gz|tgz)
				local -r ourCompression=gzip
			;;
			
			bz2|bz|tbz2|tbz)
				local -r ourCompression=bzip2
			;;
			
			# Not included in dependencies by default
			# A faster compressor still is lz4
			lzo)
				local -r ourCompression=lzop
			;;
			
			lz|tlz)
				local -r ourCompression=lzip
			;;
			
			lzma|tlzma)
				local -r ourCompression=lzma
			;;
			
			xz|txz)
				local -r ourCompression=xz
			;;
			
			Z|tz|taz)
				# eg gzip downloads
				local -r ourCompression=compress
			;;
			
			*)
				if [ ! -z "$compressionExtension" ]; then
					exitError "Unknown file extension $compressionExtension for $ourSourcePackageName $ourSourcePackageVersion"
				fi
			;;
		esac
	fi
	
	local -r key="$(printKey "$ourSourcePackageName" "$ourSourcePackageVersion")"
	
	# There are very nasty bugs in bash that mean a key can 'already exist' but with the previously added key's value!
	if sourcePackagesKeyExists "$key"; then
		local -r existingUrl="${sourcePackages_Url["${key}"]}"
		if [ "$existingUrl" != "$ourUrl" ]; then
			warning "Attempt to override URL IGNORED for source package $ourSourcePackageName version $ourSourcePackageVersion to $ourUrl from $existingUrl to $ourUrl"
		fi
		return 0
	fi
	
	source_package_without_download "$ourSourcePackageName" "$ourSourcePackageVersion" "$ourCompression" "$ourFileName" "$LFS_EXTRACTED_TARBALL_FOLDER"
	
	sourcePackages_Url["${key}"]="$ourUrl"
	sourcePackages_Hashes["${key}"]="${ourHashes//,/ }"
	sourcePackages_Patches["${key}"]=""
	
	signature "$ourUrl" "${sourcePackages_Hashes["${key}"]}"
}

function patch_download()
{
	if [ $# -ne 3 ]; then
		exitError "Not enough arguments"
	fi
	
	local -r ourSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
	local -r ourVersion="${LFS_SOURCE_PACKAGE_VERSION["${LFS_SOURCE_PACKAGE_NAME}"]}"
	local -r ourMirror="$1"
	local -r ourRelativePath="$2"
	local -r ourUrl="${ourMirror}${ourRelativePath}"
	local -r ourHashes="$3"
	local -r ourFileName="$(purebash_basename "$ourUrl")"
	
	local -r key="$(printKey "$ourSourcePackageName" "$ourVersion")"
	
	# Ensure a tar ball download exists
	if ! sourcePackagesKeyExists "$key"; then
		exitError "No source package exists for patch $ourFileName to $ourSourcePackageName version $ourVersion"
	fi
	
	# Check for duplicate patches
	local -i existingPatchNumber
	for existingPatchNumber in ${sourcePackages_Patches["${key}"]}
	do
		if [ ${patches_FileName[$existingPatchNumber]} = "$ourFileName" ]; then
			if [ ${patches_Url[$existingPatchNumber]} != "$ourUrl" ]; then
				warning "Attempt to override URL IGNORED for patch $ourFileName to $ourSourcePackageName version $ourVersion to $ourUrl"
			fi
			return 0
		fi
	done
	
	local -ir patchNumber=${#patches_Url[@]}
	patches_Url[$patchNumber]="$ourUrl"
	patches_FileName[$patchNumber]="$ourFileName"
	patches_Hashes[$patchNumber]="${ourHashes//,/ }"
	patches_Compression[$patchNumber]=""
	sourcePackages_Patches["${key}"]="${sourcePackages_Patches["${key}"]} $patchNumber"
	
	signature "$ourUrl" "${patches_Hashes[$patchNumber]}"
}

function include_mirror()
{
	if [ $# -ne 1 ]; then
		exitError "Not exactly 1 argument"
	fi
	
	local -r localMirror="$1"
	
	local previousMirror
	for previousMirror in "${previousMirrors[@]}"
	do
		if [ "$previousMirror" = "$localMirror" ]; then
			exitError "Recursion of mirrors - trying to use $localMirror after mirror stack of $previousMirrors"
		fi
	done
	previousMirrors+=("$localMirror")
	
	if [ -f "$mirrorsPath"/"$localMirror".mirrors ]; then
		source "$mirrorsPath"/"$localMirror".mirrors
	else
		exitError "mirrors $localMirror.mirrors does not exist in mirrors path $mirrorsPath or is not a file"
	fi
}

function include_profile()
{
	if [ $# -ne 1 ]; then
		exitError "Not exactly 1 argument"
	fi
	
	local -r localProfile="$1"
	local previousProfile
	for previousProfile in "${previousProfiles[@]}"
	do
		if [ "$previousProfile" = "$localProfile" ]; then
			# Allowed (but ignored)
			return 0
		fi
	done
	previousProfiles+=("$localProfile")
	
	if [ -f "$profilesPath"/"$localProfile".profile ]; then
		source "$profilesPath"/"$localProfile".profile
	else
		exitError "profile $localProfile.profile does not exist in profile path $profilesPath or is not a file"
	fi
}

function version()
{
	if [ $# -ne 1 ]; then
		exitError "Needs 1 argument"
	fi
	local -r localSourcePackageVersion="$1"
	
	local -r previousVersions="${LFS_SOURCE_PACKAGE_VERSIONS["${LFS_SOURCE_PACKAGE_NAME}"]}"
	if [ -z "$previousVersions" ]; then
		LFS_SOURCE_PACKAGE_VERSIONS["${LFS_SOURCE_PACKAGE_NAME}"]="$localSourcePackageVersion"
	else
		LFS_SOURCE_PACKAGE_VERSIONS["${LFS_SOURCE_PACKAGE_NAME}"]="$previousVersions $localSourcePackageVersion"
	fi
	LFS_SOURCE_PACKAGE_VERSION["${LFS_SOURCE_PACKAGE_NAME}"]="$localSourcePackageVersion"
}

declare_for_chroot -a alreadyIncludedOncePerPackages
function include_once_per_package()
{
	local alreadyIncludedOncePerPackage
	for alreadyIncludedOncePerPackage in "${alreadyIncludedOncePerPackages[@]}"
	do
		if [ "$alreadyIncludedOncePerPackage" = "$LFS_SOURCE_PACKAGE_NAME" ]; then
			return 0
		fi
	done
	alreadyIncludedOncePerPackages+=("$LFS_SOURCE_PACKAGE_NAME")
	
	if [ -f "$oncePerPackagePath"/"$LFS_SOURCE_PACKAGE_NAME".include ]; then
		source "$oncePerPackagePath"/"$LFS_SOURCE_PACKAGE_NAME".include
	else
		exitError "include once-per-package $ourSourcePackageName.include does not exist in path $oncePerPackagePath or is not a file"
	fi
}

declare_for_chroot -a alreadyIncludedOncePerVersionKeys
function include_once_per_version()
{
	local -r ourSourcePackageVersion="${LFS_SOURCE_PACKAGE_VERSION["${LFS_SOURCE_PACKAGE_NAME}"]}"
	
	local -r key="$(printKey "$LFS_SOURCE_PACKAGE_NAME" "$ourSourcePackageVersion")"
	
	local alreadyIncludedOncePerVersionKey
	for alreadyIncludedOncePerVersionKey in "${alreadyIncludedOncePerVersionKeys[@]}"
	do
		if [ "$alreadyIncludedOncePerVersionKey" = "$key" ]; then
			return 0
		fi
	done
	alreadyIncludedOncePerVersionKeys+=("$key")
	
	if [ -f "$oncePerVersionPath"/"$LFS_SOURCE_PACKAGE_NAME".include ]; then
		source "$oncePerVersionPath"/"$LFS_SOURCE_PACKAGE_NAME".include
	else
		exitError "include once-per-version $LFS_SOURCE_PACKAGE_NAME.include does not exist in path $oncePerVersionPath or is not a file"
	fi
}

function depends()
{
	if [ $# -ne 1 ]; then
		exitError "Needs 1 argument"
	fi
	
	local -r localSourcePackageName="$1"
	
	local previousRecipe
	for previousRecipe in ${phase_PreviousRecipes["${LFS_PHASE}"]}
	do
		if [ "$previousRecipe" = "$localSourcePackageName" ]; then
			return 0
		fi
	done
	
	local -r recipeFile="$recipesPath"/"$LFS_PHASE"/"$localSourcePackageName".recipe
	
	if [ ! -f "$recipeFile" ]; then
		exitError "recipe $localSourcePackageName ($recipeFile) does not exist or is not a file"
	fi
	
	local -r hashValue="$(sha224sum "$recipeFile" | awk 'NR==1 {print $1}')"
	
	# Weirdly, but usefully, a source'd file has access to our local variables AND can mutate them (it does not run a subshell or stack scope)
	# BUT, and here's the BUT, they won't get passed down to any functions! Darn!
	
	# Prevent recursion
	phase_PreviousRecipes["${LFS_PHASE}"]="${phase_PreviousRecipes["${LFS_PHASE}"]} $localSourcePackageName"
	
	# set / unset inside include_phase
	# Set to blank to avoid bash's associative array bugs with non-existent members (it aliases the last added member)
	LFS_SOURCE_PACKAGE_VERSIONS["${localSourcePackageName}"]=""
	# Holds the last set version - useful for scripting
	LFS_SOURCE_PACKAGE_VERSION["${localSourcePackageName}"]=""
	LFS_SOURCE_PACKAGE_NAME="$localSourcePackageName" LFS_RECIPE_HASH_VALUE="$hashValue" source "$recipeFile"
	unset LFS_SOURCE_PACKAGE_VERSIONS["${localSourcePackageName}"]
	
	# this needs to be the LAST call to version BEFORE depends
	local localSourcePackageVersion
	local key
	local previousDependenciesInstall
	local previousDependency
	for localSourcePackageVersion in ${LFS_SOURCE_PACKAGE_VERSIONS["${localSourcePackageName}"]}
	do
		# Add to installation for phase if not previously added to this phase
		key="$(printKey "$localSourcePackageName" "$localSourcePackageVersion")"
		previousDependenciesInstall="${phase_InstallationOrder["${LFS_PHASE}"]}"
		previousDependency
		for previousDependency in $previousDependenciesInstall
		do
			if [ "$previousDependency" = "$key" ]; then
				break
			fi
		done
		phase_InstallationOrder["${LFS_PHASE}"]="$previousDependenciesInstall $key"
	done
}

function resolved_dependency()
{
	local -r dependencySourcePackageName="$1"
	
	case "$LFS_SOURCE_PACKAGE_NAME" in
		
		gcc)
			
			case "$LFS_SOURCE_PACKAGE_VERSION" in
				
				4.8.1)
					
					case "$dependencySourcePackageName" in
						
						mpc)
							echo 1.0.1
						;;
						
						gmp)
							echo 5.1.2
						;;
						
						mpfr)
							echo 3.1.2
						;;
						
						*)
							exitError "Not yet supported"
						;;
						
					esac
					
				;;
				
				*)
					exitError "Not yet supported"
				;;
				
			esac
		;;
		
		*)
			exitError "Not yet supported"
		;;
		
	esac
}

function conflicts()
{
	if [ $# -ne 2 ]; then
		exitError "Needs 2 arguments"
	fi
	
	local -r localConflictsWithSourcePackageName="$1"
	local -r localConflictsWithVersion="$2"
	local -r key="$(printKey "$localConflictsWithSourcePackageName" "$localConflictsWithVersion")"
	
	local previousDependenciesInstall="${phase_InstallationOrder["${LFS_PHASE}"]}"
	local previousDependency
	local -i alreadyInstalled=1
	for previousDependency in $previousDependenciesInstall
	do
		if [ "$previousDependency" = "$key" ]; then
			exitError "Package $LFS_SOURCE_PACKAGE_NAME conflicts with $localConflictsWithSourcePackageName"
		fi
	done
}

# Also https://www.scaprepo.com/ is a good place to query
# One of the problems is we can only add CPEs post a version is made vulnerable
# eg addCPE 4.2 cpe:/a:gnu:bash:4.2
# Not all CPEs are predictable, eg for java:-
# cpe:/a:oracle:jdk:1.6.0:update_23
# However, in this case, we could 'guess' the CPE based on previously registered ones
# Other CPEs are unversioned, eg this one for gnu gzip:  cpe:/a:gnu:gzip  but also cpe:/a:gnu:gzip:1.2.4 and 
# for maximum confusion, cpe:/a:gnu:gzip:1.2.4a
function addCPE()
{
	if [ $# -ne 2 ]; then
		exitError "Not enough arguments"
	fi
	
	local -r localVersion="$1"
	local -r localCpe="$2"
	
	local -r localSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
	local -r key="$(printKey "$localSourcePackageName" "$localVersion")"
	
	# Ensure a tar ball download exists
	if ! sourcePackagesKeyExists "$key"; then
		exitError "No source package exists for $ourSourcePackageName version $ourVersion"
	fi
}

# Called inside recipe
function addCVE()
{
	if [ $# -ne 2 ]; then
		exitError "Not enough arguments"
	fi
	
	local -r localSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
	local -r cveProductId="$1"
	local -r cveProductName="$2"
	
	# https://cve.mitre.org/data/downloads/allitems.csv.gz
	#
	# https://nvd.nist.gov/download.cfm  eg
	# http://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-recent.xml
	# Contains entry elements, buried within which are cpe-lang expressions (oh, for f's sake, can't people make things simple)?
	# These ultimately reference things like cpe:/a:adobe:coldfusion:9.0 and cpe:/a:adobe:coldfusion:9.0.2 which presumably match affected packages
	# another example is  cpe:/a:eucalyptus:eucalyptus:3.2.1  
	#
	# A php XML parser for the list is at  http://homes.cerias.purdue.edu/~pmeunier/nvd_xml_parser.txt
	# A ruby one is at http://seclists.org/fulldisclosure/2011/Feb/356
	# An old perl one is at http://www.perlmonks.org/?node_id=625277
	
	# holds product definitions (but includes versions, too, irritating)
	# http://static.nvd.nist.gov/feeds/xml/cpe/dictionary/official-cpe-dictionary_v2.3.xml
	#<cpe-item name="cpe:/a:gnu:bash:1.14.0">
	#	<title xml:lang="en-US">GNU Bourne-Again SHellbash (GNU Bash) 1.14.0</title>
	#	<cpe-23:cpe23-item name="cpe:2.3:a:gnu:bash:1.14.0:*:*:*:*:*:*:*"/>
	#</cpe-item>
	# https://web.nvd.nist.gov/view/cpe/search/results?searchChoice=keyword&searchText=bash
	#
	# Not all CVEs are fixed; there's an outstanding one for bash from 1999.
	#
	#
	# CPE -- vendor, product, version
	#
	#
}

function tarExtract()
{
	if [ $# -ne 3 ]; then
		exitError "Not enough arguments"
	fi
	
	local -r tarball="$1"
	local -r tarballFolder="$2"
	local -r tarballCompression="$3"
	
	rm -rf -- "$tarballFolder"
	if [ -z "$ourCompression" ]; then
		tar --extract --file "$tarball"
	else
		tar --extract --$tarballCompression --file "$tarball"
	fi
}

# Assumes it is in the build folder
function extractDependencyIntoBuildFolder()
{
	if [ $# -ne 2 ]; then
		exitError "Needs 2 arguments"
	fi
	
	local -r localSourcePackageName="$1"
	local -r localVersion="$2"
	
	local -r key="$(printKey "$localSourcePackageName" "$localVersion")"
	
	local -r localFileName=${sourcePackages_FileName["${key}"]}
	local -r localExtractedTarballFolder=${sourcePackages_ExtractedTarballFolder["${key}"]}
	local -r localCompression=${sourcePackages_Compression["${key}"]}
	
	if [ -z "$localFileName" ]; then
		progressMessageFailed "No known source package definition for dependency $localSourcePackageName $localVersion"
	fi
	
	tarExtract ../"$localFileName" "$localExtractedTarballFolder" $localCompression
	mv -v "$localExtractedTarballFolder" "$localSourcePackageName"
}

function installPackagePrototype()
{
	./configure --prefix=/"$LFS_TOOLS" $@
	
	make
	
	#make check
	
	make install
}

function createBuildFolderAndPushd()
{
	if [ $# -gt 2 ]; then
		exitError "Too many arguments"
	fi
	
	if [ $# -eq 0 ]; then
		local -r buildFolder=../"$LFS_SOURCE_PACKAGE_NAME"-"$LFS_SOURCE_PACKAGE_VERSION"-build
		rm -rf -- "$buildFolder"
	elif [ $# -eq 2 ]; then
		local -r ourSourcePackageName="$1"
		local -r ourSourcePackageVersion="$2"
		local -r buildFolder=../"$ourSourcePackageName"-"$ourSourcePackageVersion"-build
	else
		exitError "Needs 0 or 2 arguments"
	fi
	
	mkdir -m 0755 -p "$buildFolder"
	pushd "$buildFolder" >/dev/null
}

function popdBuildFolder()
{
	if [ $# -ne 0 ]; then
		exitError "Too many arguments"
	fi
	
	local -r buildFolder=../"$LFS_SOURCE_PACKAGE_NAME"-build
	popd >/dev/null
	#rm -rf -- "$buildFolder"
}
