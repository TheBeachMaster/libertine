set -o errexit +o hashall

function verifyHostSystemRequirementsUsingDependencyChecks()
{
	# Check against http://www.linuxfromscratch.org/lfs/view/development/prologue/hostreqs.html
	
	readonly dependencyChecks="$distributionConfigPath"/dependency-checks
	if [ ! -d "$dependencyChecks" ]; then
		exitError "dependency-checks $dependencyChecks does not exist or is not a directory"
	fi
	
	local debianPackagesToInstallForDependencies=""
	
	pushd "$dependencyChecks" >/dev/null
		local dependencyCheck
		local -i exitCode
		for dependencyCheck in *.dependency-check
		do
			# Used to communicate with subshell, as we can't pass variables back (and we output stdout / stderr to the console)
			temporaryFileToRemoveOnExit
			LFS_CURRENT_DEBIAN_PACKAGES_TEMP="$TMP_FILE"
			# done as subshell to overcome the fact that commands are executing outside of a function
			if ! (source "$dependencyCheck"); then
				if [ -z "$debianPackagesToInstallForDependencies" ]; then
					debianPackagesToInstallForDependencies="$(head -n 1 "$LFS_CURRENT_DEBIAN_PACKAGES_TEMP")"
				else
					debianPackagesToInstallForDependencies="$debianPackagesToInstallForDependencies $(head -n 1 "$LFS_CURRENT_DEBIAN_PACKAGES_TEMP")"
				fi
			fi
		done
	popd >/dev/null

	if [ ! -z "$debianPackagesToInstallForDependencies" ]; then
		if which apt-get 1>/dev/null 2>/dev/null; then
			apt-get --quiet --quiet --yes update
			apt-get --quiet --quiet --yes install $debianPackagesToInstallForDependencies
		fi
	fi
}

function registerDebianPackage()
{
	printf '%s' "$@" >>"$LFS_CURRENT_DEBIAN_PACKAGES_TEMP"
}

function verifyDependency()
{
	if [ $# -lt 2 ]; then
		exitError "Needs at least 2 arguments"
	fi
	if [ $# -gt 3 ]; then
		exitError "Needs no more than 3 arguments"
	fi
	
	local -r sourcePackageName="$1"
	
	local version
	read -r -d$'\n' version
	
	# May be incomplete, eg part of the left-hand regex
	# eg 4.2.25(1)-release might be 4.2
	local -r minimumVersion="$2"
	
	# 0 is equal, =
	# 1 is greater than, >
	# 2 is less than, <
	set +e
	compareVersions "$version" "$minimumVersion"
	local -i comparison=$?
	set -e
	if [ $comparison -eq 2 ]; then
		warning "Dependency $sourcePackageName has a version, $version, less than the minimum known to work, $minimumVersion"
	fi
	
	if [ $# -eq 3 ]; then
		local -r maximumVersion="$3"
		
		set +e
		compareVersions "$version" "$maximumVersion"
		local -i comparison=$?
		set -e
		if [ $comparison -eq 1 ]; then
			warning "Dependency $sourcePackageName has a version, $version, greater than the maximum known to work, $maximumVersion"
		fi
	fi
}

# Derived from http://stackoverflow.com/questions/4023830/bash-how-compare-two-strings-in-version-format
function compareVersions()
{
	if [[ "$1" == "$2" ]]; then
		return 0
	fi
	
	local IFS=.
	local i ver1=($1) ver2=($2)
	
	# fill empty fields in ver1 with zeros
	for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
	do
		ver1[i]=0
	done
	
	for ((i=0; i<${#ver1[@]}; i++))
	do
		if [[ -z ${ver2[i]} ]]; then
			# fill empty fields in ver2 with zeros
			ver2[i]=0
		fi
		if ((10#${ver1[i]} > 10#${ver2[i]})); then
			return 1
		fi
		if ((10#${ver1[i]} < 10#${ver2[i]})); then
			return 2
		fi
	done
	
	return 0
}

function dependencyToPath()
{
	# TODO: Defer the 'current' creation
	local -r relativeOptPath=/opt/lfs
	local -r absoluteOptPath="${LFS}${relativeOptPath}"
	
	local -r relativeOptVersionPath="$relativeOptPath"/"$LFS_DISTRIBUTION_VERSION"
	local -r absoluteOptVersionPath="${LFS}${relativeOptVersionPath}"
	mkdir -m 0755 -p "$absoluteOptVersionPath"
	rm -rf -- "$absoluteOptPath"/current
	ln -s "$LFS_DISTRIBUTION_VERSION" "$absoluteOptPath"/current
	
	local -r relativatePackagePath="$relativeOptVersionPath"/"$LFS_PHASE"/"$LFS_DEPENDENCY_NAME"
	local -r absolutePackagePath="${LFS}${relativatePackagePath}"
	mkdir -m 0755 -p "$absolutePackagePath"
	
	local -r relativeVersionPath="$relativatePackagePath"/"$LFS_DEPENDENCY_VERSION"
	local -r absoluteVersionPath="${LFS}${relativeVersionPath}"
	mkdir -m 0755 -p "$absoluteVersionPath"
	rm -rf -- "$absolutePackagePath"/current
	ln -s "$LFS_DEPENDENCY_VERSION" "$absolutePackagePath"/current
	
	# Find and hash dependencies
	temporaryFileToRemoveOnExit
	local -r dependenciesFileUnsorted="$TMP_FILE"
	temporaryFileToRemoveOnExit
	local -r dependenciesFileSorted="$TMP_FILE"
	local dependency
	local name
	declare -A dependencyRelativePaths=()
	for dependency in ${dependency_Dependencies["$LFS_DEPENDENCY_KEY"]}
	do
		printf '%s\0' "${dependency_Path["$dependency"]}" >>"$dependenciesFileUnsorted"
		name="${dependency_Name["$dependency"]}"
		dependencyRelativePaths["$name"]="${dependency_RelativePath["$dependency"]}"
	done
	# --stable and LC_ALL=C to ensure a consistent sort order before hashing
	LC_ALL=C sort --key=1 --stable --zero-terminated "$dependenciesFileUnsorted" >"$dependenciesFileSorted"
	local -r dependenciesHash="$(sha256sum "$dependenciesFileSorted" | awk 'NR==1 {print $1}')"
	
	
	local -r recipeVersion="$LFS_DEPENDENCY_RECIPE_HASH"-"$LFS_DEPENDENCY_SETTINGS_HASH"-"$dependenciesHash"
	local -r relativeCompletePath="$relativeVersionPath"/"$recipeVersion"
	local -r absoluteCompletePath="${LFS}${relativeCompletePath}"
	
	dependency_Path["$LFS_DEPENDENCY_KEY"]="$relativeCompletePath"
	dependency_RelativePath["$LFS_DEPENDENCY_KEY"]="$LFS_PHASE"/"$LFS_DEPENDENCY_NAME"/"$LFS_DEPENDENCY_VERSION"/"$recipeVersion"
	dependency_RecipeSettingsDependencies["$LFS_DEPENDENCY_KEY"]="$recipeVersion"
	
	
	
	
	if [ -f "$absoluteCompletePath"/installed ]; then
		return 0
	fi
	
	# chattr -R doesn't work on symlinks, etc; it's useless
	if [ -d "$absoluteCompletePath" ]; then
		find "$absoluteCompletePath" -type f -print0 | xargs -0 -n 10 chattr -aijsu "$absoluteCompletePath"
		find "$absoluteCompletePath" -type d -print0 | xargs -0 -n 10 chattr -aiD "$absoluteCompletePath"
	fi
	
	rm -rf -- "$absoluteCompletePath"
	
	mkdir -m 0755 -p "$absoluteCompletePath"
	chown ${LFS_DEPENDENCY_UID}:${LFS_DEPENDENCY_GID} "$absoluteCompletePath"
	rm -rf -- "$absoluteVersionPath"/recipe-settings-dependencies
	ln -s "$recipeVersion" "$absoluteVersionPath"/recipe-settings-dependencies
	rm -rf -- "$absoluteVersionPath"/current
	ln -s recipe-settings-dependencies "$absoluteVersionPath"/current
	
	
	sudo -u \#${LFS_DEPENDENCY_UID} -g \#${LFS_DEPENDENCY_GID} -- mkdir -m 0755 -p "$absoluteCompletePath"/install
	
	sudo -u \#${LFS_DEPENDENCY_UID} -g \#${LFS_DEPENDENCY_GID} -- mkdir -m 0755 -p "$absoluteCompletePath"/binpath
	
	sudo -u \#${LFS_DEPENDENCY_UID} -g \#${LFS_DEPENDENCY_GID} -- mkdir -m 0755 -p "$absoluteCompletePath"/log
	
	
	# Copy in source and patches from download cache
	sudo -u \#${LFS_DEPENDENCY_UID} -g \#${LFS_DEPENDENCY_GID} -- mkdir -m 0755 -p "$absoluteCompletePath"/source
	
	
	local -i index
	for index in ${dependency_SourcePackageIndices["$LFS_DEPENDENCY_KEY"]}
	do
		linkOrCopyFile "${sourcePackages_Mirror[$index]}" "${sourcePackages_RelativePath[$index]}" "$absoluteCompletePath"/source "${sourcePackages_FileName[$index]}"
	done
	
	for index in $LFS_DEPENDENCY_PATCHES
	do
		linkOrCopyFile "${patches_Mirror[$index]}" "${patches_RelativePath[$index]}" "$absoluteCompletePath"/source "${patches_FileName[$index]}"
	done
	# There may not have been any files copied
	chmod 0644 -- "$absoluteCompletePath"/source/* 1>/dev/null 2>/dev/null || true
	chown ${LFS_DEPENDENCY_UID}:${LFS_DEPENDENCY_GID} -- "$absoluteCompletePath"/source/* 1>/dev/null 2>/dev/null || true
	
	
	cp "$dependenciesFileSorted" "$absoluteCompletePath"/dependencies.list
	chown ${LFS_DEPENDENCY_UID}:${LFS_DEPENDENCY_GID} "$absoluteCompletePath"/dependencies.list
	chmod 0400 "$absoluteCompletePath"/dependencies.list
	
	local -r absoluteDependenciesPath="$absoluteCompletePath"/dependencies
	mkdir -m 0755 -p "$absoluteDependenciesPath"
	local dependencyName
	local dependencyPath
	for dependencyName in "${!dependencyRelativePaths[@]}"
	do
		ln -s ../../../../../"${dependencyRelativePaths["$dependencyName"]}" "$absoluteDependenciesPath"/"$dependencyName"
	done
	
	cp "$recipesPath"/"$LFS_PHASE"/"$LFS_DEPENDENCY_NAME".recipe "$absoluteCompletePath"/recipe
	if [ "$LFS_DEPENDENCY_INCLUDE_HASH" != "0" ]; then
		cp "$includesPath"/"$LFS_DEPENDENCY_NAME".include "$absoluteCompletePath"/include
	fi

	if [ -f "$settingsPath"/"$LFS_PHASE"/"$LFS_DEPENDENCY_NAME".config ]; then
		cp "$settingsPath"/"$LFS_PHASE"/"$LFS_DEPENDENCY_NAME".config "$absoluteCompletePath"/config
	fi

	if [ -f "$settingsPath"/"$LFS_PHASE"/"$LFS_DEPENDENCY_NAME".settings ]; then
		cp "$settingsPath"/"$LFS_PHASE"/"$LFS_DEPENDENCY_NAME".settings "$absoluteCompletePath"/settings
	fi
}

function lfs_dependency_includes()
{
	declare -Ag LFS_DEPENDENCY_INCLUDE_VERSIONS
	local -i index
	local name
	local version
	for index in ${dependency_IncludeIndices["$LFS_DEPENDENCY_KEY"]}
	do
		name="${includes_Name[$index]}"
		version="${includes_Version[$index]}"
		LFS_DEPENDENCY_INCLUDE_VERSIONS["$name"]="$version"
	done
}

function prepareZzzLfsPath()
{
	local dependencyKey
	LFS_DEPENDENCY_KEY_ZZZ=""
	for dependencyKey in ${!dependency_Name[@]}
	do
		if [ "${dependency_Phase["$dependencyKey"]}" != "$LFS_PHASE" ]; then
			continue
		fi
		
		if [ "${dependency_Name["$dependencyKey"]}" = "zzz-lfs" ]; then
			LFS_DEPENDENCY_KEY_ZZZ="$dependencyKey"
			break
		fi
	done
	
	if [ -z "$LFS_DEPENDENCY_KEY_ZZZ" ]; then
		exitError "zzz-lfs dependency not found"
	fi

	LFS_DEPENDENCY_PATH_ZZZ="${dependency_Path["$LFS_DEPENDENCY_KEY_ZZZ"]}"
	LFS_DEPENDENCY_RELATIVE_PATH_ZZZ="${dependency_RelativePath["$LFS_DEPENDENCY_KEY_ZZZ"]}"
	LFS_DEPENDENCY_RECIPE_SETTINGS_DEPENDENCIES_ZZZ="${dependency_RecipeSettingsDependencies["$LFS_DEPENDENCY_KEY_ZZZ"]}"
	LFS_DEPENDENCY_PREFIX_PATH_ZZZ="$LFS_DEPENDENCY_PATH"/install
	
	pathToRootOfChroot "$LFS_DEPENDENCY_PREFIX_PATH_ZZZ"
	LFS_DEPENDENCY_RELATIVE_PATH_TO_ROOT_FROM_INSTALL_FOLDER_ZZZ="$PathToRoot"
	
	LFS_DEPENDENCY_SKIP_INSTALL_ZZZ="${dependency_SkipInstall["$LFS_DEPENDENCY_KEY_ZZZ"]}"
	
	if [ "$LFS_PHASE" = "system" ]; then
		LFS_DEPENDENCY_ROOT=""
	else
		LFS_DEPENDENCY_ROOT="$LFS"
	fi
	LFS_DEPENDENCY_PACKAGE_PATH_ZZZ="${LFS_DEPENDENCY_ROOT}${LFS_DEPENDENCY_PATH_ZZZ}"
	LFS_DEPENDENCY_INSTALL_PATH_ZZZ="$LFS_DEPENDENCY_PACKAGE_PATH_ZZZ"/install
	LFS_DEPENDENCY_BINPATH_PATH_ZZZ="$LFS_DEPENDENCY_PACKAGE_PATH_ZZZ"/binpath
	LFS_DEPENDENCY_SOURCE_PATH_ZZZ="$LFS_DEPENDENCY_PACKAGE_PATH_ZZZ"/source
	LFS_DEPENDENCY_LOG_PATH_ZZZ="$LFS_DEPENDENCY_PACKAGE_PATH_ZZZ"/log
	LFS_DEPENDENCY_INSTALLED_PATH_ZZZ="$LFS_DEPENDENCY_PACKAGE_PATH_ZZZ"/installed
	
	mkdir -m 0755 -p "$LFS_DEPENDENCY_BINPATH_PATH_ZZZ"
	
	mkdir -m 0755 -p "$LFS_DEPENDENCY_INSTALL_PATH_ZZZ"/bin
}

function prepareMuslCrossPath()
{
	local dependencyKey
	LFS_DEPENDENCY_KEY_MUSL_CROSS=""
	for dependencyKey in ${!dependency_Name[@]}
	do
		if [ "${dependency_Phase["$dependencyKey"]}" != "crosscompiler" ]; then
			continue
		fi
		
		if [ "${dependency_Name["$dependencyKey"]}" = "musl-cross" ]; then
			LFS_DEPENDENCY_KEY_MUSL_CROSS="$dependencyKey"
			break
		fi
	done
	
	if [ -z "$LFS_DEPENDENCY_KEY_MUSL_CROSS" ]; then
		exitError "musl-cross dependency not found"
	fi

	LFS_DEPENDENCY_PATH_MUSL_CROSS="${dependency_Path["$LFS_DEPENDENCY_KEY_MUSL_CROSS"]}"
	LFS_DEPENDENCY_RELATIVE_PATH_MUSL_CROSS="${dependency_RelativePath["$LFS_DEPENDENCY_KEY_MUSL_CROSS"]}"
	LFS_DEPENDENCY_RECIPE_SETTINGS_DEPENDENCIES_MUSL_CROSS="${dependency_RecipeSettingsDependencies["$LFS_DEPENDENCY_KEY_MUSL_CROSS"]}"
	LFS_DEPENDENCY_PREFIX_PATH_MUSL_CROSS="$LFS_DEPENDENCY_PATH_MUSL_CROSS"/install
	
	pathToRootOfChroot "$LFS_DEPENDENCY_PREFIX_PATH_MUSL_CROSS"
	LFS_DEPENDENCY_RELATIVE_PATH_TO_ROOT_FROM_INSTALL_FOLDER_MUSL_CROSS="$PathToRoot"
	
	LFS_DEPENDENCY_SKIP_INSTALL_MUSL_CROSS="${dependency_SkipInstall["$LFS_DEPENDENCY_KEY_MUSL_CROSS"]}"
	
	if [ "$LFS_PHASE" = "system" ]; then
		LFS_DEPENDENCY_ROOT=""
	else
		LFS_DEPENDENCY_ROOT="$LFS"
	fi
	LFS_DEPENDENCY_PACKAGE_PATH_MUSL_CROSS="${LFS_DEPENDENCY_ROOT}${LFS_DEPENDENCY_PATH_MUSL_CROSS}"
	LFS_DEPENDENCY_INSTALL_PATH_MUSL_CROSS="$LFS_DEPENDENCY_PACKAGE_PATH_MUSL_CROSS"/install
	LFS_DEPENDENCY_BINPATH_PATH_MUSL_CROSS="$LFS_DEPENDENCY_PACKAGE_PATH_MUSL_CROSS"/binpath
	LFS_DEPENDENCY_SOURCE_PATH_MUSL_CROSS="$LFS_DEPENDENCY_PACKAGE_PATH_MUSL_CROSS"/source
	LFS_DEPENDENCY_LOG_PATH_MUSL_CROSS="$LFS_DEPENDENCY_PACKAGE_PATH_MUSL_CROSS"/log
	LFS_DEPENDENCY_INSTALLED_PATH_MUSL_CROSS="$LFS_DEPENDENCY_PACKAGE_PATH_MUSL_CROSS"/installed
	
	LFS_C_HOST_PREFIX="$LFS_NATIVE_TRIPLE"-
	LFS_C_HOST_CC="${LFS_C_TARGET_EXTERNAL_PREFIX}gcc"
	LFS_C_HOST_CXX="${LFS_C_TARGET_EXTERNAL_PREFIX}g++"
	# Not sure if the final triple should be in or out
	LFS_C_HOST_SYS_ROOT="$LFS_DEPENDENCY_INSTALL_PATH_MUSL_CROSS/$LFS_NATIVE_TRIPLE/$LFS_NATIVE_TRIPLE"
	LFS_C_HOST_LIB_ROOT="$LFS_DEPENDENCY_INSTALL_PATH_MUSL_CROSS/$LFS_NATIVE_TRIPLE/$LFS_NATIVE_TRIPLE"
	LFS_C_HOST_DYNAMIC_LINKER="$LFS_C_HOST_LIB_ROOT/lib/ld-musl-$LFS_NATIVE_ARCHITECTURE.so.1"
	LFS_C_HOST_SPECS="-isysroot $LFS_C_HOST_SYSROOT --sysroot $LFS_C_HOST_SYSROOT -Wl,--sysroot=$LFS_C_HOST_SYSROOT -Wl,--dynamic-linker=$LFS_C_HOST_DYNAMIC_LINKER -Wl,-rpath=$LFS_C_HOST_LIB_ROOT/lib"
	LFS_C_HOST_CPPFLAGS=""
	LFS_C_HOST_CFLAGS="$LFS_C_HOST_SPECS $LFS_LDFLAGS_MUSL $LFS_CFLAGS_NATIVE_OPTIMISATION $LFS_CFLAGS_HARDENING $LFS_LDFLAGS_OPTIMISATION"
	LFS_C_HOST_CXXFLAGS="$LFS_C_HOST_CFLAGS"
	LFS_C_HOST_LDFLAGS=""
	#LFS_C_HOST_LIBS=""
	
	LFS_C_TARGET_EXTERNAL_PREFIX="$LFS_FOREIGN_TRIPLE"-
	LFS_C_TARGET_EXTERNAL_CC="${LFS_C_TARGET_EXTERNAL_PREFIX}gcc"
	LFS_C_TARGET_EXTERNAL_CXX="${LFS_C_TARGET_EXTERNAL_PREFIX}g++"
	LFS_C_TARGET_EXTERNAL_AR="${LFS_C_TARGET_EXTERNAL_PREFIX}ar"
	LFS_C_TARGET_EXTERNAL_AS="${LFS_C_TARGET_EXTERNAL_PREFIX}as"
	LFS_C_TARGET_EXTERNAL_NM="${LFS_C_TARGET_EXTERNAL_PREFIX}nm"
	LFS_C_TARGET_EXTERNAL_RANLIB="${LFS_C_TARGET_EXTERNAL_PREFIX}ranlib"
	LFS_C_TARGET_EXTERNAL_OBJDUMP="${LFS_C_TARGET_EXTERNAL_PREFIX}objdump"
	LFS_C_TARGET_EXTERNAL_LD="${LFS_C_TARGET_EXTERNAL_PREFIX}ld"
	LFS_C_TARGET_EXTERNAL_STRIP="${LFS_C_TARGET_EXTERNAL_PREFIX}strip"
	LFS_C_TARGET_EXTERNAL_SYS_ROOT="$LFS_DEPENDENCY_INSTALL_PATH_MUSL_CROSS/$LFS_FOREIGN_TRIPLE/$LFS_FOREIGN_TRIPLE"
	LFS_C_TARGET_EXTERNAL_LIB_ROOT="$LFS_DEPENDENCY_INSTALL_PATH_MUSL_CROSS/$LFS_FOREIGN_TRIPLE/$LFS_FOREIGN_TRIPLE"
	LFS_C_TARGET_EXTERNAL_DYNAMIC_LINKER="$LFS_C_TARGET_EXTERNAL_LIB_ROOT/lib/ld-musl-$LFS_FOREIGN_ARCHITECTURE.so.1"
	LFS_C_TARGET_EXTERNAL_SPECS="-isysroot $LFS_C_TARGET_EXTERNAL_SYS_ROOT --sysroot $LFS_C_TARGET_EXTERNAL_SYS_ROOT -Wl,--sysroot=$LFS_C_TARGET_EXTERNAL_SYS_ROOT -Wl,--dynamic-linker=$LFS_C_TARGET_EXTERNAL_DYNAMIC_LINKER -Wl,-rpath=$LFS_C_TARGET_EXTERNAL_LIB_ROOT/lib -Wl,-rpath-link=$LFS_C_HOST_LIB_ROOT/lib"
	LFS_C_TARGET_EXTERNAL_CPPFLAGS=""
	LFS_C_TARGET_EXTERNAL_CFLAGS="$LFS_C_TARGET_EXTERNAL_SPECS $LFS_LDFLAGS_MUSL $LFS_CFLAGS_NATIVE_OPTIMISATION $LFS_CFLAGS_HARDENING $LFS_LDFLAGS_OPTIMISATION"
	LFS_C_TARGET_EXTERNAL_CXXFLAGS="$LFS_C_TARGET_EXTERNAL_CFLAGS"
	LFS_C_TARGET_EXTERNAL_LDFLAGS=""
	#LFS_C_TARGET_EXTERNAL_LIBS=""
	LFS_C_TARGET_EXTERNAL_CFLAGS_STATIC="$LFS_C_TARGET_EXTERNAL_CFLAGS -static"
	LFS_C_TARGET_EXTERNAL_CXXFLAGS_STATIC="$LFS_C_TARGET_EXTERNAL_CXXFLAGS -static"
	
	LFS_C_TARGET_INTERNAL_PREFIX="$LFS_FOREIGN_TRIPLE"-
	LFS_C_TARGET_INTERNAL_CC="${LFS_C_TARGET_INTERNAL_PREFIX}gcc"
	LFS_C_TARGET_INTERNAL_CXX="${LFS_C_TARGET_INTERNAL_PREFIX}g++"
	LFS_C_TARGET_INTERNAL_AR="${LFS_C_TARGET_INTERNAL_PREFIX}ar"
	LFS_C_TARGET_INTERNAL_AS="${LFS_C_TARGET_INTERNAL_PREFIX}as"
	LFS_C_TARGET_INTERNAL_NM="${LFS_C_TARGET_INTERNAL_PREFIX}nm"
	LFS_C_TARGET_INTERNAL_RANLIB="${LFS_C_TARGET_INTERNAL_PREFIX}ranlib"
	LFS_C_TARGET_INTERNAL_OBJDUMP="${LFS_C_TARGET_INTERNAL_PREFIX}objdump"
	LFS_C_TARGET_INTERNAL_LD="${LFS_C_TARGET_INTERNAL_PREFIX}ld"
	LFS_C_TARGET_INTERNAL_STRIP="${LFS_C_TARGET_INTERNAL_PREFIX}strip"
	LFS_C_TARGET_EXTERNAL_SYS_ROOT="$LFS_DEPENDENCY_PREFIX_PATH_MUSL_CROSS/$LFS_FOREIGN_TRIPLE/$LFS_FOREIGN_TRIPLE"
	LFS_C_TARGET_INTERNAL_LIB_ROOT="$LFS_DEPENDENCY_PREFIX_PATH_MUSL_CROSS/$LFS_FOREIGN_TRIPLE/$LFS_FOREIGN_TRIPLE"
	LFS_C_TARGET_INTERNAL_DYNAMIC_LINKER="$LFS_C_TARGET_INTERNAL_LIB_ROOT/lib/ld-musl-$LFS_FOREIGN_ARCHITECTURE.so.1"
	LFS_C_TARGET_INTERNAL_SPECS="-isysroot $LFS_C_TARGET_EXTERNAL_SYS_ROOT --sysroot $LFS_C_TARGET_EXTERNAL_SYS_ROOT -Wl,--sysroot=$LFS_C_TARGET_EXTERNAL_SYS_ROOT -Wl,--dynamic-linker=$LFS_C_TARGET_INTERNAL_DYNAMIC_LINKER -Wl,-rpath=$LFS_C_TARGET_INTERNAL_LIB_ROOT/lib"
	LFS_C_TARGET_INTERNAL_CPPFLAGS=""
	LFS_C_TARGET_INTERNAL_CFLAGS="$LFS_C_TARGET_INTERNAL_SPECS $LFS_LDFLAGS_MUSL $LFS_CFLAGS_NATIVE_OPTIMISATION $LFS_CFLAGS_HARDENING $LFS_LDFLAGS_OPTIMISATION"
	LFS_C_TARGET_INTERNAL_CXXFLAGS="$LFS_C_TARGET_INTERNAL_CFLAGS"
	LFS_C_TARGET_INTERNAL_LDFLAGS=""
	#LFS_C_TARGET_INTERNAL_LIBS=""
	LFS_C_TARGET_INTERNAL_CFLAGS_STATIC="$LFS_C_TARGET_INTERNAL_CFLAGS -static"
	LFS_C_TARGET_INTERNAL_CXXFLAGS_STATIC="$LFS_C_TARGET_INTERNAL_CXXFLAGS -static"
}

# Removes SUID
# Removes GUID
# Removes sticky bit
# Removes chattr, then makes files and folders unalterable
# Removes capabilities
# Strips symbols
function lockDownPermissions()
{
	chattr -DdjsStuai "$LFS_DEPENDENCY_INSTALL_PATH"
	pushd "$LFS_DEPENDENCY_INSTALL_PATH" >/dev/null
	
		local topLevelFolder
		local permissions
		for topLevelFolder in *
		do
			# No files
			if [ ! -e "$topLevelFolder" ]; then
				continue
			fi
			
			# Link
			if [ -L "$topLevelFolder" ]; then
				continue
			# File
			elif [ -f "$topLevelFolder" ]; then
				# d - Remove dump ignore
				# j - Remove forced journalling (rely on file system)
				# s - Remove zeroing of contents on delete (slow, buggy and better supported using an encrypted file system)
				# S - Remove any synchronised writes
				# t - Remove tail-merging (buggy and unnecessary)
				# u - Remove undeletion
				# Note, we leave c, compression, alone
				# Note, we leave C (disable copy-on-write for BTRFS), alone
				chattr -djsStuai "$topLevelFolder"
				
				# Remove any ACLs (unlikely)
				setfacl --physical --remove-all --remove-default -- "$topLevelFolder"
				
				# Bizarrely, +a prevents chown / chmod working, but not +i (immutable) (hence removal above)
				# We strip all regular permissions, including write, sticky, suid, guid and execute; these MUST be restored by exception
				if [ -x "$topLevelFolder" ]; then
					echo "Removing execute permissions from $topLevelFolder"
				
					# Strip unneeded symbols (don't bother if errors)
					chmod 0666 "$topLevelFolder"
					strip --strip-unneeded "$topLevelFolder" 1>/dev/null 2>/dev/null || true
				else
					# Strip debug symbols (don't bother if errors); if these are libraries, don't use --strip-unneeded
					chmod 0666 "$topLevelFolder"
					strip --strip-debug "$topLevelFolder" 1>/dev/null 2>/dev/null || true
				fi
				
				# Remove any capabilities (unlikely); errors if no capabilities set (annoying)
				setcap -r "$topLevelFolder" 2>/dev/null || true
				
				chmod 0444 "$topLevelFolder"
				
				# A - atime not recorded
				# a - append-only (means vi will be broken)
				# i - immutable (even to root)
				chattr +Aai "$topLevelFolder"
			# Folder
			elif [ -d "$topLevelFolder" ]; then
				
				# Remove options from folders; we do not use chattr -R because attributes of the same name apply differently on files and folders
				# Usually an useless attribute is ignored, but some (eg +C on btrfs) have undefined behaviour
				# Disable Copy-on-Write and compression really need to be configured BEFORE a file is written (eg for /var/log/*, /usr/man/*, /usr/share/*, etc)

				# D - Remove dirsync
				# d - Remove dump ignore
				# j - Remove forced journalling (rely on file system)
				# s - Remove zeroing of contents on delete (slow, buggy and better supported using an encrypted file system)
				# S - Remove any synchronised writes
				# t - Remove tail-merging (buggy and unnecessary)
				# u - Remove undeletion
				# Note, we leave c, compression, alone
				# Note, we leave C (copy-on-write for BTRFS), alone; we can not set this with old versions of chattr
				# Note we leave T, Orlov block allocation, alone
				find "$topLevelFolder" -type d -print0 | xargs -0 -r -n 10 chattr -DdjsStuai
				find "$topLevelFolder" -type f -print0 | xargs -0 -r -n 10 chattr -djsStuai
				
				# Remove any ACLs (unlikely)
				setfacl --physical --recursive --remove-all --remove-default -- "$topLevelFolder"
				
				# We strip all dangerous permissions (Sticky bit, set suid, set guid); these must be restored by exception
				find "$topLevelFolder" -type d -print0 | xargs -0 -r -n 10 chmod 0555
				find "$topLevelFolder" -type f -perm -0111 -print0 | xargs -0 -r -n 1 echo "Removing execute permissions from"
				find "$topLevelFolder" -type f -print0 | xargs -0 -r -n 10 chmod 0444
				
				# block, char, named pipe, socket likewise
				find "$topLevelFolder" -type b -print0 | xargs -0 -r -n 10 chmod 0444
				find "$topLevelFolder" -type c -print0 | xargs -0 -r -n 10 chmod 0444
				find "$topLevelFolder" -type p -print0 | xargs -0 -r -n 10 chmod 0444
				find "$topLevelFolder" -type s -print0 | xargs -0 -r -n 10 chmod 0444
				
				# A - no atime
				# a - append-only
				# i - immutable
				# c - compress (can not be applied sensibly to existing files)
				find "$topLevelFolder" -type f -print0 | xargs -0 -r -n 10 chattr +Aai
				find "$topLevelFolder" -type d -print0 | xargs -0 -r -n 10 chattr +Aaic
			# block, char, named pipe, socket
			else
				chmod 0644 "$topLevelFolder"
			fi
		done
		
	popd >/dev/null
	
	chmod 0555 "$LFS_DEPENDENCY_INSTALL_PATH"
	chattr +Aai "$LFS_DEPENDENCY_INSTALL_PATH"
}

function setSetuidBinaries()
{
	local relativeBinaryPath
	local binary
	for relativeBinaryPath in ${dependency_SetuidBinaryInstallPaths["$LFS_DEPENDENCY_KEY"]}
	do
		binary="$LFS_DEPENDENCY_INSTALL_PATH"/"$relativeBinaryPath"
			
		if [ ! -f "$binary" ]; then
			exitError "Path $binary is not a file"
		fi
		
		chattr -ai "$binary"
		chmod u+s "$binary"
		chattr +ai "$binary"
	done
}

function setSetgidBinaries()
{
	local relativeBinaryPath
	local binary
	for relativeBinaryPath in ${dependency_SetgidBinaryInstallPaths["$LFS_DEPENDENCY_KEY"]}
	do
		binary="$LFS_DEPENDENCY_INSTALL_PATH"/"$relativeBinaryPath"
			
		if [ ! -f "$binary" ]; then
			exitError "Path $binary is not a file"
		fi
		
		chattr -ai "$binary"
		chmod g+s "$binary"
		chattr +ai "$binary"
	done
}

function setOtherExecutableBinaries()
{
	local relativeBinaryPath
	local binary
	local file
	local resolvedBinary
	for relativeBinaryPath in ${dependency_OtherwiseExecutableBinaryInstallPaths["$LFS_DEPENDENCY_KEY"]}
	do
		binary="$LFS_DEPENDENCY_INSTALL_PATH"/"$relativeBinaryPath"
		
		if [ -f "$binary" ]; then
			chattr -ai "$binary"
			chmod a+x "$binary"
			chattr +ai "$binary"
			
			continue
		fi
		
		if [ ! -d "$binary" ]; then
			exitError "Path $binary is not a file or directory"
		fi
		
		pushd "$binary" >/dev/null
			for file in *
			do
				if [ ! -e "$file" ]; then
					continue
				elif [ -L "$file" ]; then
					if ! readlink --canonicalize-existing --no-newline "$file" 1>/dev/null 2>/dev/null; then
						exitError "$file in $(pwd) does not point to an extant file"
					fi
					resolvedBinary="$(readlink --canonicalize-existing --no-newline "$file")"
					if [ ! -f "$resolvedBinary" ]; then
						exitError "$file in $(pwd) points to something ($resolvedBinary) that is not a file"
					fi
					
					chattr -ai "$resolvedBinary"
					chmod a+x "$resolvedBinary"
					chattr +ai "$resolvedBinary"
				elif [ -f "$file" ]; then
					chattr -ai "$file"
					chmod a+x "$file"
					chattr +ai "$file"
				fi
			done
		popd >/dev/null
		
	done
}

function installBinariesToPackagePath()
{
	local relativeLocationOfBinaries
	local binary
	local resolvedBinary
	local sourceBinary
	local targetBinary
	for relativeLocationOfBinaries in ${dependency_BinaryInstallPaths["$LFS_DEPENDENCY_KEY"]}
	do
		# Allows a per-file option, eg for binaries inside /lib folders
		if [ -f "$LFS_DEPENDENCY_INSTALL_PATH"/"$relativeLocationOfBinaries" ]; then
			
			pushd "$(purebash_dirname "$LFS_DEPENDENCY_INSTALL_PATH"/"$relativeLocationOfBinaries")" >/dev/null
				
				binary="$(purebash_basename "$relativeLocationOfBinaries")"

				if [ -L "$binary" ]; then
					resolvedBinary="$(readlink --canonicalize-existing --no-newline "$binary")"
					if [ ! -f "$resolvedBinary" ]; then
						exitError "$binary in $(pwd) points to something ($resolvedBinary) that is not a file"
					fi
					chattr -ai "$resolvedBinary"
					chmod a+x "$resolvedBinary"
					chattr +ai "$resolvedBinary"
				else
					chattr -ai "$binary"
					chmod a+x "$binary"
					chattr +ai "$binary"
				fi
				
				sourceBinary=../install/"$relativeLocationOfBinaries"
				targetBinary="$LFS_DEPENDENCY_BINPATH_PATH"/"$binary"
				
				if [ -e "$targetBinary" ]; then
					rm -rf -- "$targetBinary"
				fi
	
				ln -s "$sourceBinary" "$targetBinary"
				
			popd >/dev/null
			
			continue
		fi
		
		if [ ! -d "$LFS_DEPENDENCY_INSTALL_PATH"/"$relativeLocationOfBinaries" ]; then
			exitError "Path $LFS_DEPENDENCY_INSTALL_PATH"/"$relativeLocationOfBinaries is neither a file or folder (symlinks are not permitted)"
		fi
		
		pushd "$LFS_DEPENDENCY_INSTALL_PATH"/"$relativeLocationOfBinaries" >/dev/null
			for binary in *
			do
				# ie if called '*' because no files are present
				if [ ! -e "$binary" ]; then
					continue
				fi
				
				# block device
				if [ -b "$binary" ]; then
					continue
				fi

				# character device
				if [ -c "$binary" ]; then
					continue
				fi
			
				# directory
				if [ -d "$binary" ]; then
					continue
				fi
			
				# named pipe (fifo)
				if [ -p "$binary" ]; then
					continue
				fi
			
				# socket
				if [ -S "$binary" ]; then
					continue
				fi
			
				# Link
				if [ -L "$binary" ]; then
					if ! readlink --canonicalize-existing --no-newline "$binary" 1>/dev/null 2>/dev/null; then
						exitError "$binary in $(pwd) does not point to an extant file"
					fi
					resolvedBinary="$(readlink --canonicalize-existing --no-newline "$binary")"
					if [ ! -f "$resolvedBinary" ]; then
						exitError "$binary in $(pwd) points to something ($resolvedBinary) that is not a file"
					fi
					
					chattr -ai "$resolvedBinary"
					chmod a+x "$resolvedBinary"
					chattr +ai "$resolvedBinary"
				elif [ -f "$binary" ]; then
					chattr -ai "$binary"
					chmod a+x "$binary"
					chattr +ai "$binary"
				fi
				
				sourceBinary=../install/"$relativeLocationOfBinaries"/"$binary"
				targetBinary="$LFS_DEPENDENCY_BINPATH_PATH"/"$binary"
				
				if [ -e "$targetBinary" ]; then
					rm -rf -- "$targetBinary"
				fi
	
				ln -s "$sourceBinary" "$targetBinary"
			done
		popd >/dev/null
	done
}

function installPackagePathBinariesToPath()
{
	if [ "$LFS_DEPENDENCY_NAME" = 'zzz-lfs' ]; then
		continue
	fi
	
	# Why is it sealed? Recipes not changed, but something never finished installing?
	chattr -R -ai "$LFS_DEPENDENCY_BINPATH_PATH" 2>/dev/null || true
	
	pushd "$LFS_DEPENDENCY_BINPATH_PATH" >/dev/null

		local binary
		local sourceBinary
		local targetBinary
		local currentBinary
		for binary in *
		do
			if [ ! -e "$binary" ]; then
				continue
			fi
			
			if [ ! -L "$binary" ]; then
				continue
			fi
			
			sourceBinary=../../../../../"$LFS_PHASE"/"$LFS_DEPENDENCY_NAME"/"$LFS_DEPENDENCY_VERSION"/"$LFS_DEPENDENCY_RECIPE_SETTINGS_DEPENDENCIES"/binpath/"$binary"
			
			targetBinary="${LFS}${LFS_DEPENDENCY_PATH_ZZZ}"/binpath/"$binary"
			
			if [ ! -e "$targetBinary" ]; then
				ln -s "$sourceBinary" "$targetBinary"
				continue
			fi
			
			if [ -L "$targetBinary" ]; then
				
				currentBinary="$(readlink "$targetBinary")"
				if [ "$currentBinary" != "$sourceBinary" ]; then
					exitError "sourceBinary $sourceBinary should not have changed from $currentBinary for zzz-lfs binpath $binary"
				fi
			else
				exitError "targetBinary $targetBinary is not a symlink for zzz-lfs binpath $binary"
			fi
		done
	
	popd >/dev/null

	chattr -R +ai "$LFS_DEPENDENCY_BINPATH_PATH" 2>/dev/null || true
}

# Locks down /source, /log, etc
function lockDownPackage()
{
	local file
	
	chattr -DdjsStuai "$LFS_DEPENDENCY_PACKAGE_PATH"
	pushd "$LFS_DEPENDENCY_PACKAGE_PATH" >/dev/null
		for file in *
		do
			# No files
			if [ ! -e "$file" ]; then
				continue
			fi
			
			if [ "$file" = "install" ]; then
				continue
			fi
			
			# Link
			if [ -L "$file" ]; then
				continue
			# File
			elif [ -f "$file" ]; then
				# d - Remove dump ignore
				# j - Remove forced journalling (rely on file system)
				# s - Remove zeroing of contents on delete (slow, buggy and better supported using an encrypted file system)
				# S - Remove any synchronised writes
				# t - Remove tail-merging (buggy and unnecessary)
				# u - Remove undeletion
				# Note, we leave c, compression, alone
				# Note, we leave C (disable copy-on-write for BTRFS), alone
				chattr -djsStuai "$file"

				if [ -x "$topLevelFolder" ]; then
					echo "Removing execute permissions from $topLevelFolder"
				fi
				chmod 0444 "$file"
				
				# A - atime not recorded
				# a - append-only (means vi will be broken)
				# i - immutable (even to root)
				chattr +Aai "$file"
			# Folder
			elif [ -d "$file" ]; then
				
				# Remove options from folders; we do not use chattr -R because attributes of the same name apply differently on files and folders
				# Usually an useless attribute is ignored, but some (eg +C on btrfs) have undefined behaviour
				# Disable Copy-on-Write and compression really need to be configured BEFORE a file is written (eg for /var/log/*, /usr/man/*, /usr/share/*, etc)

				# D - Remove dirsync
				# d - Remove dump ignore
				# j - Remove forced journalling (rely on file system)
				# s - Remove zeroing of contents on delete (slow, buggy and better supported using an encrypted file system)
				# S - Remove any synchronised writes
				# t - Remove tail-merging (buggy and unnecessary)
				# u - Remove undeletion
				# Note, we leave c, compression, alone
				# Note, we leave C (copy-on-write for BTRFS), alone; we can not set this with old versions of chattr
				# Note we leave T, Orlov block allocation, alone
				find "$file" -type d -print0 | xargs -0 -r -n 10 chattr -DdjsStuai
				find "$file" -type f -print0 | xargs -0 -r -n 10 chattr -djsStuai
				
				# We strip all dangerous permissions (Sticky bit, set suid, set guid)
				find "$file" -type d -print0 | xargs -0 -r -n 10 chmod 0555
				find "$file" -type f -perm -0111 -print0 | xargs -0 -r -n 1 echo "Removing execute permissions from"
				find "$file" -type f -print0 | xargs -0 -r -n 10 chmod 0444
				
				# block, char, named pipe, socket likewise
				find "$file" -type b -print0 | xargs -0 -r -n 10 chmod 0444
				find "$file" -type c -print0 | xargs -0 -r -n 10 chmod 0444
				find "$file" -type p -print0 | xargs -0 -r -n 10 chmod 0444
				find "$file" -type s -print0 | xargs -0 -r -n 10 chmod 0444
				
				# A - no atime
				# a - append-only
				# i - immutable
				# c - compress (can not be applied sensibly to existing files)
				find "$file" -type f -print0 | xargs -0 -r -n 10 chattr +Aai
				find "$file" -type d -print0 | xargs -0 -r -n 10 chattr +Aaic
			# block, char, named pipe, socket
			else
				chmod 0644 "$file"
			fi
		done
	popd >/dev/null
	
	chmod 0555 "$LFS_DEPENDENCY_PACKAGE_PATH"
	chattr +Aai "$LFS_DEPENDENCY_PACKAGE_PATH"
}