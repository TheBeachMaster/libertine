set -o errexit +o hashall

function verifyHostSystemRequirementsUsingDependencyChecks()
{
	# Check against http://www.linuxfromscratch.org/lfs/view/development/prologue/hostreqs.html
	
	readonly dependencyChecks="$distributionConfigPath"/dependency-checks
	if [ ! -d "$dependencyChecks" ]; then
		exitError "dependency-checks $dependencyChecks does not exist or is not a directory"
	fi
	
	local debianPackagesToInstallForDependencies=""
	
	pushd "$dependencyChecks" >/dev/null
		local dependencyCheck
		local -i exitCode
		for dependencyCheck in *.dependency-check
		do
			# Used to communicate with subshell, as we can't pass variables back (and we output stdout / stderr to the console)
			temporaryFileToRemoveOnExit
			LFS_CURRENT_DEBIAN_PACKAGES_TEMP="$TMP_FILE"
			# done as subshell to overcome the fact that commands are executing outside of a function
			if ! (source "$dependencyCheck"); then
				if [ -z "$debianPackagesToInstallForDependencies" ]; then
					debianPackagesToInstallForDependencies="$(head -n 1 "$LFS_CURRENT_DEBIAN_PACKAGES_TEMP")"
				else
					debianPackagesToInstallForDependencies="$debianPackagesToInstallForDependencies $(head -n 1 "$LFS_CURRENT_DEBIAN_PACKAGES_TEMP")"
				fi
			fi
		done
	popd >/dev/null

	if [ ! -z "$debianPackagesToInstallForDependencies" ]; then
		if which apt-get 1>/dev/null 2>/dev/null; then
			apt-get --quiet --quiet --yes update
			apt-get --quiet --quiet --yes install $debianPackagesToInstallForDependencies
		fi
	fi
}

function registerDebianPackage()
{
	printf '%s' "$@" >>"$LFS_CURRENT_DEBIAN_PACKAGES_TEMP"
}

function verifyDependency()
{
	if [ $# -lt 2 ]; then
		exitError "Needs at least 2 arguments"
	fi
	if [ $# -gt 3 ]; then
		exitError "Needs no more than 3 arguments"
	fi
	
	local -r sourcePackageName="$1"
	
	local version
	read -r -d$'\n' version
	
	# May be incomplete, eg part of the left-hand regex
	# eg 4.2.25(1)-release might be 4.2
	local -r minimumVersion="$2"
	
	# 0 is equal, =
	# 1 is greater than, >
	# 2 is less than, <
	set +e
	compareVersions "$version" "$minimumVersion"
	local -i comparison=$?
	set -e
	if [ $comparison -eq 2 ]; then
		warning "Dependency $sourcePackageName has a version, $version, less than the minimum known to work, $minimumVersion"
	fi
	
	if [ $# -eq 3 ]; then
		local -r maximumVersion="$3"
		
		set +e
		compareVersions "$version" "$maximumVersion"
		local -i comparison=$?
		set -e
		if [ $comparison -eq 1 ]; then
			warning "Dependency $sourcePackageName has a version, $version, greater than the maximum known to work, $maximumVersion"
		fi
	fi
}

# Derived from http://stackoverflow.com/questions/4023830/bash-how-compare-two-strings-in-version-format
function compareVersions()
{
	if [[ "$1" == "$2" ]]; then
		return 0
	fi
	
	local IFS=.
	local i ver1=($1) ver2=($2)
	
	# fill empty fields in ver1 with zeros
	for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
	do
		ver1[i]=0
	done
	
	for ((i=0; i<${#ver1[@]}; i++))
	do
		if [[ -z ${ver2[i]} ]]; then
			# fill empty fields in ver2 with zeros
			ver2[i]=0
		fi
		if ((10#${ver1[i]} > 10#${ver2[i]})); then
			return 1
		fi
		if ((10#${ver1[i]} < 10#${ver2[i]})); then
			return 2
		fi
	done
	
	return 0
}

function dependencyToPath()
{
	# TODO: Defer the 'current' creation
	local -r relativeOptPath=/opt/lfs
	local -r absoluteOptPath="${LFS}${relativeOptPath}"
	
	local -r relativeOptVersionPath="$relativeOptPath"/"$LFS_DISTRIBUTION_VERSION"
	local -r absoluteOptVersionPath="${LFS}${relativeOptVersionPath}"
	mkdir -m 0755 -p "$absoluteOptVersionPath"
	rm -rf -- "$absoluteOptPath"/current
	ln -s "$LFS_DISTRIBUTION_VERSION" "$absoluteOptPath"/current
	
	local -r relativatePackagePath="$relativeOptVersionPath"/"$LFS_PHASE"/"$LFS_DEPENDENCY_NAME"
	local -r absolutePackagePath="${LFS}${relativatePackagePath}"
	mkdir -m 0755 -p "$absolutePackagePath"
	
	local -r relativeVersionPath="$relativatePackagePath"/"$LFS_DEPENDENCY_VERSION"
	local -r absoluteVersionPath="${LFS}${relativeVersionPath}"
	mkdir -m 0755 -p "$absoluteVersionPath"
	rm -rf -- "$absolutePackagePath"/current
	ln -s "$LFS_DEPENDENCY_VERSION" "$absolutePackagePath"/current
	
	
	# Find and hash dependencies
	addFileToRemoveOnExit
	local -r dependenciesFileUnsorted="$TMP_FILE"
	local dependency
	declare -A dependencyPaths=()
	for dependency in ${!dependency_Dependencies["$LFS_DEPENDENCY_KEY"]}
	do
		printf '%s\0' "${dependency_Path["$dependency"]}" >>"$dependenciesFileUnsorted"
		local name="${dependency_Name["$dependency"]}"
		dependencyPaths["$name"]="${dependency_Path["$dependency"]}"
	done
	addFileToRemoveOnExit
	local -r dependenciesFileSorted="$TMP_FILE"
	# --stable and LC_ALL=C to ensure a consistent sort order before hashing
	LC_ALL=C sort --key=1 --stable --zero-terminated "$dependenciesFileUnsorted" >"$dependenciesFileSorted"
	local -r dependenciesHash="$(sha256sum "$dependenciesFileSorted" | awk 'NR==1 {print $1}')"
	
	
	
	local -r recipeVersion="$LFS_DEPENDENCY_RECIPE_HASH"-"$LFS_DEPENDENCY_SETTINGS_HASH"-"$dependenciesHash"
	local -r relativeCompletePath="$relativeVersionPath"/"$recipeVersion"
	local -r absoluteCompletePath="${LFS}${relativeCompletePath}"
	
	dependency_Path["$LFS_DEPENDENCY_KEY"]="$relativeCompletePath"
	
	if [ -f "$absoluteCompletePath"/installed ]; then
		return 0
	fi
	
	rm -rf -- "$absoluteCompletePath"
	mkdir -m 0755 -p "$absoluteCompletePath"
	chown ${LFS_DEPENDENCY_UID}:${LFS_DEPENDENCY_GID} "$absoluteCompletePath"
	rm -rf -- "$absoluteVersionPath"/recipe-settings-dependencies
	ln -s "$recipeVersion" "$absoluteVersionPath"/recipe-settings-dependencies
	rm -rf -- "$absoluteVersionPath"/current
	ln -s recipe-settings-dependencies "$absoluteVersionPath"/current
	
	
	sudo -u \#${LFS_DEPENDENCY_UID} -g \#${LFS_DEPENDENCY_GID} -- mkdir -m 0755 -p "$absoluteCompletePath"/install
	
	sudo -u \#${LFS_DEPENDENCY_UID} -g \#${LFS_DEPENDENCY_GID} -- mkdir -m 0755 -p "$absoluteCompletePath"/log
	
	
	# Copy in source and patches from download cache
	sudo -u \#${LFS_DEPENDENCY_UID} -g \#${LFS_DEPENDENCY_GID} -- mkdir -m 0755 -p "$absoluteCompletePath"/source
	
	
	local -i index
	for index in ${dependency_SourcePackageIndices["$LFS_DEPENDENCY_KEY"]}
	do
		linkOrCopyFile "${sourcePackages_Mirror[$index]}" "${sourcePackages_RelativePath[$index]}" "$absoluteCompletePath"/source "${sourcePackages_FileName[$index]}"
	done
	
	for index in $LFS_DEPENDENCY_PATCHES
	do
		linkOrCopyFile "${patches_Mirror[$index]}" "${patches_RelativePath[$index]}" "$absoluteCompletePath"/source "${patches_FileName[$index]}"
	done
	# There may not have been any files copied
	chmod 0644 -- "$absoluteCompletePath"/source/* || true
	chown ${LFS_DEPENDENCY_UID}:${LFS_DEPENDENCY_GID} -- "$absoluteCompletePath"/source/* || true
	
	
	mv "$dependenciesFileSorted" "$absoluteCompletePath"/dependencies.list
	chown ${LFS_DEPENDENCY_UID}:${LFS_DEPENDENCY_GID} "$absoluteCompletePath"/dependencies.list
	chmod 0400 "$absoluteCompletePath"/dependencies.list
	
	local -r absoluteDependenciesPath="$absoluteCompletePath"/dependencies
	mkdir -m 0755 -p "$absoluteDependenciesPath"
	local dependencyName
	local dependencyPath
	for dependencyName in "${!dependencyPaths[@]}"
	do
		ln -s "${dependencyPaths["$dependencyName"]}" "$absoluteDependenciesPath"/"$dependencyName"
	done
	
	cp "$recipesPath"/"$LFS_PHASE"/"$LFS_DEPENDENCY_NAME".recipe "$absoluteCompletePath"/recipe
	if [ "$LFS_DEPENDENCY_INCLUDE_HASH" != "0" ]; then
		cp "$includesPath"/"$LFS_DEPENDENCY_NAME".include "$absoluteCompletePath"/include
	fi
	if [ "$LFS_DEPENDENCY_SETTINGS_HASH" != "0" ]; then
		cp "$settingsPath"/"$LFS_PHASE"/"$LFS_DEPENDENCY_NAME".settings "$absoluteCompletePath"/settings
	fi
}
