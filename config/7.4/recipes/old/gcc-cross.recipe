set -o errexit +o hashall

version 4.8.1
{
	include gcc 4.8.1
	include mpfr 3.1.2
	include gmp 5.1.2
	include mpc 1.0.1
	include binutils 2.23.2
	
	install_binaries_in_paths bin "$LFS_TARGET"/bin
	
	# plugin, install-tools are folders
	make_executable_binary \
		libexec/gcc/"$LFS_TARGET"/"${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"/cc1 \
		libexec/gcc/"$LFS_TARGET"/"${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"/collect2 \
		libexec/gcc/"$LFS_TARGET"/"${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"/lto1 \
		libexec/gcc/"$LFS_TARGET"/"${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"/lto-wrapper \
		libexec/gcc/"$LFS_TARGET"/"${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"/plugin \
		libexec/gcc/"$LFS_TARGET"/"${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"/install-tools
}

function install_crosscompiler_gcc-cross()
{
	local -r linuxInstallPath="${LFS}$(dependencyPath linux)"/install
	local -r glibcInstallPath="${LFS}$(dependencyPath glibc)"/install
	
	pushdDependencyFolder

		# http://stackoverflow.com/questions/1726042/recipe-for-compiling-binutils-gcc-together
		
		local dependencyName
		for dependencyName in mpfr gmp mpc
		do
			ln -sv ../"$dependencyName" "$dependencyName"
		done
		local binutilsFile
		for binutilsFile in ../binutils/*
		do
			# suppress existing entries
			ln -sv "$binutilsFile" 2>/dev/null || true
		done
		
		local file
		for file in $(find gcc/config -name linux64.h -o -name linux.h -o -name sysv4.h)
		do
			cp -u "$file" "$file".orig
			
			# change ld location (matches /lib, /lib32, /lib64 and /libx32, the \1 is a group reference)
			# /usr seems to be used for non-x86 setups
			sed -r -e "s;/lib(64|32|x32|)/ld;/${glibcInstallPath}/lib\1/ld;g" -e "s;/usr;/${glibcInstallPath}/usr;g" "$file".orig >"$file"
			
			cat >>"$file" <<-EOF
			
				#undef STANDARD_STARTFILE_PREFIX_1
				#undef STANDARD_STARTFILE_PREFIX_2
				#define STANDARD_STARTFILE_PREFIX_1 "$glibcInstallPath/lib/"
				#define STANDARD_STARTFILE_PREFIX_2 ""
			EOF
			touch "$file".orig
		done
		
		# Stack protection fix for glibc-2.18 / musl
		sed -i '/k prot/agcc_cv_libc_provides_ssp=yes' gcc/configure
	
		# with-native-system-header-dir specifies a path that does not exist at this point in time (we haven't installed linux). Should not be a problem.
		createBuildFolderAndPushd
		
			# --without-headers --with-newlib ensures that libgcc is built without any header files or other libraries
			../"$LFS_DEPENDENCY_NAME"/configure \
			--target="$LFS_TARGET" \
			--prefix="$LFS_DEPENDENCY_PREFIX_PATH" \
			--with-sysroot="$LFS" \
			--with-newlib \
			--without-headers \
			--with-local-prefix="$LFS_DEPENDENCY_PREFIX_PATH" \
			--with-native-system-header-dir="$linuxInstallPath"/usr/include \
			--disable-nls \
			--disable-werror \
			--disable-shared \
			--disable-multilib \
			--disable-decimal-float \
			--disable-threads \
			--disable-libatomic \
			--disable-libgomp \
			--disable-libitm \
			--disable-libmudflap \
			--disable-libquadmath \
			--disable-libsanitizer \
			--disable-libssp \
			--disable-libstdc++-v3 \
			--enable-languages=c,c++ \
				--with-lib-path="$LFS_DEPENDENCY_INSTALL_PATH_ZZZ"/lib
		
			# --with-lib-path=XXXX == make -C ld LIB_PATH=XXXX
			# After pass 2 of gcc, we need to set lib-path differently when the linker (ld) is used inside the chroot
		
			make

			make DESTDIR="$LFS" install

			# Using --disable-shared means that the libgcc_eh.a file isn't created and installed. The Glibc package depends on this library as it uses -lgcc_eh within its build system.
			# This dependency can be satisfied by creating a symlink to libgcc.a, since that file will end up containing the objects normally contained in libgcc_eh.a:
			
			local -r libgccPath="$("$LFS_DEPENDENCY_INSTALL_PATH"/bin/${LFS_TARGET}-gcc -print-libgcc-file-name | sed 's/libgcc/&_eh/')"
			
			ln -sv libgcc.a "$libgccPath"

		popdBuildFolder
	
	popdDepdendencyFolder
}
