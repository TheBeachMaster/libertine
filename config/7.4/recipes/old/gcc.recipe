set -o errexit +o hashall

version 4.8.1
{
	depends libstdc++
	
	include gcc 4.8.1
	include mpfr 3.1.2
	include gmp 5.1.2
	include mpc 1.0.1
	include binutils 2.23.2
	
	install_binaries_in_paths bin
}

function installPackage_toolchain2_gcc()
{
	local -r linuxInstallPath="${LFS}$(dependencyPath linux)"/install
	local -r glibcInstallPath="${LFS}$(dependencyPath glibc)"/install
	
	pushdDependencyFolder

		# http://stackoverflow.com/questions/1726042/recipe-for-compiling-binutils-gcc-together
		
		local dependencyName
		for dependencyName in mpfr gmp mpc
		do
			ln -sv ../"$dependencyName" "$dependencyName"
		done
		local binutilsFile
		for binutilsFile in ../binutils/*
		do
			# suppress existing entries
			ln -sv "$binutilsFile" 2>/dev/null || true
		done
		
		local file
		for file in $(find gcc/config -name linux64.h -o -name linux.h -o -name sysv4.h)
		do
			cp -u "$file" "$file".orig
			
			# change ld location (matches /lib, /lib32, /lib64 and /libx32, the \1 is a group reference)
			# /usr seems to be used for non-x86 setups
			sed -r -e "s;/lib(64|32|x32|)/ld;/${glibcInstallPath}/lib\1/ld;g" -e "s;/usr;/${glibcInstallPath}/usr;g" "$file".orig >"$file"
			
			cat >>"$file" <<-EOF
			
				#undef STANDARD_STARTFILE_PREFIX_1
				#undef STANDARD_STARTFILE_PREFIX_2
				#define STANDARD_STARTFILE_PREFIX_1 "$glibcInstallPath/lib/"
				#define STANDARD_STARTFILE_PREFIX_2 ""
			EOF
			touch "$file".orig
		done
	
		local -r libgccPath=$("$LFS_TARGET"-gcc -print-libgcc-file-name)
		cat gcc/limitx.h gcc/glimits.h gcc/limity.h >"$(purebash_dirname "$libgccPath")"/include-fixed/limits.h
		
		cp -v gcc/Makefile.in{,.tmp}
		sed 's/^T_CFLAGS =$/& -fomit-frame-pointer/' gcc/Makefile.in.tmp >gcc/Makefile.in
	
		createBuildFolderAndPushd
		
			local -r currentDir="$(pwd)"
			CC="$LFS_TARGET"-gcc \
			CXX="$LFS_TARGET"-g++ \
			AR="$LFS_TARGET"-ar \
			RANLIB="$LFS_TARGET"-ranlib \
			../"$LFS_RECIPE_EXTRACTED_TARBALL_FOLDER"/configure \
			--prefix="$LFS_DEPENDENCY_PREFIX_PATH" \
			--with-local-prefix="$LFS_DEPENDENCY_PREFIX_PATH" \
			--with-native-system-header-dir="$linuxInstallPath"/usr/include \
			--enable-clocale=gnu \
			--enable-shared \
			--enable-threads=posix \
			--enable-__cxa_atexit \
			--enable-languages=c,c++ \
			--disable-libstdcxx-pch \
			--disable-multilib \
			--disable-bootstrap \
			--disable-libgomp \
				--with-lib-path="$LFS_DEPENDENCY_INSTALL_PATH_ZZZ"/lib
		
			# --with-lib-path=XXXX == make -C ld LIB_PATH=XXXX in effect, this is the ld search path
			# With pass 2 of gcc, we need to set lib-path differently when the linker (ld) is used inside the chroot
		
			make
		
			make DESTDIR="$LFS" install
		
			ln -sv gcc "$LFS_DEPENDENCY_PREFIX_PATH"/bin/cc
		
		popdBuildFolder
	
		#localPackage_toolchain2_gcc_verifyGcc
	
	popdDepdendencyFolder
}

# similar to localPackage_toolchain2_glibc_verifyGlibc except we use 'cc' rather than "$LFS_TARGET"-gcc
function localPackage_toolchain2_gcc_verifyGcc()
{
	echo 'main(){}' >dummy.c
	cc dummy.c
	local -r interpreter="$(readelf -l a.out | awk -v FS=': ' -v ORS='' 'NR==1, $0 ~ /Requesting program interpreter/ {print $2}')"
	
	case "$LFS_ARCHITECTURE" in
		x86_64)
			local -r libraryFolderName=lib64
		;;
		
		*)
			local -r libraryFolderName=lib
		;;
	esac
	
	if [ "$(purebash_dirname "$interpreter")" != /"$LFS_TOOLS"/"$libraryFolderName" ]; then
		echo "$interpreter is incorrect"
		exit 3
	fi
	
	rm -f -v dummy.c a.out
}
