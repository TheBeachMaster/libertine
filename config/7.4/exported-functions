function progressMessage()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	SECONDS=0
	printf "$ourName: $1"
}

function progressMessageUpdate()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	printf " $1"
}

function progressMessageFailed()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	echo " FAILED (in ${SECONDS}s: $1)"
	exit 1
}

function progressMessageSucceeded()
{
	if [ $# -ne 0 ]; then
		exitError "Too many arguments"
	fi
	echo " PASSED (in ${SECONDS}s)"
}

function printKey()
{
	if [ $# -ne 2 ]; then
		exitError "Too many arguments"
	fi
	
	local -r localSourcePackageName="$1"
	local -r localVersion="$2"
	# bash has problems with keys containing non-alphanumerics when the key has not previously been added to an associative array
	# this is a problem for existence checks
	# printf so as to avoid tr replacing a trailing \n (as would happen with a heredoc)
	printf '%s' "${localSourcePackageName}:${localVersion}" | tr --complement '[:alpha:][:digit:]' '_'
}

function printDistributionVersionKey()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	local -r localDistributionVersion="$1"
	printf '%s' "${localDistributionVersion}" | tr --complement '[:alpha:][:digit:]' '_'
}

function sourcePackagesKeyExists()
{
	if [ $# -ne 1 ]; then
		exitError "Too many arguments"
	fi
	
	local -r key="$1"
	local -i index
	for index in ${!sourcePackages_IndicesToKeys[@]}
	do
		if [ "$key" = "${sourcePackages_IndicesToKeys[$index]}" ]; then
			# key already exists
			return 0
		fi
	done
	return 1
}

declare -a signatures_Url=()
declare -a signatures_FileName=()

function addSignature()
{
	local -r ourUnsignedUrl="$1"
	local -r ourHashesSpaceSeparated="$2"
	
	local hashNameAndValue
	local -i signatureNumber
	for hashNameAndValue in $ourHashesSpaceSeparated
	do
		IFS=':' read -r -d$'\n' hashName hashValue <<<"$hashNameAndValue"
		case "$hashName" in
			KEYRING|KEYFILE|HKP)
				signatureNumber=${#signatures_Url[@]}
				signatures_Url[$signatureNumber]="$ourUnsignedUrl".sig
				signatures_FileName[$signatureNumber]="$(purebash_basename "$ourUnsignedUrl".sig)"
			;;
		esac
	done
}

# Exists because ${!sourcePackages_XXXX[@]} returns INDICES not KEYS; we can also use indices it seems against associative arrays
declare -a sourcePackages_IndicesToKeys=()
declare -A sourcePackages_SourcePackageName=()
declare -A sourcePackages_Version=()
declare -A sourcePackages_Url=()
declare -A sourcePackages_Compression=()
declare -A sourcePackages_FileName=()
declare -A sourcePackages_ExtractedTarballFolder=()
declare -A sourcePackages_Hashes=()
declare -A sourcePackages_Patches=()

function addSourcePackageDownload()
{
	if [ $# -lt 3 ]; then
		exitError "Not enough arguments"
	elif [ $# -gt 5 ]; then
		exitError "Too many arguments"
	fi
	
	local -r ourSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
	local -r ourVersion="$1"
	local -r ourUrl="$2"
	local -r ourHashes="$3"
	local -r ourFileName="$(purebash_basename "$ourUrl")"
	
	local -r compressionExtension="${ourFileName##*.}"
	
	if [ $# -ge 4 ]; then
		local -r LFS_EXTRACTED_TARBALL_FOLDER="$4"
	else
		local -r withoutCompressionExtension="${ourFileName%.*}"
		if [ -z "$compressionExtension" ]; then
			local -r LFS_EXTRACTED_TARBALL_FOLDER="$withoutCompressionExtension"
		else
			case "$compressionExtension" in
				
				# The various abominations are also slackware packages (txz, tgz especially)
				tar|tgz|tbz|tbz2|txz|tlz|tlzma|tz|taz)
					local -r LFS_EXTRACTED_TARBALL_FOLDER="$withoutCompressionExtension"
				;;
				
				*)
					local -r LFS_EXTRACTED_TARBALL_FOLDER="${withoutCompressionExtension%.*}"
				;;
				
			esac
		fi
	fi
	
	# TODO:  cpio/cpgz  zip/jar/war/ear  ar/deb  shar  rpm (using rpm2cpio, so we can think of rpm as a compressed cpio file)
	# TODO: support non-tar formats, eg cpio/rpm, zip, ar/deb
	# TODO: split compression from tar for non-tar formats
	#
	
	if [ $# -eq 5 ]; then
		local -r ourCompression="$5"
	else
		case "$compressionExtension" in
			tar)
				local -r ourCompression=''
			;;
			
			gz|tgz)
				local -r ourCompression=ungzip
			;;
			
			bz2|bz|tbz2|tbz)
				local -r ourCompression=bzip2
			;;
			
			# Not included in dependencies by default
			# A faster compressor still is lz4
			lzo)
				local -r ourCompression=lzop
			;;
			
			# Not included in dependencies by default
			lz|tlz)
				local -r ourCompression=lzip
			;;
			
			lzma|tlzma)
				local -r ourCompression=lzma
			;;
			
			xz|txz)
				local -r ourCompression=xz
			;;
			
			# Not included in dependencies by default
			Z|tz|taz)
				# eg gzip downloads
				local -r ourCompression=uncompress
			;;
			
			*)
				if [ ! -z "$compressionExtension" ]; then
					exitError "Unknown file extension $compressionExtension for $ourSourcePackageName $ourVersion"
				fi
			;;
		esac
	fi
	
	local -r key="$(printKey "$ourSourcePackageName" "$ourVersion")"
	
	# There are very nasty bugs in bash that mean a key can 'already exist' but with the previously added key's value!
	if sourcePackagesKeyExists "$key"; then
		local -r existingUrl="${sourcePackages_Url["${key}"]}"
		if [ "$existingUrl" != "$ourUrl" ]; then
			warning "Attempt to override URL IGNORED for source package $ourSourcePackageName version $ourVersion to $ourUrl from $existingUrl to $ourUrl"
		fi
		return 0
	fi
	sourcePackages_IndicesToKeys["${#sourcePackages_IndicesToKeys[@]}"]="$key"
	
	sourcePackages_SourcePackageName["${key}"]="$ourSourcePackageName"
	sourcePackages_Version["${key}"]="$ourVersion"
	sourcePackages_Url["${key}"]="$ourUrl"
	sourcePackages_Compression["${key}"]="$ourCompression"
	sourcePackages_FileName["${key}"]="$ourFileName"
	sourcePackages_ExtractedTarballFolder["${key}"]="$LFS_EXTRACTED_TARBALL_FOLDER"
	sourcePackages_Hashes["${key}"]="${ourHashes//,/ }"
	sourcePackages_Patches["${key}"]=""
	
	addSignature "$ourUrl" "${sourcePackages_Hashes["${key}"]}"
}

declare -a patches_Url=()
declare -a patches_FileName=()
declare -a patches_Hashes=()
function addPatchDownload()
{
	if [ $# -ne 3 ]; then
		exitError "Not enough arguments"
	fi
	
	local -r ourSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
	local -r ourVersion="$1"
	local -r ourUrl="$2"
	local -r ourHashes="$3"
	local -r ourFileName="$(purebash_basename "$ourUrl")"
	
	local -r key="$(printKey "$ourSourcePackageName" "$ourVersion")"
	
	# Ensure a tar ball download exists
	if ! sourcePackagesKeyExists "$key"; then
		exitError "No source package exists for patch $ourFileName to $ourSourcePackageName version $ourVersion"
	fi
	
	# Check for duplicate patches
	local -i existingPatchNumber
	for existingPatchNumber in ${sourcePackages_Patches["${key}"]}
	do
		if [ ${patches_FileName[$existingPatchNumber]} = "$ourFileName" ]; then
			if [ ${patches_Url[$existingPatchNumber]} != "$ourUrl" ]; then
				warning "Attempt to override URL IGNORED for patch $ourFileName to $ourSourcePackageName version $ourVersion to $ourUrl"
			fi
			return 0
		fi
	done
	
	local -ir patchNumber=${#patches_Url[@]}
	patches_Url[$patchNumber]="$ourUrl"
	patches_FileName[$patchNumber]="$ourFileName"
	patches_Hashes[$patchNumber]="${ourHashes//,/ }"
	sourcePackages_Patches["${key}"]="${sourcePackages_Patches["${key}"]} $patchNumber"
	
	addSignature "$ourUrl" "${patches_Hashes[$patchNumber]}"
}

previousMirrors=""
function sourceMirror()
{
	if [ $# -ne 1 ]; then
		exitError "Not exactly 1 argument"
	fi
	
	local -r localMirror="$1"
	
	local previousMirror
	for previousMirror in $previousMirrors
	do
		if [ "$previousMirror" = "$localMirror" ]; then
			exitError "Recursion of mirrors - trying to use $localMirror after mirror stack of $previousMirrors"
		fi
	done
	previousMirrors="$previousMirrors $localMirror"
	
	if [ -f "$mirrorsPath"/"$localMirror".mirrors ]; then
		LFS_DISTRIBUTION_VERSION="$distributionVersion" source "$mirrorsPath"/"$localMirror".mirrors "$distributionVersion" "$localMirror"
	else
		exitError "mirrors $localMirror.mirrors does not exist in mirrors path $mirrorsPath or is not a file"
	fi
}

function sourceProfile()
{
	if [ $# -ne 1 ]; then
		exitError "Not exactly 1 argument"
	fi
	
	local -r localProfile="$1"
	
	if [ -f "$profilesPath"/"$localProfile".profile ]; then
		LFS_PHASE="$LFS_PHASE" LFS_DISTRIBUTION_VERSION="$distributionVersion" source "$profilesPath"/"$localProfile".profile "$LFS_PHASE" "$distributionVersion" "$localProfile"
	else
		exitError "profile $localProfile.profile does not exist in profile path $profilesPath or is not a file"
	fi
}

declare -a keyrings_Url=()
declare -a keyrings_FileName=()
declare -a keyrings_Hashes=()
function sourceKeyring()
{
	if [ $# -ne 2 ]; then
		exitError "Not exactly 2 arguments"
	fi
	
	local -r ourUrl="$1"
	local -r ourHashes="$2"
	local -r ourFileName="$(purebash_basename "$ourUrl")"
	
	if [ "${ourFileName##*.}" != "gpg" ]; then
		exitError "Only gpg keyrings are supported - which is not so for this url: $ourUrl"
	fi
	
	local -i existingKeyringNumber
	for existingKeyringNumber in ${!keyrings_FileName[@]}
	do
		if [ ${keyrings_FileName[$existingKeyringNumber]} = "$ourFileName" ]; then
			if [ ${keyrings_FileName[$existingPatchNumber]} != "$ourUrl" ]; then
				warning "Attempt to override URL IGNORED for keyring $ourFileName to $ourUrl"
			fi
			return 0
		fi
	done
	
	local -ir keyringNumber=${#patches_Url[@]}
	keyrings_Url[$keyringNumber]="$ourUrl"
	keyrings_FileName[$keyringNumber]="$ourFileName"
	keyrings_Hashes[$keyringNumber]="${ourHashes//,/ }"
	
	addSignature "$ourUrl" "${keyrings_Hashes[$patchNumber]}"
}

declare -a keys_Url=()
declare -a keys_FileName=()
declare -a keys_Hashes=()
function sourceKey()
{
	if [ $# -ne 2 ]; then
		exitError "Not exactly 2 arguments"
	fi
	
	local -r ourUrl="$1"
	local -r ourHashes="$2"
	local -r ourFileName="$(purebash_basename "$ourUrl")"
	
	local -i existingKeyNumber
	for existingKeyNumber in ${!keys_FileName[@]}
	do
		if [ ${keys_FileName[$existingKeyNumber]} = "$ourFileName" ]; then
			if [ ${keys[$existingPatchNumber]} != "$ourUrl" ]; then
				warning "Attempt to override URL IGNORED for key $ourFileName to $ourUrl"
			fi
			return 0
		fi
	done
	
	local -ir keyNumber=${#patches_Url[@]}
	keys_Url[$keyNumber]="$ourUrl"
	keys_FileName[$keyNumber]="$ourFileName"
	keys_Hashes[$keyNumber]="${ourHashes//,/ }"
	
	addSignature "$ourUrl" "${keys_Hashes[$keyNumber]}"
}

function sourceHkp()
{
	local -r keyId="$1"
	if [ $# -eq 1 ]; then
		local -r keyServer="$LFS_MIRROR_KEYSERVER"
	elif [ $# -eq 2 ]; then
		local -r keyServer="$2"
	else
		exitError "Not 1 or 2 arguments"
	fi
	
	sourceKey "${LFS_MIRROR_HKP}${keyId}" ""
	env
	echo "$LFS_MIRROR_HKP"
	exit 7
}

function sourceRecipe()
{
	if [ $# -lt 2 ]; then
		exitError "Too few arguments"
	elif [ $# -gt 3 ]; then
		exitError "Too many arguments"
	fi
	
	local -r localSourcePackageName="$1"
	local -r ourVersion="$2"
	
	LFS_SOURCE_PACKAGE_NAME="$localSourcePackageName" LFS_VERSION="$ourVersion" source "$recipesPath"/"$localSourcePackageName".recipe "$localSourcePackageName"
	
	if [ $# -eq 3 ]; then
		local -r onlyInstallForPhase="$3"
		
		case "$onlyInstallForPhase" in
			
			toolchain1|toolchain2|system)
				:
			;;
			
			*)
				exitError "Unknown phase $onlyInstallForPhase"
			;;
			
		esac
		
		if [ "$onlyInstallForPhase" = "$LFS_PHASE" ]; then
			addToInstall "$localSourcePackageName" "$ourVersion" "$LFS_PHASE" "$distributionVersion"
		fi
	else
		addToInstall "$localSourcePackageName" "$ourVersion" "$LFS_PHASE" "$distributionVersion"
	fi
}

declare -A installPhase_toolchain1=()
declare -A installPhase_toolchain2=()
declare -A installPhase_system=()
function addToInstall()
{
	if [ $# -lt 4 ]; then
		exitError "Not enough arguments"
	fi
	
	local -r ourSourcePackageName="$1"
	local -r ourVersion="$2"
	local -r phase="$3"
	local -r key="$(printKey "$ourSourcePackageName" "$ourVersion")"
	
	# Use an override (versioned) installer, otherwise the default
	local -r installer_versioned=installPackage_${phase}_${ourSourcePackageName}_${ourVersion}
	local -r installer_unversioned=installPackage_${phase}_${ourSourcePackageName}
	if type "$installer_versioned" &>/dev/null; then
		local -r installer="$installer_versioned"
	elif type "$installer_unversioned" &>/dev/null; then
		local -r installer="$installer_unversioned"
	else
		exitError "No installer $installer_versioned or $installer_unversioned defined for $ourSourcePackageName version $ourVersion"
	fi
	
	# Ensure a tar ball download exists
	if ! sourcePackagesKeyExists "$key"; then
		exitError "No source package exists for $ourSourcePackageName version $ourVersion"
	fi
	
	# remaining variables are distribution versions (ie software that works together)
	shift 3
	local localDistributionVersion
	local localDistributionVersionKey
	local previousDependencies=""
	for localDistributionVersion in $@
	do
		localDistributionVersionKey="$(printDistributionVersionKey "$localDistributionVersion")"
		
		case "$phase" in
		
			toolchain1)
				previousDependencies="${installPhase_toolchain1["${localDistributionVersionKey}"]}"
				installPhase_toolchain1["${localDistributionVersionKey}"]="$previousDependencies $key"
			;;
		
			toolchain2)
				previousDependencies="${installPhase_toolchain2["${localDistributionVersionKey}"]}"
				installPhase_toolchain2["${localDistributionVersionKey}"]="$previousDependencies $key"
			;;
		
			system)
				previousDependencies="${installPhase_system["${localDistributionVersionKey}"]}"
				installPhase_system["${localDistributionVersionKey}"]="$previousDependencies $key"
			;;
		
			*)
				exitError "Unsupported phase $phase"
			;;
		
		esac
	done
}

# Also https://www.scaprepo.com/ is a good place to query
# One of the problems is we can only add CPEs post a version is made vulnerable
# eg addCPE 4.2 cpe:/a:gnu:bash:4.2
# Not all CPEs are predictable, eg for java:-
# cpe:/a:oracle:jdk:1.6.0:update_23
# However, in this case, we could 'guess' the CPE based on previously registered ones
# Other CPEs are unversioned, eg this one for gnu gzip:  cpe:/a:gnu:gzip  but also cpe:/a:gnu:gzip:1.2.4 and 
# for maximum confusion, cpe:/a:gnu:gzip:1.2.4a
function addCPE()
{
	if [ $# -ne 2 ]; then
		exitError "Not enough arguments"
	fi
	
	local -r localVersion="$1"
	local -r localCpe="$2"
	
	local -r localSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
	local -r key="$(printKey "$localSourcePackageName" "$localVersion")"
	
	# Ensure a tar ball download exists
	if ! sourcePackagesKeyExists "$key"; then
		exitError "No source package exists for $ourSourcePackageName version $ourVersion"
	fi
}

# Called inside sourceRecipe
function addCVE()
{
	if [ $# -ne 2 ]; then
		exitError "Not enough arguments"
	fi
	
	local -r localSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
	local -r cveProductId="$1"
	local -r cveProductName="$2"
	
	# https://cve.mitre.org/data/downloads/allitems.csv.gz
	#
	# https://nvd.nist.gov/download.cfm  eg
	# http://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-recent.xml
	# Contains entry elements, buried within which are cpe-lang expressions (oh, for f's sake, can't people make things simple)?
	# These ultimately reference things like cpe:/a:adobe:coldfusion:9.0 and cpe:/a:adobe:coldfusion:9.0.2 which presumably match affected packages
	# another example is  cpe:/a:eucalyptus:eucalyptus:3.2.1  
	#
	# A php XML parser for the list is at  http://homes.cerias.purdue.edu/~pmeunier/nvd_xml_parser.txt
	# A ruby one is at http://seclists.org/fulldisclosure/2011/Feb/356
	# An old perl one is at http://www.perlmonks.org/?node_id=625277
	
	# holds product definitions (but includes versions, too, irritating)
	# http://static.nvd.nist.gov/feeds/xml/cpe/dictionary/official-cpe-dictionary_v2.3.xml
	#<cpe-item name="cpe:/a:gnu:bash:1.14.0">
	#	<title xml:lang="en-US">GNU Bourne-Again SHellbash (GNU Bash) 1.14.0</title>
	#	<cpe-23:cpe23-item name="cpe:2.3:a:gnu:bash:1.14.0:*:*:*:*:*:*:*"/>
	#</cpe-item>
	# https://web.nvd.nist.gov/view/cpe/search/results?searchChoice=keyword&searchText=bash
	#
	# Not all CVEs are fixed; there's an outstanding one for bash from 1999.
	#
	#
	# CPE -- vendor, product, version
	#
	#
}

function tarExtract()
{
	if [ $# -ne 3 ]; then
		exitError "Not enough arguments"
	fi
	
	local -r tarball="$1"
	local -r tarballFolder="$2"
	local -r tarballCompression="$3"
	
	rm -rf -- "$tarballFolder"
	if [ -z "$ourCompression" ]; then
		tar --extract --file "$tarball"
	else
		tar --extract --file "$tarball" --$tarballCompression
	fi
}

function extractDependencies()
{
	if [ $# -eq 0 ]; then
		exitError "Not enough arguments"
	fi
	
	local dependency
	local localSourcePackageName
	local localVersion
	local key
	local localFileName
	local localExtractedTarballFolder
	local localCompression
	
	for dependency in $@
	do
		IFS=: read -r -d $'\t' localSourcePackageName localVersion <<<"$dependency"
		
		key="$(printKey "$localSourcePackageName" "$localVersion")"
		
		localFileName=sourcePackages_FileName["${key}"]
		localExtractedTarballFolder=sourcePackages_ExtractedTarballFolder["${key}"]
		localCompression=sourcePackages_Compression["${key}"]
		
		if [ -z "$localSourcePackageName" ]; then
			progressMessageFailed "No known source package definition for dependency $localSourcePackageName $localVersion"
		fi
		
		tarExtract ../"$localFileName" "$localExtractedTarballFolder" $localCompression
		mv "$localExtractedTarballFolder" "$localSourcePackageName"
	done
}

function installPackagePrototype()
{
	./configure --prefix=/"$LFS_TOOLS" $@
	
	make
	
	#make check
	
	make install
}

function createBuildFolderAndPushd()
{
	if [ $# -gt 1 ]; then
		exitError "Too many arguments"
	fi
	
	if [ $# -eq 1 ]; then
		local -r localSourcePackageName="$1"
		local -r buildFolder=../"$localSourcePackageName"-build
	else
		local -r localSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
		local -r buildFolder=../"$localSourcePackageName"-build
		rm -rf -- "$buildFolder"
	fi
	
	mkdir -m 0755 -p "$buildFolder"
	pushd "$buildFolder" >/dev/null
}

function popdBuildFolder()
{
	if [ $# -ne 0 ]; then
		exitError "Too many arguments"
	fi
	
	local -r buildFolder=../"$LFS_SOURCE_PACKAGE_NAME"-build
	popd >/dev/null
	#rm -rf -- "$buildFolder"
}
