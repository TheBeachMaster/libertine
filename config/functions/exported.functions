set -o errexit +o hashall

essentialProgramCheck getent awk

# Since this file is source'd inside a function, the declare builtin defaults to making variables local!
declare -irg nobodyUid=$(getent passwd nobody | awk -v FS=: 'NR==1 {print $3}')
declare -irg nogroupGid=$(getent group nogroup | awk -v FS=: 'NR==1 {print $3}')

declare_for_chroot -a previousMirrors

declare_for_chroot -A phase_PreviousRecipes
phase_PreviousRecipes+=(['crosscompiler']="" ['toolchain2']="" ['system']="")
declare_for_chroot -A phase_InstallationOrder

declare_for_chroot -a signatures_Mirror
declare_for_chroot -a signatures_RelativePath
declare_for_chroot -a signatures_FileName
declare_for_chroot -a signatures_Compression
declare_for_chroot -a signatures_Post
declare_for_chroot -a signatures_ReferFrom

declare_for_chroot -a keyrings_Mirror
declare_for_chroot -a keyrings_RelativePath
declare_for_chroot -a keyrings_FileName
declare_for_chroot -a keyrings_Hashes
declare_for_chroot -a keyrings_Compression
declare_for_chroot -a keyrings_Post
declare_for_chroot -a keyrings_ReferFrom

declare_for_chroot -a keys_Mirror
declare_for_chroot -a keys_RelativePath
declare_for_chroot -a keys_FileName
declare_for_chroot -a keys_Hashes
declare_for_chroot -a keys_Compression
declare_for_chroot -a keys_Post
declare_for_chroot -a keys_ReferFrom

declare_for_chroot -a sourcePackages_Name
declare_for_chroot -a sourcePackages_Version
declare_for_chroot -a sourcePackages_Mirror
declare_for_chroot -a sourcePackages_RelativePath
declare_for_chroot -a sourcePackages_Hashes
declare_for_chroot -a sourcePackages_FileName
declare_for_chroot -a sourcePackages_Compression
declare_for_chroot -a sourcePackages_Post
declare_for_chroot -a sourcePackages_ReferFrom
declare_for_chroot -a sourcePackages_ExtractedTarballFolder
declare_for_chroot -a sourcePackages_IsTarbomb

declare_for_chroot -a patches_Mirror
declare_for_chroot -a patches_RelativePath
declare_for_chroot -a patches_FileName
declare_for_chroot -a patches_Hashes
declare_for_chroot -a patches_Compression
declare_for_chroot -a patches_Post
declare_for_chroot -a patches_ReferFrom
declare_for_chroot -ai patches_SourcePackageIndex

declare_for_chroot -A dependency_Phase
declare_for_chroot -A dependency_Name
declare_for_chroot -A dependency_Version
declare_for_chroot -A dependency_RecipeHash
declare_for_chroot -A dependency_IncludeHash
declare_for_chroot -A dependency_SettingsHash
declare_for_chroot -A dependency_UidGid
declare_for_chroot -A dependency_SourcePackageIndices
declare_for_chroot -A dependency_PatchIndices
declare_for_chroot -A dependency_Dependencies
declare_for_chroot -A dependency_Path
declare_for_chroot -A dependency_RelativePath
declare_for_chroot -A dependency_RecipeSettingsDependencies
declare_for_chroot -A dependency_SkipInstall
declare_for_chroot -A dependency_MakeFhsFoldersBeforeInstallPaths
declare_for_chroot -A dependency_RemoveResourcePaths
declare_for_chroot -A dependency_DocResourcePaths
declare_for_chroot -A dependency_CompileResourcePaths
declare_for_chroot -A dependency_LibtoolArchivePaths
declare_for_chroot -A dependency_BinaryStripPaths
declare_for_chroot -A dependency_UidGidPaths
declare_for_chroot -A dependency_BinaryPermissionBitsPaths
declare_for_chroot -A dependency_CapabilitiesBinaryInstallPaths
declare_for_chroot -A dependency_BinaryInstallPaths
declare_for_chroot -A dependency_SystemBinaryInstallPaths
declare_for_chroot -A dependency_IncludeIndices

declare_for_chroot -a includes_DependencyKey
declare_for_chroot -a includes_Name
declare_for_chroot -a includes_Version

# Since this file is source'd inside a function, the declare builtin defaults to making variables local!
declare -ig nextSystemUid=-1
declare -ig nextSystemGid=-1
declare -ig nextUserUid=-1
declare -ig nextUserGid=-1

declare_for_chroot -a groups_Name
declare_for_chroot -a groups_Gid
declare_for_chroot -a groups_Members

declare_for_chroot -a users_Name
declare_for_chroot -a users_Gecos
declare_for_chroot -a users_Home
declare_for_chroot -a users_Shell
declare_for_chroot -a users_Uid
declare_for_chroot -a users_Gid

function warning()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	echo "$ourName: WARNING: $1" 1>&2
}

function informationMessage()
{
	echo "$ourName: $1"
}

function progressMessage()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	SECONDS=0
	printf '%s' "$ourName: $1"
}

function progressMessageUpdate()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	printf '%s' " $1"
}

function progressMessageFailed()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	echo " FAILED (in ${SECONDS}s: $1)"
	exit 1
}

function progressMessageSucceeded()
{
	if [ $# -ne 0 ]; then
		exitError "Too many arguments"
	fi
	echo " PASSED (in ${SECONDS}s)"
}

function dependency_key()
{
	# bash has problems with keys containing non-alphanumerics
	# printf so as to avoid tr replacing a trailing \n (as would happen with a heredoc)
	DependencyKey="$(printf '%s:%s:%s' "$1" "$2" "$3" | tr --complement '[:alpha:][:digit:]' '_')"
}

function signature()
{
	local -r ourMirror="$1"
	local -r originalFileRelativePath="$2"
	local -r ourHashesSpaceSeparated="$3"
	
	local hashNameAndValue
	local hashName
	local hashValue
	local hashSignatureFileName
	local hashSignatureRelativePath
	
	local -i index
	for hashNameAndValue in $ourHashesSpaceSeparated
	do
		IFS=':' read -r -d$'\n' hashName hashValue hashSignatureFileName <<<"$hashNameAndValue"
		case "$hashName" in
			KEYRING|KEYFILE|HKP|HKP_UNCOMPRESSED)
				index=${#signatures_Mirror[@]}
				
				if [ -z "$hashSignatureFileName" ]; then
					hashSignatureFileName="$(purebash_basename "$originalFileRelativePath".sig)"
				fi
				hashSignatureRelativePath="$(purebash_dirname "$originalFileRelativePath")"/"$hashSignatureFileName"
				
				signatures_Mirror[$index]="$ourMirror"
				signatures_RelativePath[$index]="$hashSignatureRelativePath"
				signatures_FileName[$index]="$hashSignatureFileName"
				signatures_Compression[$index]=""
				signatures_Post[$index]="$LFS_DOWNLOAD_POST"
				signatures_ReferFrom[$index]="$LFS_DOWNLOAD_REFER_FROM"
				
				case "$hashName" in
					HKP|HKP_UNCOMPRESSED)
						hkp "$hashValue"
					;;
				esac
			;;
		esac
	done
}

function keyring()
{
	if [ $# -ne 3 ]; then
		exitError "Not exactly 3 arguments"
	fi
	
	local -r ourMirror="$1"
	local -r ourRelativePath="$2"
	local -r ourHashes="$3"
	local -r ourFileName="$(purebash_basename "$ourRelativePath")"
	
	if [ "${ourFileName##*.}" != "gpg" ]; then
		exitError "Only gpg keyrings are supported - which is not so for this keyring: $ourMirror $ourRelativePath"
	fi
	
	local -i index
	for index in ${!keyrings_FileName[@]}
	do
		if [ "${keyrings_FileName[$index]}" = "$ourFileName" ]; then
			if [ "${keyrings_Mirror[$index]}" != "$ourMirror" ]; then
				exitError "Attempt to override mirror for keyring $ourFileName to $ourMirror"
			fi
			if [ "${keyrings_RelativePath[$index]}" != "$ourRelativePath" ]; then
				exitError "Attempt to override mirror for keyring $ourFileName to $ourRelativePath"
			fi
			return 0
		fi
	done
	
	index=${#keyrings_Mirror[@]}
	keyrings_Mirror+=("$ourMirror")
	keyrings_RelativePath+=("$ourRelativePath")
	keyrings_FileName+=("$ourFileName")
	keyrings_Hashes+=("${ourHashes//,/ }")
	keyrings_Compression+=("")
	keyrings_Post+=("$LFS_DOWNLOAD_POST")
	keyrings_ReferFrom+=("$LFS_DOWNLOAD_REFER_FROM")
	
	signature "$ourMirror" "$ourRelativePath" "${keyrings_Hashes[$index]}"
}

function key()
{
	if [ $# -lt 3 ]; then
		exitError "Not 3 or 4 arguments"
	fi
	if [ $# -gt 4 ]; then
		exitError "Not 3 or 4 arguments"
	fi
	
	local -r ourMirror="$1"
	local -r ourRelativePath="$2"
	
	local -r ourHashes="$3"
	if [ $# -eq 3 ]; then
		local -r ourFileName="$(purebash_basename "$ourRelativePath")"
	else
		local -r ourFileName="$4"
	fi
	
	local -i index
	for index in ${!keys_FileName[@]}
	do
		if [ "${keys_FileName[$index]}" = "$ourFileName" ]; then
			if [ "${keys_Mirror[$index]}" != "$ourMirror" ]; then
				exitError "Attempt to override mirror for key $ourFileName to $ourMirror"
			fi
			if [ "${keys_RelativePath[$index]}" != "$ourRelativePath" ]; then
				exitError "Attempt to override mirror for key $ourFileName to $ourRelativePath"
			fi
			return 0
		fi
	done
	
	index=${#keys_Mirror[@]}
	keys_Mirror+=("$ourMirror")
	keys_RelativePath+=("$ourRelativePath")
	keys_FileName+=("$ourFileName")
	keys_Hashes+=("${ourHashes//,/ }")
	keys_Compression+=("")
	keys_Post+=("$LFS_DOWNLOAD_POST")
	keys_ReferFrom+=("$LFS_DOWNLOAD_REFER_FROM")
	
	signature "$ourMirror" "$ourRelativePath" "${keys_Hashes[$index]}"
}

function hkp()
{
	if [ $# -ne 1 ]; then
		exitError "Not 1 argument"
	fi
	local -r keyId="$1"
	
	key HKPS "$keyId" "" "$keyId"
}

function skip_install()
{
	local -r ourRecipeName="$LFS_RECIPE_NAME"
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"

	dependency_key "$LFS_PHASE" "$ourRecipeName" "$ourRecipeVersion"
	
	local phase
	for phase in "$@"
	do
		if [ "$phase" = "$LFS_PHASE" ]; then
			dependency_SkipInstall["$DependencyKey"]="1"
			return 0
		fi
	done
}

function source_package()
{
	if [ $# -lt 3 ]; then
		exitError "Not enough arguments"
	elif [ $# -gt 6 ]; then
		exitError "Too many arguments"
	fi
	
	if [ -z "$LFS_SOURCE_PACKAGE_NAME" ]; then
		local -r ourSourcePackageName="$LFS_RECIPE_NAME"
		local -r ourRecipeName="$ourSourcePackageName"
	else
		local -r ourSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
		local -r ourRecipeName="$LFS_RECIPE_NAME"
	fi
	
	if [ -z "$LFS_SOURCE_PACKAGE_VERSION" ]; then
		local -r ourSourcePackageVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
		local -r ourRecipeVersion="$ourSourcePackageVersion"
	else
		local -r ourSourcePackageVersion="$LFS_SOURCE_PACKAGE_VERSION"
		local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	fi
	
	local -r ourMirror="$1"
	local -r ourRelativePath="$2"
	local -r ourHashes="$3"
	local -r ourFileName="$(purebash_basename "$ourRelativePath")"
	
	local -r compressionExtension="${ourFileName##*.}"
	
	if [ $# -ge 4 ]; then
		local -r ourExtractedTarballFolder="$4"
	else
		local -r withoutCompressionExtension="${ourFileName%.*}"
		if [ -z "$compressionExtension" ]; then
			local -r ourExtractedTarballFolder="$withoutCompressionExtension"
		else
			case "$compressionExtension" in
				
				# The various abominations are also slackware packages (txz, tgz especially)
				tar|tgz|tbz|tbz2|txz|tlz|tlzma|tz|taz)
					local -r ourExtractedTarballFolder="$withoutCompressionExtension"
				;;
				
				*)
					local -r ourExtractedTarballFolder="${withoutCompressionExtension%.*}"
				;;
				
			esac
		fi
	fi
	
	if [ $# -ge 5 ]; then
		local -r ourCompression="$5"
	else
		case "$compressionExtension" in
			tar)
				local -r ourCompression=''
			;;
			
			gz|tgz)
				local -r ourCompression=gzip
			;;
			
			bz2|bz|tbz2|tbz)
				local -r ourCompression=bzip2
			;;
			
			# Not included in dependencies by default
			# A faster compressor still is lz4
			lzo)
				local -r ourCompression=lzop
			;;
			
			lz|tlz)
				local -r ourCompression=lzip
			;;
			
			lzma|tlzma)
				local -r ourCompression=lzma
			;;
			
			xz|txz)
				local -r ourCompression=xz
			;;
			
			Z|tz|taz)
				# eg gzip downloads
				local -r ourCompression=compress
			;;
			
			*)
				if [ ! -z "$compressionExtension" ]; then
					exitError "Unknown file extension $compressionExtension for $ourSourcePackageName $ourSourcePackageVersion"
				fi
			;;
		esac
	fi
	
	if [ $# -ge 6 ]; then
		local -r isTarbomb="$6"
	else
		local -r isTarbomb="no"
	fi
	
	dependency_key "$LFS_PHASE" "$ourRecipeName" "$ourRecipeVersion"
	local -i index
	for index in ${!sourcePackages_Name[@]}
	do
		if [ "${sourcePackages_Name[$index]}" = "$ourSourcePackageName" ]; then
			if [ "${sourcePackages_Version[$index]}" = "$ourSourcePackageVersion" ]; then
				local -r existingSourcePackageIndices="${dependency_SourcePackageIndices["$DependencyKey"]}"
				if [ -z "$existingSourcePackageIndices" ]; then
					dependency_SourcePackageIndices["$DependencyKey"]="$index"
				else
					dependency_SourcePackageIndices["$DependencyKey"]="$existingSourcePackageIndices $index"
				fi
				return 0
			fi
		fi
	done
	
	index=${#sourcePackages_Name[@]}

	local -r existingSourcePackageIndices="${dependency_SourcePackageIndices["$DependencyKey"]}"
	if [ -z "$existingSourcePackageIndices" ]; then
		dependency_SourcePackageIndices["$DependencyKey"]="$index"
	else
		dependency_SourcePackageIndices["$DependencyKey"]="$existingSourcePackageIndices $index"
	fi
	
	sourcePackages_Name+=("$ourSourcePackageName")
	sourcePackages_Version+=("$ourSourcePackageVersion")
	
	sourcePackages_Mirror+=("$ourMirror")
	sourcePackages_RelativePath+=("$ourRelativePath")
	sourcePackages_Hashes+=("${ourHashes//,/ }")
	sourcePackages_Compression+=("$ourCompression")
	sourcePackages_Post+=("$LFS_DOWNLOAD_POST")
	sourcePackages_ReferFrom+=("$LFS_DOWNLOAD_REFER_FROM")
	sourcePackages_FileName+=("$ourFileName")
	sourcePackages_ExtractedTarballFolder+=("$ourExtractedTarballFolder")
	sourcePackages_IsTarbomb+=("$isTarbomb")
	signature "$ourMirror" "$ourRelativePath" "${sourcePackages_Hashes[$index]}"
}

function source_patch()
{
	if [ $# -ne 3 ]; then
		exitError "Not enough arguments"
	fi
	
	if [ -z "$LFS_SOURCE_PACKAGE_NAME" ]; then
		local -r ourSourcePackageName="$LFS_RECIPE_NAME"
	else
		local -r ourSourcePackageName="$LFS_SOURCE_PACKAGE_NAME"
	fi
	
	if [ -z "$LFS_SOURCE_PACKAGE_VERSION" ]; then
		local -r ourSourcePackageVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	else
		local -r ourSourcePackageVersion="$LFS_SOURCE_PACKAGE_VERSION"
	fi
	
	local -r ourMirror="$1"
	local -r ourRelativePath="$2"
	local -r ourHashes="$3"
	local -r ourFileName="$(purebash_basename "$ourRelativePath")"

	local -i sourcePackageIndex=-1
	for index in ${!sourcePackages_Name[@]}
	do
		if [ "$ourSourcePackageName" = "${sourcePackages_Name[$index]}" ]; then
			if [ "$ourSourcePackageVersion" = "${sourcePackages_Version[$index]}" ]; then
				sourcePackageIndex=$index
				break
			fi
		fi
	done
	
	if [ $sourcePackageIndex -eq -1 ]; then
		exitError "Patch is for unknown source package $ourSourcePackageName $ourSourcePackageVersion"
	fi
	
	dependency_key "$LFS_PHASE" "$ourSourcePackageName" "$ourSourcePackageVersion"
	local -r existingPatchIndices="${dependency_PatchIndices["$DependencyKey"]}"
	local -i index
	for index in ${!patches_RelativePath[@]}
	do
		if [ "${patches_RelativePath[$index]}" = "$ourRelativePath" ]; then
			if [ "${patches_Mirror[$index]}" = "$ourMirror" ]; then
				if [ -z "$existingPatchIndices" ]; then
					dependency_PatchIndices["$DependencyKey"]="$index"
				else
					dependency_PatchIndices["$DependencyKey"]="$existingPatchIndices $index"
				fi
				return 0
			fi
		fi
	done
	
	index=${#patches_Mirror[@]}
	patches_Mirror+=("$ourMirror")
	patches_FileName+=("$ourFileName")
	patches_RelativePath+=("$ourRelativePath")
	patches_Hashes+=("${ourHashes//,/ }")
	patches_Compression+=("")
	patches_Post+=("$LFS_DOWNLOAD_POST")
	patches_ReferFrom+=("$LFS_DOWNLOAD_REFER_FROM")
	patches_SourcePackageIndex+=($sourcePackageIndex)
	
	if [ -z "$existingPatchIndices" ]; then
		dependency_PatchIndices["$DependencyKey"]="$index"
	else
		dependency_PatchIndices["$DependencyKey"]="$existingPatchIndices $index"
	fi
	
	signature "$ourMirror" "$ourRelativePath" "${patches_Hashes[$index]}"
}

function version()
{
	if [ $# -ne 1 ]; then
		exitError "Needs 1 argument"
	fi
	local -r ourRecipeVersion="$1"
	
	local -r previousVersions="${LFS_RECIPE_VERSIONS["${LFS_RECIPE_NAME}"]}"
	if [ -z "$previousVersions" ]; then
		LFS_RECIPE_VERSIONS["${LFS_RECIPE_NAME}"]="$ourRecipeVersion"
	else
		LFS_RECIPE_VERSIONS["${LFS_RECIPE_NAME}"]="$previousVersions $ourRecipeVersion"
	fi
	LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]="$ourRecipeVersion"
	
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	dependency_Phase["$DependencyKey"]="$LFS_PHASE"
	dependency_Name["$DependencyKey"]="$LFS_RECIPE_NAME"
	dependency_Version["$DependencyKey"]="$ourRecipeVersion"
	dependency_RecipeHash["$DependencyKey"]="$LFS_RECIPE_HASH"
	dependency_IncludeHash["$DependencyKey"]="$LFS_RECIPE_INCLUDE_HASH"
	dependency_SettingsHash["$DependencyKey"]="$LFS_RECIPE_SETTINGS_HASH"
	dependency_UidGid["$DependencyKey"]="$LFS_RECIPE_UIDGID"
	dependency_SourcePackageIndices["$DependencyKey"]=""
	dependency_PatchIndices["$DependencyKey"]=""
	dependency_Dependencies["$DependencyKey"]=""
	dependency_Path["$DependencyKey"]=""
	dependency_RelativePath["$DependencyKey"]=""
	dependency_RecipeSettingsDependencies["$DependencyKey"]=""
	dependency_SkipInstall["$DependencyKey"]="0"
	dependency_RemoveResourcePaths["$DependencyKey"]=""
	dependency_CompileResourcePaths["$DependencyKey"]=""
	dependency_LibtoolArchivePaths["$DependencyKey"]=""
	dependency_BinaryStripPaths["$DependencyKey"]=""
	dependency_UidGidPaths["$DependencyKey"]=""
	dependency_BinaryPermissionBitsPaths["$DependencyKey"]=""
	dependency_CapabilitiesBinaryInstallPaths["$DependencyKey"]=""
	dependency_BinaryInstallPaths["$DependencyKey"]=""
	dependency_SystemBinaryInstallPaths["$DependencyKey"]=""
	dependency_IncludeIndices["$DependencyKey"]=""
	
	if [ "$LFS_RECIPE_INCLUDE_HASH" != "0" ]; then
		include "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	fi
}

function include()
{
	if [ $# -ne 2 ]; then
		exitError "Needs 2 arguments"
	fi
	
	local -r includeSourcePackageName="$1"
	local -r includeSourcePackageVersion="$2"
	
	local includeFile="$includesPath"/"$includeSourcePackageName".include
	if [ ! -f "$includeFile" ]; then
		exitError "No include $includeSourcePackageName known in recipe $LFS_RECIPE_NAME"
	fi
	
	local -i index
	for index in ${dependency_IncludeIndices["$DependencyKey"]}
	do
		if [ "${includes_DependencyKey[$index]}" = "$DependencyKey" ]; then
			if [ "${includes_Name[$index]}" = "$includeSourcePackageName" ]; then
				exitError "Multiple versions of $includeSourcePackageName (${includes_Version[$index]} and $includeSourcePackageVersion) are not supported"
			fi
		fi
	done
	
	LFS_SOURCE_PACKAGE_NAME="$includeSourcePackageName" LFS_SOURCE_PACKAGE_VERSION="$includeSourcePackageVersion" source "$includeFile"
	
	index=${#includes_DependencyKey[@]}
	includes_DependencyKey+=("$DependencyKey")
	includes_Name+=("$includeSourcePackageName")
	includes_Version+=("$includeSourcePackageVersion")
	
	local -r existingIndices="${dependency_IncludeIndices["$DependencyKey"]}"
	if [ -z "$existingIndices" ]; then
		dependency_IncludeIndices["$DependencyKey"]="$index"
	else
		dependency_IncludeIndices["$DependencyKey"]="$existingIndices $index"
	fi
}

function depends()
{
	if [ $# -ne 1 ]; then
		exitError "Needs 1 argument"
	fi
	local -r localSourcePackageName="$1"
	
	local -i alreadySourced=0
	local previousRecipe
	for previousRecipe in ${phase_PreviousRecipes["${LFS_PHASE}"]}
	do
		if [ "$previousRecipe" = "$localSourcePackageName" ]; then
			alreadySourced=1
			break
		fi
	done
	
	if [ $alreadySourced -eq 0 ]; then
		
		local -r recipeFile="$recipesPath"/"$LFS_PHASE"/"$localSourcePackageName".recipe
		
		local -r uidgidFile="$recipesPath"/"$LFS_PHASE"/"$localSourcePackageName".uidgid
		
		if [ ! -f "$recipeFile" ]; then
			exitError "recipe $localSourcePackageName ($recipeFile) does not exist or is not a file"
		fi
		
		if [ ! -f "$uidgidFile" ]; then
			exitError "uidgid file for $localSourcePackageName ($uidgidFile) does not exist or is not a file"
		fi
		
		# Prevent recursion
		phase_PreviousRecipes["${LFS_PHASE}"]="${phase_PreviousRecipes["${LFS_PHASE}"]} $localSourcePackageName"
	
		# set / unset inside includeLeafRecipe
		# Set to blank to avoid bash's associative array bugs with non-existent members (it aliases the last added member)
		LFS_RECIPE_VERSIONS["${localSourcePackageName}"]=""
		
		# Holds the last set version
		LFS_RECIPE_VERSION["${localSourcePackageName}"]=""
		
		local -r kConfigFile="$settingsPath"/"$LFS_PHASE"/"$localSourcePackageName".config
		if [ -f "$kConfigFile" ]; then
			local -r settingsHash="$(sha256sum "$kConfigFile" | awk 'NR==1 {print $1}')"
		else
			local -r settingsFile="$settingsPath"/"$LFS_PHASE"/"$localSourcePackageName".settings
			if [ -f "$settingsFile" ]; then
				local -r settingsHash="$(sha256sum "$settingsFile" | awk 'NR==1 {print $1}')"
				LFS_RECIPE_NAME="$localSourcePackageName" source "$settingsFile"
			else
				local -r settingsHash="0"
			fi
		fi
		
		local includeFile="$includesPath"/"$localSourcePackageName".include
		if [ -f "$includeFile" ]; then
			local -r includeHash="$(sha256sum "$includeFile" | awk 'NR==1 {print $1}')"
		else
			local -r includeHash="0"
			includeFile=""
		fi
		
		local userAndGroupName=lfs-"$localSourcePackageName"
		
		local relativeUidGid="$(head -n 1 "$uidgidFile")"
		if [ -z "$relativeUidGid" ]; then
			exitError "Undefined package relative uid/gid for $localSourcePackageName ($uidgidFile)"
		fi
		
		local -ir baseRecipeUidGid=${settings_integer[LFS_INCLUSIVE_RECIPE_UID]}
		
		local -ir absoluteUidGid=$((relativeUidGid+baseRecipeUidGid))
		
		local -i create=1
		local group
		for group in ${groups_Name[@]}
		do
			if [ "$group" = "$userAndGroupName" ]; then
				create=0
			fi
		done
		
		if [ $create -eq 1 ]; then
			system_group "$userAndGroupName" $absoluteUidGid
			user "$userAndGroupName" "$userAndGroupName" /dev/null /bin/false $absoluteUidGid "$userAndGroupName"
		fi
		
		# Weirdly, but usefully, a source'd file has access to our local variables AND can mutate them (it does not run a subshell or stack scope)
		# BUT, and here's the BUT, they won't get passed down to any functions!
		LFS_RECIPE_NAME="$localSourcePackageName" LFS_RECIPE_HASH="$(sha256sum "$recipeFile" | awk 'NR==1 {print $1}')" LFS_RECIPE_INCLUDE_HASH="$includeHash" LFS_RECIPE_SETTINGS_HASH="$settingsHash" LFS_RECIPE_UIDGID=$absoluteUidGid source "$recipeFile"
	fi
	
	# We currently only do this for the last set version. In future, we might be able to take a directive from above
	# if depends bash is called, which does version 4.2, depends gcc, version 2.5, then once back in 'depends bash':-
	#  LFS_RECIPE_NAME is blank
	# "${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"   is 4.2
	#  localSourcePackageName is gcc
	# "${LFS_RECIPE_VERSION["${localSourcePackageName}"]}"   is 2.5
	
	# Add to parent's dependencies
	# LFS_RECIPE_NAME will be blank for the package listed in the profile
	dependency_key "$LFS_PHASE" "$localSourcePackageName" "${LFS_RECIPE_VERSION["${localSourcePackageName}"]}"
	local -r child="$DependencyKey"
	
	if [ ! -z "$LFS_RECIPE_NAME" ]; then
		dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
		local -r parent="$DependencyKey"
		local -r dependencies="${dependency_Dependencies["$parent"]}"
		if [ -z "$dependencies" ]; then
			dependency_Dependencies["$parent"]="$child"
		else
			dependency_Dependencies["$parent"]="$dependencies $child"
		fi
	fi
	
	local existingInstall
	for existingInstall in ${phase_InstallationOrder["${LFS_PHASE}"]}
	do
		if [ "$existingInstall" = "$child" ]; then
			return 0
		fi
	done
	
	local -r all="${phase_InstallationOrder["${LFS_PHASE}"]}"
	if [ -z "$all" ]; then
		phase_InstallationOrder["${LFS_PHASE}"]="$child"
	else
		phase_InstallationOrder["${LFS_PHASE}"]="$all $child"
	fi
}

function conflicts()
{
	exitError "Unimplemented"
}

function system_group()
{
	local -r groupName="$1"
	if [ $# -eq 2 ]; then
		local -ir proposedGid=$2
	fi
	
	local -i index
	for index in ${!groups_Name[@]}
	do
		if [ "${groups_Name[$index]}" = "$groupName" ]; then
			if [ $# -eq 2 ]; then
				if [ ${groups_Gid[$index]} -ne $proposedGid ]; then
					exitError "mismatch in group gids for $groupName, $gid (is previously defined as ${groups_Gid[$index]})"
				else
					return 0
				fi
			else
				return 0
			fi
		fi
	done
	
	if [ $# -eq 2 ]; then
		local -ir gid=$proposedGid
	else
		if [ $nextSystemGid -eq -1 ]; then
			nextSystemGid=${settings_integer[LFS_INCLUSIVE_SYSTEM_GID]}
		fi
		local -ir gid=$((nextSystemGid++))
	fi
	
	index=${#groups_Name[@]}
	groups_Name[$index]="$groupName"
	groups_Gid[$index]=$gid
	groups_Members[$index]=""
}

function verifyGroupExists()
{
	local -r groupName="$1"
	local -r userName="$2"
	local group
	for group in ${groups_Name[@]}
	do
		if [ "$group" = "$groupName" ]; then
			return 0
		fi
	done
	exitError "Group with name $groupName does exist for user $userName"
}

function user()
{
	local -r userName="$1"
	local -r gecos="$2"
	local -r home="$3"
	local -r shell="$4"
	
	if [ $# -eq 6 ]; then
		verifyGroupExists $6 "$userName"
	fi
	
	local -i index
	for index in ${!users_Name[@]}
	do
		if [ "${users_Name[$index]}" = "$userName" ]; then
			if [ "${users_Gecos[$index]}" != "$gecos" ]; then
				exitError "gecos redefined for user $userName"
			fi
			if [ "${users_Home[$index]}" != "$home" ]; then
				exitError "home redefined for user $userName"
			fi
			if [ "${users_Shell[$index]}" != "$shell" ]; then
				exitError "shell redefined for user $userName"
			fi
			if [ $# -ge 5 ]; then
				if [ ${users_Uid[$index]} -ne $5 ]; then
					exitError "uid redefined for user $userName"
				fi
			fi
		fi
	done
	
	if [ $# -ge 5 ]; then
		local -ir uid=$5
	else
		if [ "$shell" = "/bin/false" ]; then
			if [ $nextSystemUid -eq -1 ]; then
				nextSystemUid=${settings_integer[LFS_INCLUSIVE_SYSTEM_UID]}
			fi
		else
			if [ $nextUserId -eq -1 ]; then
				nextUserUid=${settings_integer[LFS_INCLUSIVE_USER_UID]}
			fi
			local -ir uid=$((nextUserUid++))
		fi
	fi
	
	# check uid not already in use
	local -i existingUid
	for existingUid in ${users_Uid[@]}
	do
		if [ $existingUid -eq $uid ]; then
			exitError "uid $uid already exists for user $userName"
		fi
	done
	
	if [ $# -eq 6 ]; then
		local -r groupName="$6"
		local -i gid=-1
		for index in ${!groups_Name[@]}
		do
			if [ "${groups_Name[$index]}" = "$groupName" ]; then
				gid=${groups_Gid[$index]}
				break
			fi
		done
		if [ $gid -eq -1 ]; then
			exitError "Group $groupName not defined for user $userName"
		fi
	else
		if [ "$shell" = "/bin/false" ]; then
			local -ir gid=$((nextSystemGid++))
		else
			if [ $nextUserGid -eq -1 ]; then
				nextUserGid=${settings_integer[LFS_INCLUSIVE_USER_GID]}
			fi
			local -ir gid=$((nextUserGid++))
		fi
	fi
	
	# check gid not already in use
	local -i existingGid
	for existingGid in ${users_Gid[@]}
	do
		if [ $existingGid -eq $gid ]; then
			exitError "gid $gid already exists for user $userName"
		fi
	done
		
	local -r ourSourcePackageName="$LFS_RECIPE_NAME"
	
	index=${#users_Name[@]}
	users_Name[$index]="$userName"
	users_Gecos[$index]="$gecos"
	users_Home[$index]="$home"
	users_Shell[$index]="$shell"
	users_Uid[$index]=$uid
	users_Gid[$index]=$gid
	
	LFS_LAST_UID=$uid
	LFS_LAST_GID=$gid
}

function remove_unwanted()
{
	local -r parentPath="$1"
	shift 1
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local file
	local filePath
	local existingPaths
	for file in "$@"
	do
		filePath="$parentPath"/"$file"
		
		existingPaths="${dependency_RemoveResourcePaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_RemoveResourcePaths["$DependencyKey"]="$filePath"
		else
			dependency_RemoveResourcePaths["$DependencyKey"]="$existingPaths $filePath"
		fi
	done
}

function doc_resources()
{
	local -r parentPath="$1"
	shift 1
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local file
	local filePath
	local existingPaths
	for file in "$@"
	do
		filePath="$parentPath"/"$file"
		
		existingPaths="${dependency_DocResourcePaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_DocResourcePaths["$DependencyKey"]="$filePath"
		else
			dependency_DocResourcePaths["$DependencyKey"]="$existingPaths $filePath"
		fi
	done
}

function compile_resources()
{
	local -r parentPath="$1"
	shift 1
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local file
	local filePath
	local existingPaths
	for file in "$@"
	do
		filePath="$parentPath"/"$file"
		
		existingPaths="${dependency_CompileResourcePaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_CompileResourcePaths["$DependencyKey"]="$filePath"
		else
			dependency_CompileResourcePaths["$DependencyKey"]="$existingPaths $filePath"
		fi
	done
}

function libtool_archives()
{
	local -r parentPath="$1"
	shift 1
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local file
	local filePath
	local existingPaths
	for file in "$@"
	do
		filePath="$parentPath"/"$file"
		
		existingPaths="${dependency_LibtoolArchivePaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_LibtoolArchivePaths["$DependencyKey"]="$filePath"
		else
			dependency_LibtoolArchivePaths["$DependencyKey"]="$existingPaths $filePath"
		fi
	done
}

function strip_unneeded()
{
	local -r parentPath="$1"
	shift 1
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local file
	local filePath
	local existingPaths
	for file in "$@"
	do
		filePath="$parentPath"/"$file"
		
		existingPaths="${dependency_BinaryStripPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_BinaryStripPaths["$DependencyKey"]="$filePath"
		else
			dependency_BinaryStripPaths["$DependencyKey"]="$existingPaths $filePath"
		fi
	done
}

function uidgid_paths()
{
	local -r value="$1"
	local -r parentPath="$2"
	shift 2
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local path
	local combination
	local existingPaths
	for path in "$@"
	do
		combination="${parentPath}/${path}.${value}"
		
		existingPaths="${dependency_UidGidPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_UidGidPaths["$DependencyKey"]="$combination"
		else
			dependency_UidGidPaths["$DependencyKey"]="$existingPaths $combination"
		fi
	done
}

function capabilities_binaries()
{
	local -r value="$1"
	local -r parentPath="$2"
	shift 2
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local path
	local combination
	local existingPaths
	for path in "$@"
	do
		combination="${parentPath}/${path}.${value}"
		
		existingPaths="${dependency_CapabilitiesBinaryInstallPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_CapabilitiesBinaryInstallPaths["$DependencyKey"]="$combination"
		else
			dependency_CapabilitiesBinaryInstallPaths["$DependencyKey"]="$existingPaths $combination"
		fi
	done
}

function _binaryPermissionBits()
{
	local -r value="$1"
	local -r parentPath="$2"
	shift 2
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local path
	local combination
	local existingPaths
	for path in "$@"
	do
		combination="${parentPath}/${path}.${value}"
		
		existingPaths="${dependency_BinaryPermissionBitsPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_BinaryPermissionBitsPaths["$DependencyKey"]="$combination"
		else
			dependency_BinaryPermissionBitsPaths["$DependencyKey"]="$existingPaths $combination"
		fi
	done
}

function executable_binaries()
{
	local -r parentPath="$1"
	shift 1
	_binaryPermissionBits a+x "$parentPath" "$@"
}

function setuid_binaries()
{
	local -r parentPath="$1"
	shift 1
	_binaryPermissionBits u+s "$parentPath" "$@"
}

function setgid_binaries()
{
	local -r parentPath="$1"
	shift 1
	_binaryPermissionBits g+s "$parentPath" "$@"
}

function explicit_filemode()
{
	local -r fileModeBits="$1"
	local -r parentPath="$2"
	shift 2
	_binaryPermissionBits "$fileModeBits" "$parentPath" "$@"
}

function install_binaries()
{
	local -r relativeBinaryPath="$1"
	shift 1
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local binary
	local binaryPath
	local existingPaths
	for binary in "$@"
	do
		binaryPath="$relativeBinaryPath"/"$binary"
		
		existingPaths="${dependency_BinaryInstallPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_BinaryInstallPaths["$DependencyKey"]="$binaryPath"
		else
			dependency_BinaryInstallPaths["$DependencyKey"]="$existingPaths $binaryPath"
		fi
	done
}

function install_system_binaries()
{
	local -r relativeBinaryPath="$1"
	shift 1
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local binary
	local binaryPath
	local existingPaths
	for binary in "$@"
	do
		binaryPath="$relativeBinaryPath"/"$binary"
		
		existingPaths="${dependency_SystemBinaryInstallPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_SystemBinaryInstallPaths["$DependencyKey"]="$binaryPath"
		else
			dependency_SystemBinaryInstallPaths["$DependencyKey"]="$existingPaths $binaryPath"
		fi
	done
}

function make_fhs_folders_before_install()
{
	local -r relativeParentPath="$1"
	shift 1
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local folder
	local folderPath
	local existingPaths
	for folderPath in "$@"
	do
		# The leading slash is deliberate
		binaryPath=/"$relativeParentPath"/"$folderPath"
		
		existingPaths="${dependency_MakeFhsFoldersBeforeInstallPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_MakeFhsFoldersBeforeInstallPaths["$DependencyKey"]="$binaryPath"
		else
			dependency_MakeFhsFoldersBeforeInstallPaths["$DependencyKey"]="$existingPaths $binaryPath"
		fi
	done
}

function include_mirror()
{
	if [ $# -ne 1 ]; then
		exitError "Not exactly 1 argument"
	fi
	
	local -r localMirror="$1"
	
	local previousMirror
	for previousMirror in "${previousMirrors[@]}"
	do
		if [ "$previousMirror" = "$localMirror" ]; then
			exitError "Recursion of mirrors - trying to use $localMirror after mirror stack of $previousMirrors"
		fi
	done
	previousMirrors+=("$localMirror")
	
	if [ -f "$mirrorsPath"/"$localMirror".mirrors ]; then
		source "$mirrorsPath"/"$localMirror".mirrors
	else
		exitError "mirrors $localMirror.mirrors does not exist in mirrors path $mirrorsPath or is not a file"
	fi
}

function dependencyPath()
{
	local -r dependencyName="$1"
	for dependencyKey in "${!dependency_Name[@]}"
	do
		if [ "${dependency_Name["$dependencyKey"]}" = "$dependencyName" ]; then
			if [ "${dependency_Phase["$dependencyKey"]}" = "$LFS_PHASE" ]; then
				echo -n "${dependency_Path["$dependencyKey"]}"
				return 0
			fi
		fi
	done
}

function fixUpGnulib()
{
	pushdDependencyFolder
	
		../gnulib/gnulib-tool --add-import
		
	popdDependencyFolder
}

function fixUpAutoToolsConfig()
{
	if [ -d config ]; then
		
		pushd config >/dev/null
			local -r configSubFile="$(pwd)"/config.sub
			local -r configGuessFile="$(pwd)"/config.guess
			chmod +x "$configSubFile"
			chmod +x "$configGuessFile"
		popd >/dev/null
		
		local dependencyFolder
		for dependencyFolder in *
		do
			if [ "$dependencyFolder" = "config" ]; then
				continue
			fi
			if [ "${dependencyFolder:0:7}" = "config-" ]; then
				continue
			fi
		
			if [ ! -d "$dependencyFolder" ]; then
				continue
			fi
			
			pushd "$dependencyFolder" >/dev/null
			
				# Update autotools malarkey
				local configFolder
				local configFile
				for configFolder in . config support build-aux
				do
					if [ ! -d "$configFolder" ]; then
						continue
					fi
					
					pushd "$configFolder" >/dev/null
					
						for configFile in config.sub configfsf.sub
						do
							if [ -f "$configFile" ]; then
								mv "$configFile" "$configFile".orig
								ln "$configSubFile" "$configFile"
							fi
						done
						for configFile in config.guess
						do
							if [ -f "$configFile" ]; then
								mv "$configFile" "$configFile".orig
								ln "$configGuessFile" "$configFile"
							fi
						done
						
					popd >/dev/null
				done
			
				popd >/dev/null
		done
	fi
}

function autotoolsConfiguredMakeWrapper()
{
	# This weird setting of PATH is so we can use the set -x output on the command line directly to test build problems
	PATH="$PATH" \
	make \
		--jobs $LFS_MAKE_COMPILE_JOBS \
		--load-average $LFS_MAKE_LOAD_AVERAGE \
		--debug \
		--print-directory \
		V=1 \
	"$@" 1>&2
}

function buildUsingMakeExternal()
{
	# This weird setting of PATH is so we can use the set -x output on the command line directly to test build problems
	PATH="$PATH" \
	make \
		--jobs $LFS_MAKE_COMPILE_JOBS \
		--load-average $LFS_MAKE_LOAD_AVERAGE \
		--debug \
		--print-directory \
		V=1 \
		CC="$LFS_C_TARGET_EXTERNAL_CC" \
		CXX="$LFS_C_TARGET_EXTERNAL_CXX" \
		CPP="$LFS_C_TARGET_EXTERNAL_CPP" \
		CXXCPP="$LFS_C_TARGET_EXTERNAL_CXXCPP" \
		AR="$LFS_C_TARGET_EXTERNAL_AR" \
		AS="$LFS_C_TARGET_EXTERNAL_AS" \
		NM="$LFS_C_TARGET_EXTERNAL_NM" \
		RANLIB="$LFS_C_TARGET_EXTERNAL_RANLIB" \
		OBJDUMP="$LFS_C_TARGET_EXTERNAL_OBJDUMP" \
		OBJCOPY="$LFS_C_TARGET_EXTERNAL_OBCOPY" \
		LD="$LFS_C_TARGET_EXTERNAL_LD" \
		STRIP="$LFS_C_TARGET_EXTERNAL_STRIP" \
		CPPFLAGS="$LFS_C_TARGET_EXTERNAL_CPPFLAGS" \
		CFLAGS="$LFS_C_TARGET_EXTERNAL_CFLAGS" \
		CXXFLAGS="$LFS_C_TARGET_EXTERNAL_CXXFLAGS" \
		LDFLAGS="$LFS_C_TARGET_EXTERNAL_LDFLAGS" \
	"$@"
}

function callback_empty()
{
	:
}

# This is a hack for packages which don't support cross-compilation
function buildUsingAutotoolsHost()
{
	local -r callback="$1"
	shift 1
	
	fixUpAutoToolsConfig
	
	pushdDependencyFolder
		# This weird setting of PATH is so we can use the set -x output on the command line directly to test build problems
		PATH="$PATH" \
		./configure \
			CC="$LFS_C_HOST_CC" \
			CXX="$LFS_C_HOST_CXX" \
			CPP="$LFS_C_HOST_CPP" \
			CXXCPP="$LFS_C_HOST_CXXCPP" \
			AR="$LFS_C_HOST_AR" \
			AS="$LFS_C_HOST_AS" \
			NM="$LFS_C_HOST_NM" \
			RANLIB="$LFS_C_HOST_RANLIB" \
			OBJDUMP="$LFS_C_HOST_OBJDUMP" \
			OBJCOPY="$LFS_C_HOST_OBJCOPY" \
			LD="$LFS_C_HOST_LD" \
			STRIP="$LFS_C_HOST_STRIP" \
			CPPFLAGS="$LFS_C_HOST_CPPFLAGS" \
			CFLAGS="$LFS_C_HOST_CFLAGS" \
			CXXFLAGS="$LFS_C_HOST_CXXFLAGS" \
			LDFLAGS="$LFS_C_HOST_LDFLAGS" \
		--host="$LFS_NATIVE_TRIPLE" \
		--target="$LFS_NATIVE_TRIPLE" \
		--prefix="${LFS}${LFS_DEPENDENCY_PREFIX_PATH}"/build \
		"$@"
		
		$callback
		
		autotoolsConfiguredMakeWrapper
	
		if [ -z "$LFS" ]; then
			autotoolsConfiguredMakeWrapper install
		else
			autotoolsConfiguredMakeWrapper install
		fi
		
	popdDependencyFolder
}

function buildUsingAutotoolsExternal()
{	
	local -r callback="$1"
	shift 1
	
	fixUpAutoToolsConfig
	
	pushdDependencyFolder
		# This weird setting of PATH is so we can use the set -x output on the command line directly to test build problems
		# Note that an older name for CC_FOR_BUILD is HOST_CC
		PATH="$PATH" \
		./configure \
			CC_FOR_BUILD="$LFS_C_HOST_CC" \
			CXX_FOR_BUILD="$LFS_C_HOST_CXX" \
			CPPFLAGS_FOR_BUILD="$LFS_C_HOST_CPPFLAGS" \
			CFLAGS_FOR_BUILD="$LFS_C_HOST_CFLAGS" \
			CXXFLAGS_FOR_BUILD="$LFS_C_HOST_CXXFLAGS" \
			LDFLAGS_FOR_BUILD="$LFS_C_HOST_LDFLAGS" \
			CC="$LFS_C_TARGET_EXTERNAL_CC" \
			CXX="$LFS_C_TARGET_EXTERNAL_CXX" \
			CPP="$LFS_C_TARGET_EXTERNAL_CPP" \
			CXXCPP="$LFS_C_TARGET_EXTERNAL_CXXCPP" \
			AR="$LFS_C_TARGET_EXTERNAL_AR" \
			AS="$LFS_C_TARGET_EXTERNAL_AS" \
			NM="$LFS_C_TARGET_EXTERNAL_NM" \
			RANLIB="$LFS_C_TARGET_EXTERNAL_RANLIB" \
			OBJDUMP="$LFS_C_TARGET_EXTERNAL_OBJDUMP" \
			OBJCOPY="$LFS_C_TARGET_EXTERNAL_OBJCOPY" \
			LD="$LFS_C_TARGET_EXTERNAL_LD" \
			STRIP="$LFS_C_TARGET_EXTERNAL_STRIP" \
			CPPFLAGS="$LFS_C_TARGET_EXTERNAL_CPPFLAGS" \
			CFLAGS="$LFS_C_TARGET_EXTERNAL_CFLAGS" \
			CXXFLAGS="$LFS_C_TARGET_EXTERNAL_CXXFLAGS" \
			LDFLAGS="$LFS_C_TARGET_EXTERNAL_LDFLAGS" \
		--host="$LFS_NATIVE_TRIPLE" \
		--target="$LFS_FOREIGN_TRIPLE" \
		--prefix="$LFS_DEPENDENCY_PREFIX_PATH" \
		"$@"
		
		$callback
		
		autotoolsConfiguredMakeWrapper
	
		if [ -z "$LFS" ]; then
			autotoolsConfiguredMakeWrapper install
		else
			autotoolsConfiguredMakeWrapper DESTDIR="$LFS"/ install
		fi
		
	popdDependencyFolder
}

function pushdDependencyFolder()
{
	pushd "$LFS_DEPENDENCY_NAME" >/dev/null
}

function popdDependencyFolder()
{
	popd >/dev/null
}

function createBuildFolderAndPushd()
{
	local -r buildFolder=../"$LFS_DEPENDENCY_NAME"-build
	mkdir -m 0755 -p "$buildFolder"
	pushd "$buildFolder" >/dev/null
}

function popdBuildFolder()
{
	popd >/dev/null
}

function setLfsSourcePackageVariables()
{
	LFS_SOURCE_PACKAGE_NAME="${sourcePackages_Name[$1]}"
	LFS_SOURCE_PACKAGE_VERSION="${sourcePackages_Version[$1]}"
	LFS_SOURCE_PACKAGE_COMPRESSION="${sourcePackages_Compression[$1]}"
	LFS_SOURCE_PACKAGE_FILENAME="${sourcePackages_FileName[$1]}"
	LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER="${sourcePackages_ExtractedTarballFolder[$1]}"
	LFS_SOURCE_PACKAGE_IS_TARBOMB="${sourcePackages_IsTarbomb[$1]}"
	LFS_SOURCE_PACKAGE_MIRROR="${sourcePackages_Mirror[$1]}"
	LFS_SOURCE_PACKAGE_RELATIVE_PATH="${sourcePackages_RelativePath[$1]}"
}
