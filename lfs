#!/bin/bash -
set -e

function exitError()
{
	local -r error="$1"
	echo "$ourName: $error" 1>&2
	#exitHelp 1
	exit 1
}

function setDebugging()
{
	# is set -x on?
	if [[ "$-" == *x* ]]; then
		export LFS_BASH_DEBUGGING="yes"
	fi
	if [ "$LFS_BASH_DEBUGGING" = "yes" ];then
		set -x
	fi
}

function findOurNameAndPath()
{
	readonly ourName="$(basename "$0")"
	cd "$(dirname "$0")" 1>/dev/null
	readonly crudeOurPath="$(pwd)"
	cd - 1>/dev/null
}

function executeWithCleanEnvironment()
{
	exec env -i HOME="$HOME" TERM="$TERM" PS1='\u:\w\$ ' LFS_BASH_DEBUGGING="$LFS_BASH_DEBUGGING" LFS_CLEAN_ENVIRONMENT='yes' "$crudeOurPath"/"$ourName" $@
}

function exitHelp()
{
	cat 1>&2 <<-EOF
		Usage: ${ourName} -h
		Usage: ${ourName} -d distribution [-l lfsPath] [-c lfsConfigPath] [-t toolsFolderName] [-m mirrors] [-1 toolchain1Profile] [-2 toolchain2Profile] [-o option] -- [profiles ...]
		
		Profiles
		[profiles ...] lists one or more system profiles to create. These are snippets of simplified bash
		script, that install and build from source what would be called packages on other systems.
		
		If no profile is specified, then the baseline 'lfs' profile is used.
		
		profiles are executed in the order listed. Internally, a profile may reference ('source')
		another profile if it depends on it. This is the equivalent of package management on other
		systems. A set of profiles is intended to be version-controlled using a source control system
		such as git and so do not declare explicit version dependencies.
		
		The profiles 'toolchain1' and 'toolchain2' are special. Implementors of profiles can assume
		that these profiles are always sourced. It is an error to specify them in the list of profiles.
		
		A profile does not have to just install packages.
		
		Profiles may be suffixed with [distribution] to target a particular distribution.
		
		Defaults
		    distribution       ${distribution}
		    lfsPath            ${lfsPath}
		    lfsConfigPath      ${lfsConfigPath}
		    toolsFolderName    ${toolsFolderName}
		    mirrors            ${mirrors}
		    toolchain1Profile  ${toolchain1Profile}
		    toolchain2Profile  ${toolchain2Profile}
		    option             See below
		    profiles           ${profiles}
		
		A mirror defines mirror URLs. If a mirror is 'timezone', then timezone settings used to determine the actual mirrors.
		Note that if the timezone is Etc/UTC or something similar, then the 'language' mirrors are used. These use the LC_CTYPE,
		LANG and LANGUAGE environment variables in order. The 'global' mirror can be specified to override this. A list of mirrors
		is in <lfsConfigPath>/mirrors . Conversions from timezone and language are controlled using <lfsConfigPath>/timezones-to-mirrors.map
		and <lfsConfigPath>/languages-to-mirrors.map respectively. Note that some mirrors, eg for the UK, are incomplete and source
		the global mirrors first to provide defaults. mirrors may be symlinks.
		
		At this time we don't support the metalink (.meta4) protocol for mirrors (as it requires additional
		runtime dependencies).
		
		Options
		For options, prefix with either 'yes-' to turn it on
		or 'no-' to turn it off. For example, to turn on 'strip-system-docs' :-
		
		    ${ourName} -o yes-strip-system-docs
		
		-o may be repeated as necessary. Options are evaluated in left-to-right order.
		Last setting wins.
		
		Options are as follows:-     Default
		    strip-toolchain-symbols  ${stripToolchainSymbols}
		    strip-toolchain-docs     ${stripToolchainDocs}
		    strip-system-symbols     ${stripSystemSymbols}
		    strip-system-docs        ${stripSystemDocs}
	EOF
	exit $1
}

function parseCommandLine()
{
	# Defaults
	distributionVersion=""
	lfsPath="/var/tmp/lfs"
	lfsConfigPath="${crudeOurPath}/config"
	toolsFolderName=tools
	mirrors="timezone"
	toolchain1Profile=toolchain1
	toolchain2Profile=toolchain2
	stripToolchainSymbols="yes"
	stripToolchainDocs="no"
	stripSystemSymbols="yes"
	stripSystemDocs="no"
	profiles="system"
	
	if [ "$LFS_CLEAN_ENVIRONMENT" != "yes" ]; then
		executeWithCleanEnvironment "$@"
	else
		OPTERR=1
		OPTIND=1
		local option
		while getopts :hl:d:m:1:2:o: option
		do
			case "$option" in
				
				h)
					exitHelp 2
				;;
				
				d)
					distributionVersion="$OPTARG"
				;;
				
				l)
					lfsPath="$OPTARG"
				;;
				
				c)
					lfsConfigPath="$OPTARG"
				;;
				
				t)
					toolsFolderName="$OPTARG"
				;;
				
				m)
					mirrors="$OPTARG"
				;;
				
				1)
					toolchain1Profile="$OPTARG"
				;;
				
				2)
					toolchain2Profile="$OPTARG"
				;;
				
				o)
					if [ -z "$OPTARG" ]; then
						exitError "Invalid option -o requires an argument"
					fi
				
					case "$OPTARG" in
						
						no-strip-toolchain-symbols)
							stripToolchainSymbols="no"
						;;
						
						yes-strip-toolchain-symbols)
							stripToolchainSymbols="yes"
						;;
						
						no-strip-toolchain-docs)
							stripToolchainDocs="no"
						;;
						
						yes-strip-toolchain-docs)
							stripToolchainDocs="yes"
						;;
						
						no-strip-system-symbols)
							stripSystemSymbols="no"
						;;
						
						yes-strip-system-symbols)
							stripSystemSymbols="yes"
						;;
						
						no-strip-system-docs)
							stripSystemDocs="no"
						;;
						
						yes-strip-system-docs)
							stripSystemDocs="yes"
						;;
						
						*)
							exitError "Invalid option -o ${OPTARG}"
						;;
						
					esac
				;;
				
				'?')
					exitError "Invalid option -${OPTARG}"
				;;
				
			esac
		done
		
		shift $((OPTIND - 1))
		if [ $# -ne 0 ]; then
			profiles="$@"
		fi
		
		if [ -z "$distributionVersion" ]; then
			exitError "Please specify a distribution using -d"
		fi
	fi
}

function cleanShell()
{
	set +h
	umask 022
}

function setPathsAndExports()
{
	if [ ! -d "$lfsConfigPath" ]; then
		exitError "Config path $lfsConfigPath does not exist or is not a directory"
	fi
	pushd "$lfsConfigPath">/dev/null
	lfsConfigPath="$(pwd)"
	popd >/dev/null
	
	readonly distributionPath="$lfsConfigPath"/"$distributionVersion"
	if [ ! -d "$distributionPath" ]; then
		exitError "Distribution path $distributionPath does not exist or is not a directory"
	fi
	
	readonly mirrorsPath="$distributionPath"/mirrors
	if [ ! -d "$mirrorsPath" ]; then
		exitError "Mirrors path $mirrorsPath does not exist or is not a directory"
	fi
	
	readonly profilesPath="$distributionPath"/profiles
	if [ ! -d "$profilesPath" ]; then
		exitError "Profiles path $profilesPath does not exist or is not a directory"
	fi
	
	readonly keyringsPath="$distributionPath"/keyrings
	if [ ! -d "$keyringsPath" ]; then
		exitError "Keyrings path $keyringsPath does not exist or is not a directory"
	fi
	
	readonly signaturesPath="$distributionPath"/signatures
	if [ ! -d "$signaturesPath" ]; then
		exitError "Signatures path $signaturesPath does not exist or is not a directory"
	fi
	
	readonly recipesPath="$distributionPath"/recipes
	if [ ! -d "$recipesPath" ]; then
		exitError "Recipes path $recipesPath does not exist or is not a directory"
	fi
	
	readonly exportedFunctions="$distributionPath"/exported-functions
	if [ ! -f "$exportedFunctions" ]; then
		exitError "exported-functions $exportedFunctions does not exist or is not a file"
	fi
	
	if [ ! -d "$lfsPath" ]; then
		mkdir -m 0755 -p "$lfsPath"
	fi
	pushd "$lfsPath">/dev/null
	lfsPath="$(pwd)"
	popd >/dev/null
	
	export LFS="$lfsPath"/root
	export LFS_TOOLS="$toolsFolderName"
	
	readonly logsPath="$lfsPath"/logs
	readonly sourcesPath="$LFS"/sources
	readonly toolsPath="$LFS"/"$LFS_TOOLS"
	
	export LC_ALL=POSIX
	export LFS_TGT="$(uname -m)"-lfs-linux-gnu
	export PATH=/"$LFS_TOOLS"/bin:/bin:/usr/bin
	
	if [ -f /proc/cpuinfo ]; then
		local -ir numberOfCpus="$(awk '$1 ~ /processor/ { print $3}' /proc/cpuinfo | sort --unique --reverse | head -n 1)"
	else
		local -ir numberOfCpus=0
	fi
	
	if [ $numberOfCpus -ne 0 ]; then
		export MAKEFLAGS="-j $numberOfCpus"
	fi
}

function installDebianDependencies()
{
	#sudo apt-get --quiet --quiet update
	sudo apt-get --quiet --quiet install bash binutils bison bzip2 coreutils diffutils findutils gawk gcc g++ libc-bin grep gzip m4 make patch perl-base sed tar texinfo xz-utils
}

function verifyHostSystemRequirements()
{
	# Check against http://www.linuxfromscratch.org/lfs/view/development/prologue/hostreqs.html
	local -r original_LC_ALL="$LC_ALL"
	export LC_ALL=C
	
	# Must be at least 4.2 (so doesn't work on Mac OS X)
	bash --version | head -n 1 | cut -d" " -f2-4
	
	echo "/bin/sh -> $(readlink -f /bin/sh)"
	
	echo -n "Binutils: "; ld --version | head -n 1 | cut -d" " -f3-
	
	bison --version | head -n 1
	
	if [ -e /usr/bin/yacc ]; then
		echo "/usr/bin/yacc -> $(readlink -f /usr/bin/yacc)"
	else
		echo "yacc not found"
	fi

	bzip2 --version 2>&1 </dev/null | head -n 1 | cut -d" " -f1,6-
	
	echo -n "Coreutils: "; chown --version | head -n 1 | cut -d")" -f2
	
	diff --version | head -n 1
	
	find --version | head -n 1
	
	gawk --version | head -n 1
	
	if [ -e /usr/bin/awk ]; then
		echo "/usr/bin/awk -> `readlink -f /usr/bin/awk`"
	else
		echo "awk not found"
	fi

	gcc --version | head -n 1
	
	g++ --version | head -n 1
	
	ldd --version | head -n 1 | cut -d" " -f2-  # glibc version
	
	grep --version | head -n 1
	
	gzip --version | head -n 1
	
	cat /proc/version
	
	m4 --version | head -n 1
	
	make --version | head -n 1
	
	patch --version | head -n 1
	
	echo Perl `perl -V:version`
	
	sed --version | head -n 1
	
	tar --version | head -n 1
	
	echo "Texinfo: `makeinfo --version | head -n1`"
	
	xz --version | head -n 1
	
	sudo -V | head -n 1
	
	# Test C++ compiler
	echo 'main(){}' > dummy.c && g++ -o dummy dummy.c
	if [ -x dummy ]; then
		echo "g++ compilation OK"
	else
		echo "g++ compilation failed"
	fi
	rm -f dummy.c dummy
	
	unset LC_ALL
	if [ ! -z "$original_LC_ALL" ]; then
		export LC_ALL="$original_LC_ALL"
	fi
}

function sourceMirrors()
{
	pushd "$mirrorsPath" >/dev/null
		
		sourceMirror "$mirrors"
		
	popd >/dev/null
}

function sourceProfiles()
{
	pushd "$profilesPath" >/dev/null
		
		LFS_PHASE="toolchain1" sourceProfile "$toolchain1Profile"
		
		LFS_PHASE="toolchain2" sourceProfile "$toolchain2Profile"
		
		for profile in $profiles
		do
			LFS_PHASE="system" sourceProfile "$profile"
		done
		
	popd >/dev/null
	
}

function createSkeletonFolderStructure()
{
	mkdir -m 0755 -p "$LFS"
	
	# Logs
	mkdir -m 0755 -p "$logsPath"
	rm -rf "$logsPath"/*
	chmod a+wt "$logsPath"
	
	# Sources
	mkdir -m 0755 -p "$sourcesPath"
	chmod a+wt "$sourcesPath"
	
	# Tools
	sudo mkdir -m 0755 -p "$toolsPath"
	# symlink, say, /mnt/lfs/tools as /tools
	sudo rm -rf /"$LFS_TOOLS"
	sudo ln --symbolic "$toolsPath" /
	
	sudo chown -R $UID:$UID "$sourcesPath"
	sudo chown -R $UID:$UID "$toolsPath"
}

function verifyHash()
{
	local -r toPath="$1"
	local -r fileName="$2"
	local -r hashProgram="$3"
	local -r hashValue="$4"
	
	local -r logFile="$logsPath"/downloads/"$fileName".$hashProgram.log
	pushd "$toPath">/dev/null
		$hashProgram --check --quiet --warn --strict <<<"${hashValue}  ${fileName}" 2>&1 1>"$logFile"
	popd >/dev/null
}

function verifySignature()
{
	local -r toPath="$1"
	local -r fileName="$2"
	local -r keyring="$3"
	
	case "$keyring" in
		
		secring.gpg|trustdb.gpg)
			exitError "The keyring $keyring is not a public keyring"
		;;
		
	esac
	
	if [ "${keyring##*.}" != "gpg" ]; then
		exitError "Keyrings must be gpg - $keyring is not"
	fi
	
	if [ ! -f "$keyring" ]; then
		exitError "$keyringsPath"/"$keyring does not exist"
	fi
	
	gpg --no-options --no-greeting --no-permission-warning --no-random-seed-file --ignore-time-conflict --quiet --batch --no-default-keyring \
	--homedir "$keyringsPath" \
	--secret-keyring secring.gpg \
	--trustdb-name trustdb.gpg
	--primary-keyring pubring.gpg \
	--keyring "$keyring" \
	--verify "$signaturesPath"/"$fileName".sig "$toPath"/"$fileName" 2>&1 1>$logsPath/downloads/$fileName.sig.log
}

# metalink in the latest curl (7.29.0) and wget (1.15, not released) allows parallel downloading and fail-over and obsoletes mirrors logic
function downloadFileAndCheckHash()
{
	if [ $# -ne 5 ]; then
		exitError "Not exactly 5 arguments"
	fi
	
	local -r downloadName="$1"
	local -r url="$2"
	local -r toPath="$3"
	local -r fileName="$4"
	local -r hashes="$5"
	local -i exitCode
	
	mkdir -m 0755 -p "$logsPath"/downloads
	
	if [ -f "$toPath"/"$fileName" ]; then
		progressMessage "Using downloaded $downloadName $url at $toPath/$fileName"
		progressMessageSucceeded
	else
		progressMessage "Downloading $downloadName $url to $toPath/$fileName"
		
		rm -rf "$toPath"/"$fileName"
		
		# We re-load the config after specifying our options
		touch "$HOME"/.curlrc
		
		local -r referer="$(dirname "$url")/"
		
		set +e
		curl --fail --silent --show-error \
		--user-agent "lfs/${distributionVersion}" --referer "${referer};auto" \
		--location --max-redirs 5 --retry 20 \
		--tlsv1 --anyauth --netrc-optional \
		--compressed --remote-time \
		--dump-header "$logsPath"/downloads/"$fileName".headers.log \
		--trace-time --trace-ascii "$logsPath"/downloads/"$fileName".trace-ascii.log \
		--stderr "$logsPath"/downloads/"$fileName".stderr.log \
		--write-out '%{url_effective}\t%{http_code}\t%{ssl_verify_result}\t%{http_connect}\t%{time_total}\t%{size_download}\t%{speed_download}\t%{num_redirects}\n' \
		--config "$HOME"/.curlrc \
		--url "$url" --output "$toPath"/"$fileName" \
		1>"$logsPath"/downloads/"$fileName".stdout.log
		exitCode=$?
		set -e
		if [ $exitCode -ne 0 ]; then
			progressMessageFailed "download failed, check logs $logsPath/downloads/$fileName.*.log"
		else
			progressMessageSucceeded
		fi
	fi
	
	progressMessage "Checking $downloadName $url hashes of $toPath/$fileName"
	
	local hashNameAndValue
	local hashName
	local hashValue
	local hashProgram
	local -i hasHash=1
	for hashNameAndValue in ${hashes//,/ }
	do
		IFS=':' read -r -d$'\n' hashName hashValue <<<"$hashNameAndValue"
		case "$hashName" in
			
			MD5)
				hashProgram=md5sum
				hasHash=0
			;;
			
			SHA1)
				hashProgram=sha1sum
				hasHash=0
			;;
			
			SHA224)
				hashProgram=sha224sum
				hasHash=0
			;;
			
			SHA256)
				hashProgram=sha256sum
				hasHash=0
			;;
			
			SHA384)
				hashProgram=sha384sum
				hasHash=0
			;;
			
			SHA512)
				hashProgram=sha512sum
				hasHash=0
			;;
			
			SIG)
				hashProgram=gpg
				hasHash=0
				if ! verifySignature "$toPath" "$fileName" "$hashValue"; then
					progressMessageFailed "signature does not match, check logs $logsPath/downloads/$fileName.sig.log"
				fi
			;;
			
			*)
				exitError "Unsupported hash algorithm $hashName for $toPath/$fileName"
			;;
			
		esac
		
		if [ "$hashProgram" != gpg ]; then
			if ! verifyHash "$toPath" "$fileName" "$hashProgram" "$hashValue"; then
				progressMessageFailed "hash digest (sum) does not match, check logs $logsPath/downloads/$fileName.$hashProgram.log"
			fi
		fi
	done
	
	if [ $hasHash -ne 0 ]; then
		progressMessageFailed "no hash algorithms specified"
	fi
	
	progressMessageSucceeded
}

function downloadKeyrings()
{
	local -i keyringNumber
	for keyringNumber in ${!keyrings_Url[@]}
	do
		downloadFileAndCheckHash "keyring" "${keyrings_Url[$keyringNumber]}" "$keyringsPath" "${keyrings_FileName[$keyringNumber]}" "${keyrings_Hashes[$keyringNumber]}"
	done
}

function downloadSources()
{
	local -r localDistributionVersionKey="$(printDistributionVersionKey "$distributionVersion")"
	local key
	local -i patchNumber
	for key in ${installPhase_toolchain1["${localDistributionVersionKey}"]} ${installPhase_toolchain2["${localDistributionVersionKey}"]} ${installPhase_system["${localDistributionVersionKey}"]}
	do
		downloadFileAndCheckHash "source package" "${sourcePackages_Url["${key}"]}" "$sourcesPath" "${sourcePackages_FileName["${key}"]}" "${sourcePackages_Hashes["${key}"]}"
		
		for patchNumber in ${sourcePackages_Patches["${key}"]}
		do
			downloadFileAndCheckHash "patch" "${patches_Url[$patchNumber]}" "$patchesPath" "${patches_FileName[$patchNumber]}" "${patches_Hashes[$patchNumber]}"
		done
	done
}

function installPackage()
{
	local -r phase="$1"
	local -r key="$2"
	shift 2
	
	ourSourcePackageName="${sourcePackages_SourcePackageName["${key}"]}"
	if [ -z "$ourSourcePackageName" ]; then
		progressMessageFailed "No known package definition for key $key"
	fi
	
	progressMessage "Installing phase $phase source package $ourSourcePackageName version $ourVersion"
	
	ourVersion="${sourcePackages_Version["${key}"]}"
	ourCompression="${sourcePackages_Compression["${key}"]}"
	ourFileName="${sourcePackages_FileName["${key}"]}"
	ourExtractedTarballFolder="${sourcePackages_ExtractedTarballFolder["${key}"]}"
	ourPatchFileName="${patches_FileName["${key}"]}"
	
	local -i exitCode
	
	# Use an override (versioned) installer, otherwise the default
	local -r installer_versioned=installPackage_${phase}_${ourSourcePackageName}_${ourVersion}
	local -r installer_unversioned=installPackage_${phase}_${ourSourcePackageName}
	if type "$installer_versioned" &>/dev/null; then
		local -r installer="$installer_versioned"
	elif type "$installer_unversioned" &>/dev/null; then
		local -r installer="$installer_unversioned"
	else
		progressMessageFailed "No installer $installer_versioned or $installer_unversioned defined"
	fi
	
	pushd "$sourcesPath" >/dev/null
		
		tarExtract "$ourFileName" "$ourExtractedTarballFolder" $ourCompression
		
		local -r outLogFile="$logsPath"/"$installer".stdout.log
		local -r errorLogFile="$logsPath"/"$installer".stderr.log
		pushd "$ourExtractedTarballFolder" >/dev/null
			
			exec 3>&1
			exec 1>"$outLogFile"
			exec 4>&2
			exec 2>"$errorLogFile"
		
			set +e
			$installer "$@"
			exitCode=$?
			set -e
		
			exec 2>&4
			exec 4>&-
			exec 1>&3
			exec 3>&-
			
			if [ $exitCode -ne 0 ]; then
				progressMessageFailed "$installer failed with exitCode $exitCode, check logs $outLogFile and $errorLogFile"
			fi
		
		popd >/dev/null
		rm -rf "$ourExtractedTarballFolder"
		
	popd >/dev/null
	
	progressMessageSucceeded
}

function installPackages()
{
	local -r phase="$1"
	
	local -r localDistributionVersionKey="$(printDistributionVersionKey "$distributionVersion")"
	case "$phase" in
		
		toolchain1)
			local -r packageKeys="${installPhase_toolchain1["${localDistributionVersionKey}"]}"
		;;
		
		toolchain2)
			local -r packageKeys="${installPhase_toolchain2["${localDistributionVersionKey}"]}"
		;;
		
		system)
			local -r packageKeys="${installPhase_system["${localDistributionVersionKey}"]}"
		;;
		
		*)
			exitError "Unknown phase $phase"
		;;
		
	esac
	
	local key
	for key in $packageKeys
	do
		installPackage "$phase" "$key"
	done
}

function stripToolchainSymbols()
{
	if [ "$stripToolchainSymbols" = "yes" ]; then
		strip --strip-debug /"$LFS_TOOLS"/lib/*
		strip --strip-unneeded /"$LFS_TOOLS"/{,s}bin/*
	fi
}

function stripToolchainDocs
{
	if [ "$stripToolchainDocs" = "yes" ]; then
		rm -rf /"$LFS_TOOLS"/{,share}/{info,man,doc}
	fi
}

function main()
{
	setDebugging
	findOurNameAndPath
	parseCommandLine "$@"
	
	setDebugging
	cleanShell
	setPathsAndExports
	
	if [ -d /etc/dpkg/origins ]; then
		installDebianDependencies
	fi
	verifyHostSystemRequirements >/dev/null 2>/dev/null
	
	createSkeletonFolderStructure
	
	source "$exportedFunctions"
	sourceMirrors
	sourceProfiles
	
	downloadKeyrings
	downloadSources
	
	installPackages toolchain1
	installPackages toolchain2
	stripToolchainSymbols
	stripToolchainDocs
}

main "$@"
