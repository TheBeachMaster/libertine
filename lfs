#!/bin/bash -
set +o allexport -o braceexpand +o emacs -o errexit +o errtrace +o functrace +o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword +o monitor +o noclobber +o noexec +o noglob +o nolog +o notify +o nounset +o onecmd +o physical +o pipefail +o posix +o verbose +o vi +o xtrace;unset CDPATH;umask 022

function ensureWhichInstalled()
{
	set +e
	which
	local -ir exitCode=$?
	set -e
	if [ $exitCode = 127 ]; then
		exitError "Program which does not exist on path $PATH"
	fi
}

declare -a trapHandlers=()

function runOnTrap()
{
	local trapHandler
	for trapHandler in ${trapHandlers[@]}
	do
		$trapHandler
	done
}

function addNextTrapHandler()
{
	local trapHandler="$1"
	trap runOnTrap 0 HUP INT QUIT ILL ABRT FPE SEGV PIPE TERM
	trapHandlers[${#trapHandlers[*]}]="$trapHandler"
}

function removeLastTrapHandler()
{
	unset trapHandlers[$((${#trapHandlers[*]}-1))]
}

declare -a filesToRemoveOnExit=()

function removeFilesOnExit()
{
	local -i fileIndex
	for fileIndex in  in ${!filesToRemoveOnExit[@]}
	do
		rm -rf -- "${filesToRemoveOnExit[$fileIndex]}"
	done
}

function addFileToRemoveOnExit()
{
	local -r fileToRemove="$1"
	filesToRemoveOnExit[${#filesToRemoveOnExit[*]}]="$fileToRemove"
}

function temporaryFileToRemoveOnExit()
{
	local -r fileToRemove="$(mktemp)"
	addFileToRemoveOnExit "$fileToRemove"
	echo "$fileToRemove"
}

function temporaryFolderToRemoveOnExit()
{
	local -r fileToRemove="$(mktemp --directory)"
	addFileToRemoveOnExit "$fileToRemove"
	echo "$fileToRemove"
}

function essentialProgramCheck()
{
	# This nasty hack exists because source'd files override the set -xxxx options!
	set -e
	
	local program
	for program in $@
	do
		if ! which "$program" 1>/dev/null 2>/dev/null; then
			warning "Program $program does not exist on path $PATH"
			return 100
		fi
	done
}

function verifyDependency()
{
	if [ $# -lt 2 ]; then
		exitError "Needs at least 2 arguments"
	fi
	if [ $# -gt 3 ]; then
		exitError "Needs no more than 3 arguments"
	fi
	
	local -r sourcePackageName="$1"
	
	local version
	read -r -d$'\n' version
	
	# May be incomplete, eg part of the left-hand regex
	# eg 4.2.25(1)-release might be 4.2
	local -r minimumVersion="$2"
	
	# 0 is equal, =
	# 1 is greater than, >
	# 2 is less than, <
	set +e
	compareVersions "$version" "$minimumVersion"
	local -i comparison=$?
	set -e
	if [ $comparison -eq 2 ]; then
		warning "Dependency $sourcePackageName has a version, $version, less than the minimum known to work, $minimumVersion"
	fi
	
	if [ $# -eq 3 ]; then
		local -r maximumVersion="$3"
		
		set +e
		compareVersions "$version" "$maximumVersion"
		local -i comparison=$?
		set -e
		if [ $comparison -eq 1 ]; then
			warning "Dependency $sourcePackageName has a version, $version, greater than the maximum known to work, $maximumVersion"
		fi
	fi
}

# Derived from http://stackoverflow.com/questions/4023830/bash-how-compare-two-strings-in-version-format
function compareVersions()
{
	if [[ $1 == $2 ]]; then
		return 0
	fi
	
	local IFS=.
	local i ver1=($1) ver2=($2)
	
	# fill empty fields in ver1 with zeros
	for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
	do
		ver1[i]=0
	done
	
	for ((i=0; i<${#ver1[@]}; i++))
	do
		if [[ -z ${ver2[i]} ]]; then
			# fill empty fields in ver2 with zeros
			ver2[i]=0
		fi
		if ((10#${ver1[i]} > 10#${ver2[i]})); then
			return 1
		fi
		if ((10#${ver1[i]} < 10#${ver2[i]})); then
			return 2
		fi
	done
	
	return 0
}

# The purpose of these functions is to provide internal implementations of logic we can't be 100%
# sure of exists in the environment or is implemented as we would like for critical pieces of code.
# Such a critical piece is code executed before and during command line arg parsing (eg exitError)
# They will usually be MUCH slower than their external equivalents
function purebash_dirname()
{
	echo "${1%/*}"
}

function purebash_basename()
{
	echo "${1##*/}"
}

function exitError()
{
	local -r error="$1"
	echo "$ourName: $error" 1>&2
	exit 1
}

function warning()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	echo "$ourName: WARNING: $1" 1>&2
}

function setDebugging()
{
	# is set -x on?
	if [[ "$-" == *x* ]]; then
		export LFS_BASH_DEBUGGING="yes"
	fi
	if [ "$LFS_BASH_DEBUGGING" = "yes" ];then
		set -x
	fi
}

function findOurNameAndPath()
{
	readonly ourName="$(purebash_basename "$0")"
	pushd "$(purebash_dirname "$0")" >/dev/null
	readonly crudeOurPath="$(pwd)"
	popd >/dev/null
}

function executeWithCleanEnvironment()
{
	essentialProgramCheck env
	exec env -i HOME="$HOME" TERM="$TERM" PS1='\u:\w\$ ' LFS_BASH_DEBUGGING="$LFS_BASH_DEBUGGING" LFS_CLEAN_ENVIRONMENT='yes' bash --noprofile --norc -- "$crudeOurPath"/"$ourName" $@
}

function exitHelp()
{
	echo -n -E "Usage: ${ourName} -h
Usage: ${ourName} -d distribution [-l lfsPath] [-c lfsConfigPath] [-t toolsFolderName] [-m mirrors] [-1 toolchain1Profile] [-2 toolchain2Profile] [-o option] -- [profiles ...]

Profiles
[profiles ...] lists one or more system profiles to create. These are snippets of simplified bash
script, that install and build from source what would be called packages on other systems.

If no profile is specified, then the baseline 'lfs' profile is used.

profiles are executed in the order listed. Internally, a profile may reference (source)
another profile it depends on. This is the equivalent of package management on other
systems. A set of profiles is intended to be version-controlled using a source control system
such as git and so do not declare explicit version dependencies.

The profiles 'toolchain1' and 'toolchain2' are special. Implementors of profiles can assume
that these profiles are always sourced. It is an error to specify them in the list of profiles.

A profile does not have to just install packages.

Profiles may be suffixed with [distribution] to target a particular distribution.

Defaults
    distribution       ${distribution}
    lfsPath            ${lfsPath}
    lfsConfigPath      ${lfsConfigPath}
    toolsFolderName    ${toolsFolderName}
    mirrors            ${mirrors}
    toolchain1Profile  ${toolchain1Profile}
    toolchain2Profile  ${toolchain2Profile}
    option             See below
    profiles           ${profiles}

A mirror defines mirror URLs. If a mirror is 'timezone', then timezone settings used to determine the actual mirrors.
If Etc/UTC or something similar is the timezone, then the 'language' mirrors are used. These use the LC_CTYPE,
LANG and LANGUAGE environment variables in order. The 'global' mirror can be specified to override this. A list of mirrors
is in <lfsConfigPath>/mirrors . Conversions from timezone and language are controlled using <lfsConfigPath>/timezones-to-mirrors.map
and <lfsConfigPath>/languages-to-mirrors.map respectively. Note that some mirrors, eg for the UK, are incomplete and source
the global mirrors first to provide defaults. mirrors may be symlinks.

At this time we don't support the metalink (.meta4) protocol for mirrors (as it requires additional
runtime dependencies).

Options
For options, prefix with either 'yes-' to turn it on
or 'no-' to turn it off. For example, to turn on 'strip-system-docs' :-

    ${ourName} -o yes-strip-system-docs

-o may be repeated as necessary. Options are evaluated in left-to-right order.
Last setting wins.

Options are as follows:-     Default
    skip-toolchain1          ${skipToolchain1}
    skip-toolchain2          ${skipToolchain2}
    strip-toolchain-symbols  ${stripToolchainSymbols}
    strip-toolchain-docs     ${stripToolchainDocs}
    strip-system-symbols     ${stripSystemSymbols}
    strip-system-docs        ${stripSystemDocs}
" 1>&2
	exit $1
}

function parseCommandLine()
{
	# Defaults
	distributionVersion=""
	lfsPath="/var/tmp/lfs"
	lfsConfigPath="${crudeOurPath}/config"
	toolsFolderName=tools
	mirrors="timezone"
	toolchain1Profile=toolchain1
	toolchain2Profile=toolchain2
	skipToolchain1="no"
	skipToolchain2="no"
	stripToolchainSymbols="yes"
	stripToolchainDocs="no"
	stripSystemSymbols="yes"
	stripSystemDocs="no"
	profiles="system"
	
	if [ "$LFS_CLEAN_ENVIRONMENT" != "yes" ]; then
		executeWithCleanEnvironment "$@"
	else
		local OPTERR=1
		local OPTIND=1
		local OPTARG
		local option
		while getopts :hl:d:m:1:2:o: option
		do
			case "$option" in
				
				h)
					exitHelp 2
				;;
				
				d)
					distributionVersion="$OPTARG"
				;;
				
				l)
					lfsPath="$OPTARG"
				;;
				
				c)
					lfsConfigPath="$OPTARG"
				;;
				
				t)
					toolsFolderName="$OPTARG"
				;;
				
				m)
					mirrors="$OPTARG"
				;;
				
				1)
					toolchain1Profile="$OPTARG"
				;;
				
				2)
					toolchain2Profile="$OPTARG"
				;;
				
				o)
					if [ -z "$OPTARG" ]; then
						exitError "Invalid option -o requires an argument"
					fi
				
					case "$OPTARG" in
						
						no-skip-toolchain1)
							skipToolchain1="no"
						;;
						
						yes-skip-toolchain1)
							skipToolchain1="yes"
						;;
						
						no-skip-toolchain2)
							skipToolchain2="no"
						;;
						
						yes-skip-toolchain2)
							skipToolchain2="yes"
						;;
						
						no-strip-toolchain-symbols)
							stripToolchainSymbols="no"
						;;
						
						yes-strip-toolchain-symbols)
							stripToolchainSymbols="yes"
						;;
						
						no-strip-toolchain-docs)
							stripToolchainDocs="no"
						;;
						
						yes-strip-toolchain-docs)
							stripToolchainDocs="yes"
						;;
						
						no-strip-system-symbols)
							stripSystemSymbols="no"
						;;
						
						yes-strip-system-symbols)
							stripSystemSymbols="yes"
						;;
						
						no-strip-system-docs)
							stripSystemDocs="no"
						;;
						
						yes-strip-system-docs)
							stripSystemDocs="yes"
						;;
						
						*)
							exitError "Invalid option -o ${OPTARG}"
						;;
						
					esac
				;;
				
				'?')
					exitError "Invalid option -${OPTARG}"
				;;
				
			esac
		done
		
		shift $((OPTIND - 1))
		if [ $# -ne 0 ]; then
			profiles="$@"
		fi
		
		if [ -z "$distributionVersion" ]; then
			exitError "Please specify a distribution using -d"
		fi
	fi
}

function setPathsAndExports()
{
	essentialProgramCheck mkdir uname awk sort
	
	if [ ! -d "$lfsConfigPath" ]; then
		exitError "Config path $lfsConfigPath does not exist or is not a directory"
	fi
	pushd "$lfsConfigPath">/dev/null
	lfsConfigPath="$(pwd)"
	popd >/dev/null
	
	readonly distributionPath="$lfsConfigPath"/"$distributionVersion"
	if [ ! -d "$distributionPath" ]; then
		exitError "distribution path $distributionPath does not exist or is not a directory"
	fi
	
	readonly certificateAuthoritiesPath="$distributionPath"/certificate-authorities
	if [ ! -d "$certificateAuthoritiesPath" ]; then
		exitError "certificate-authorities path $certificateAuthoritiesPath does not exist or is not a directory"
	fi
	
	readonly mirrorsPath="$distributionPath"/mirrors
	if [ ! -d "$mirrorsPath" ]; then
		exitError "Mirrors path $mirrorsPath does not exist or is not a directory"
	fi
	
	readonly profilesPath="$distributionPath"/profiles
	if [ ! -d "$profilesPath" ]; then
		exitError "Profiles path $profilesPath does not exist or is not a directory"
	fi
	
	readonly keyringsPath="$distributionPath"/keyrings
	if [ ! -d "$keyringsPath" ]; then
		exitError "Keyrings path $keyringsPath does not exist or is not a directory"
	fi
	
	readonly keysPath="$distributionPath"/keys
	if [ ! -d "$keysPath" ]; then
		exitError "Keys path $keysPath does not exist or is not a directory"
	fi
	
	readonly signaturesPath="$distributionPath"/signatures
	if [ ! -d "$signaturesPath" ]; then
		exitError "Signatures path $signaturesPath does not exist or is not a directory"
	fi
	
	readonly recipesPath="$distributionPath"/recipes
	if [ ! -d "$recipesPath" ]; then
		exitError "Recipes path $recipesPath does not exist or is not a directory"
	fi
	
	readonly exportedFunctions="$distributionPath"/exported-functions
	if [ ! -f "$exportedFunctions" ]; then
		exitError "exported-functions $exportedFunctions does not exist or is not a file"
	fi
	
	if [ ! -d "$lfsPath" ]; then
		mkdir -m 0755 -p "$lfsPath"
	fi
	pushd "$lfsPath">/dev/null
	lfsPath="$(pwd)"
	popd >/dev/null
	
	export LFS="$lfsPath"/root
	export LFS_TOOLS="$toolsFolderName"
	
	readonly logsPath="$lfsPath"/logs
	readonly sourcesPath="$LFS"/sources
	readonly toolsPath="$LFS"/"$LFS_TOOLS"
	
	export LC_ALL=POSIX
	export LFS_TGT="$(uname -m)"-lfs-linux-gnu
	export PATH=/"$LFS_TOOLS"/bin:/bin:/usr/bin
	
	if [ -f /proc/cpuinfo ]; then
		local highestCpu
		read -r -d $'\n' highestCpu < <(awk '$1 ~ /processor/ { print $3 }' /proc/cpuinfo | sort --unique --reverse --numeric-sort)
		local -ir highestCpuZeroBased=$highestCpu
	else
		local -ir highestCpuZeroBased=0
	fi
	
	if [ $highestCpuZeroBased -ne 0 ]; then
		export MAKEFLAGS="-j $((highestCpuZeroBased+1))"
	fi
}

function registerDebianPackage()
{
	printf '%s' "$@" >>"$LFS_CURRENT_DEBIAN_PACKAGES_TEMP"
}

function verifyHostSystemRequirements()
{
	# Check against http://www.linuxfromscratch.org/lfs/view/development/prologue/hostreqs.html
	
	readonly dependencyChecks="$distributionPath"/dependency-checks
	if [ ! -d "$dependencyChecks" ]; then
		exitError "dependency-checks $dependencyChecks does not exist or is not a directory"
	fi
	
	local debianPackagesToInstallForDependencies=""
	
	pushd "$dependencyChecks" >/dev/null
		local dependencyCheck
		local -i exitCode
		for dependencyCheck in *.dependency-check
		do
			# Used to communicate with subshell, as we can't pass variables back (and we output stdout / stderr to the console)
			LFS_CURRENT_DEBIAN_PACKAGES_TEMP="$(temporaryFileToRemoveOnExit)"
			# done as subshell to overcome the fact that commands are executing outside of a function
			if ! (source "$dependencyCheck"); then
				if [ -z "$debianPackagesToInstallForDependencies" ]; then
					debianPackagesToInstallForDependencies="$(head -n 1 "$LFS_CURRENT_DEBIAN_PACKAGES_TEMP")"
				else
					debianPackagesToInstallForDependencies="$debianPackagesToInstallForDependencies $(head -n 1 "$LFS_CURRENT_DEBIAN_PACKAGES_TEMP")"
				fi
			fi
		done
	popd >/dev/null

	if [ ! -z "$debianPackagesToInstallForDependencies" ]; then
		if which apt-get 1>/dev/null 2>/dev/null; then
			sudo -p "Password needed to attempt to install dependencies ($debianPackagesToInstallForDependencies): " apt-get --quiet --quiet --yes update
			sudo -p "Password needed to attempt to install dependencies ($debianPackagesToInstallForDependencies): " apt-get --quiet --quiet --yes install $debianPackagesToInstallForDependencies
		fi
	fi
}

function sourceMirrors()
{
	pushd "$mirrorsPath" >/dev/null
		
		sourceMirror "$mirrors"
		
	popd >/dev/null
}

function sourceProfiles()
{
	pushd "$profilesPath" >/dev/null
		
		LFS_PHASE="toolchain1" sourceProfile "$toolchain1Profile"
		
		LFS_PHASE="toolchain2" sourceProfile "$toolchain2Profile"
		
		for profile in $profiles
		do
			LFS_PHASE="system" sourceProfile "$profile"
		done
		
	popd >/dev/null
}

function createSkeletonFolderStructure()
{
	mkdir -m 0755 -p "$LFS"
	
	# Logs
	mkdir -m 0755 -p "$logsPath"
	rm -rf "$logsPath"/*
	mkdir -m 0755 -p "$logsPath"/downloads
	mkdir -m 0755 -p "$logsPath"/toolchain1
	mkdir -m 0755 -p "$logsPath"/toolchain2
	mkdir -m 0755 -p "$logsPath"/system
	chmod a+wt "$logsPath"
	
	# Sources
	mkdir -m 0755 -p "$sourcesPath"
	chmod a+wt "$sourcesPath"
	
	# Tools
	sudo mkdir -m 0755 -p "$toolsPath"
	# symlink, say, /mnt/lfs/tools as /tools
	sudo rm -rf /"$LFS_TOOLS"
	sudo ln --symbolic "$toolsPath" /
	
	sudo chown -R $UID:$UID "$sourcesPath"
	sudo chown -R $UID:$UID "$toolsPath"
}

function rehashCertificateAuthorities()
{
	# Bottom of http://www.sks-keyservers.net/overview-of-pools.php :  https://sks-keyservers.net/sks-keyservers.netCA.pem
	# http://people.spodhuis.org/phil.pennock/pgp-keyservers  is also a reference
	
	if ! which openssl 1>/dev/null 2>/dev/null; then
		warning "openssl isn't present, so we can't rehash certificate authorities (only matters if curl is linked to openssl and you have changed the certificate authorities)"
		return 0
	fi
	
	pushd "$certificateAuthoritiesPath" >/dev/null
		local values
		local hashValue
		local sha1ColonSeparated
		local hashIndex
		local hashFile
		local hashValue2
		local sha1ColonSeparated2
		for certificateAuthority in *.pem
		do
			values="$(openssl x509 -subject_hash -fingerprint -noout -in "$certificateAuthority" | awk 'BEGIN { FS="\n"; RS=""; OFS="\t"} {print $1,substr($2,18)}')"
			IFS=$'\t' read -r -d $'\n' hashValue sha1ColonSeparated <<<"$values"
			hashIndex=0
			while :
			do
				hashFile="$hashValue"."$hashIndex"
				
				if [ -L "$hashFile" ]; then
					# It's possible this is a symlink to the same (or similar) file)
					values="$(openssl x509 -subject_hash -fingerprint -noout -in "$certificateAuthority" | awk 'BEGIN { FS="\n"; RS=""; OFS="\t"} {print $1,substr($2,18)}')"
					IFS=$'\t' read -r -d $'\n' hashValue2 sha1ColonSeparated2 <<<"$values"
					if [ "$sha1ColonSeparated2" = "$sha1ColonSeparated" ]; then
						break
					fi
					hashIndex=$((hashIndex+1))
					continue
				fi
				
				if [ -e "$hashFile" ]; then
					rm -rf -- "$hashFile"
				fi
				
				ln --symbolic "$certificateAuthority" "$hashFile"
				break
			done
		done
	popd >/dev/null
}

function verifyHash()
{
	local -r toPath="$1"
	local -r fileName="$2"
	local -r hashProgram="$3"
	local -r hashValue="$4"
	
	local -r logFile="$logsPath"/downloads/"$fileName".$hashProgram.log
	pushd "$toPath">/dev/null
		$hashProgram --check --strict <<<"${hashValue}  ${fileName}" 1>"$logFile" 2>&1
		local -ir exitCode=$?
	popd >/dev/null
	
	return $exitCode
}

function verifyKeyringSignature()
{
	local -r toPath="$1"
	local -r fileName="$2"
	local -r keyring="$3"
	local -r signatureFileName="$4"
	local -r isCompressed="$5"
	
	if [ "$isCompressed" = "no" ]; then
		local -r logFileName="$logsPath"/downloads/"$fileName".keyfile.log
	else
		local -r logFileName="$logsPath"/downloads/"$fileName".keyfile_uncompressed.log
	fi
	
	case "$keyring" in
		
		secring.gpg|trustdb.gpg)
			exitError "The keyring $keyring is not a public keyring"
		;;
		
	esac
	
	if [ "${keyring##*.}" != "gpg" ]; then
		exitError "Keyrings must be gpg - $keyring is not"
	fi
	
	if [ ! -f "$keyringsPath"/"$keyring" ]; then
		exitError "$keyringsPath"/"$keyring does not exist"
	fi
	
	gpg --no-options --no-greeting --no-permission-warning --no-auto-check-trustdb --no-secmem-warning \
	--no-random-seed-file --ignore-time-conflict \
	--no-verbose --quiet --batch --no-tty --exit-on-status-write-error \
	 --homedir "$keyringsPath" --trustdb-name trustdb.gpg --no-default-keyring --secret-keyring secring.gpg --primary-keyring pubring.gpg --keyring "$keyring" \
	--verify "$signaturesPath"/"$signatureFileName" "$toPath"/"$fileName" </dev/null 1>"$logFileName" 2>&1
	local -ir exitCode=$?
	return $exitCode
}

function verifyKeyFileSignature()
{
	local -r toPath="$1"
	local -r fileName="$2"
	local -r keyFile="$3"
	local -r signatureFileName="$4"
	local -r isCompressed="$5"
	
	if [ ! -f "$keysPath"/"$keyFile" ]; then
		exitError "$keysPath"/"$keyFile does not exist"
	fi
	
	if [ "$isCompressed" = "no" ]; then
		local -r logFileName="$logsPath"/downloads/"$fileName".keyfile.log
	else
		local -r logFileName="$logsPath"/downloads/"$fileName".keyfile_uncompressed.log
	fi
	
	local -r gpgHome="$(temporaryFolderToRemoveOnExit)"
	cp --archive "$keyringsPath"/pubring.gpg  "$keyringsPath"/secring.gpg "$keyringsPath"/trustdb.gpg "$gpgHome"
	
	gpg --no-options --no-greeting --no-permission-warning --no-auto-check-trustdb --no-secmem-warning \
	--no-random-seed-file --ignore-time-conflict \
	--no-verbose --quiet --batch --no-tty --exit-on-status-write-error \
	 --homedir "$gpgHome" --trustdb-name trustdb.gpg --no-default-keyring --secret-keyring secring.gpg --primary-keyring pubring.gpg --keyring pubring.gpg \
	--import "$keysPath"/"$keyFile" </dev/null 1>"$logFileName" 2>&1
	local -i exitCode=$?
	if [ $exitCode -ne 0 ]; then
		return $exitCode
	fi
	
	gpg --no-options --no-greeting --no-permission-warning --no-auto-check-trustdb --no-secmem-warning \
	--no-random-seed-file --ignore-time-conflict \
	--no-verbose --quiet --batch --no-tty --exit-on-status-write-error \
	 --homedir "$gpgHome" --trustdb-name trustdb.gpg --no-default-keyring --secret-keyring secring.gpg --primary-keyring pubring.gpg --keyring pubring.gpg \
	--verify "$signaturesPath"/"$signatureFileName" "$toPath"/"$fileName" </dev/null 1>>"$logFileName" 2>&1
	exitCode=$?
	
	return $exitCode
}

function verifyHkpSignature()
{
	local -r toPath="$1"
	local -r fileName="$2"
	local -r keyId="$3"
	local -r signatureFileName="$4"
	local -r isCompressed="$5"
	
	if [ ! -f "$keysPath"/"$keyId" ]; then
		exitError "$keysPath"/"$keyId does not exist"
	fi
	
	if [ "$isCompressed" = "no" ]; then
		local -r logFileName="$logsPath"/downloads/"$fileName".hkp.log
	else
		local -r logFileName="$logsPath"/downloads/"$fileName".hkp_uncompressed.log
	fi
	
	local -r gpgHome="$(temporaryFolderToRemoveOnExit)"
	cp --archive "$keyringsPath"/pubring.gpg  "$keyringsPath"/secring.gpg "$keyringsPath"/trustdb.gpg "$gpgHome"
	
	gpg --no-options --no-greeting --no-permission-warning --no-auto-check-trustdb --no-secmem-warning \
	--no-random-seed-file --ignore-time-conflict \
	--no-verbose --quiet --batch --no-tty --exit-on-status-write-error \
	 --homedir "$gpgHome" --trustdb-name trustdb.gpg --no-default-keyring --secret-keyring secring.gpg --primary-keyring pubring.gpg --keyring pubring.gpg \
	--import "$keysPath"/"$keyId" </dev/null 1>"$logFileName" 2>&1
	local -i exitCode=$?
	if [ $exitCode -ne 0 ]; then
		return $exitCode
	fi
	
	gpg --no-options --no-greeting --no-permission-warning --no-auto-check-trustdb --no-secmem-warning \
	--no-random-seed-file --ignore-time-conflict \
	--no-verbose --quiet --batch --no-tty --exit-on-status-write-error \
	 --homedir "$gpgHome" --trustdb-name trustdb.gpg --no-default-keyring --secret-keyring secring.gpg --primary-keyring pubring.gpg --keyring pubring.gpg \
	--verify "$signaturesPath"/"$signatureFileName" "$toPath"/"$fileName" </dev/null 1>>"$logFileName" 2>&1
	exitCode=$?
	
	return $exitCode
}

function decompressFileToStdout()
{
	local -r decompressionOption="$1"
	local -r fileToDecompress="$2"
	if [ "$decompressionOption" = "" ]; then
		cat $fileToDecompress
	fi
	
	case "$decompressionOption" in
		gzip|compress)
			gzip --decompress --stdout --no-name --quiet -- "$fileToDecompress"
		;;
		
		bzip2)
			bzip2 --decompress --stdout --quiet -- "$fileToDecompress"
		;;
		
		lzop)
			lzop --decompress --stdout --no-name --quiet -- "$fileToDecompress"
		;;
		
		lzip)
			lzip --decompress --quiet --stdout -- "$fileToDecompress"
		;;
		
		lzma)
			xz --format=lzma --decompress --stdout -- "$fileToDecompress"
		;;
		
		xz)
			xz --decompress --stdout --quiet --quiet -- "$fileToDecompress"
		;;
		
		*)
			exitError "Unknown compression option $decompressionOption"
		;;
	esac
}

# metalink in the latest curl (7.29.0) and wget (1.15, not released) allows parallel downloading and fail-over and obsoletes mirrors logic
function downloadFileAndCheckHash()
{
	if [ $# -ne 7 ]; then
		exitError "Needs 7 arguments"
	fi
	
	local -r downloadName="$1"
	local -r url="$2"
	local -r toPath="$3"
	local -r fileName="$4"
	local -r decompressionOption="$5"
	local -r hashesMayBeEmpty="$6"
	local -r hashes="$7"
	local -i exitCode
	
	mkdir -m 0755 -p "$logsPath"/downloads
	
	if [ -f "$toPath"/"$fileName" ]; then
		progressMessage "Using downloaded $downloadName $url at $toPath/$fileName"
		progressMessageSucceeded
	else
		progressMessage "Downloading $downloadName $url to $toPath/$fileName"
		
		rm -rf "$toPath"/"$fileName"
		
		# We re-load the config after specifying our options
		touch "$HOME"/.curlrc
		
		local -r referer="$(dirname "$url")/"
		
		set +e
		curl --fail --silent --show-error \
		--user-agent "lfs/${distributionVersion}" --referer "${referer};auto" \
		--location --max-redirs 5 --retry 20 \
		--anyauth --netrc-optional --tlsv1 --capath "$certificateAuthoritiesPath" \
		--compressed --remote-time \
		--dump-header "$logsPath"/downloads/"$fileName".headers.log \
		--trace-time --trace-ascii "$logsPath"/downloads/"$fileName".trace-ascii.log \
		--stderr "$logsPath"/downloads/"$fileName".stderr.log \
		--write-out '%{url_effective}\t%{http_code}\t%{ssl_verify_result}\t%{http_connect}\t%{time_total}\t%{size_download}\t%{speed_download}\t%{num_redirects}\n' \
		--config "$HOME"/.curlrc \
		--url "$url" --output "$toPath"/"$fileName" \
		1>"$logsPath"/downloads/"$fileName".stdout.log
		exitCode=$?
		set -e
		if [ $exitCode -ne 0 ]; then
			progressMessageFailed "download $downloadName failed, check logs $logsPath/downloads/$fileName.*.log"
		else
			progressMessageSucceeded
		fi
	fi
	
	if [ "$hashesMayBeEmpty" = "yes" ]; then
		if [ ${#hashes} -eq 0 ]; then
			return 0
		fi
	fi
	
	progressMessage "Verifying $downloadName $url hashes of $toPath/$fileName"
	
	local hashNameAndValue
	local hashName
	local hashValue
	local hashSignatureFileName
	local hashProgram
	local -i hasHash=1
	local progressMessage
	local signatureFileName
	local temporaryFolder
	for hashNameAndValue in ${hashes}
	do
		IFS=':' read -r -d$'\n' hashName hashValue hashSignatureFileName <<<"$hashNameAndValue"
		case "$hashName" in
			
			MD5|SHA1|SHA224|SHA256|SHA384|SHA512)
				hashProgram=${hashName,,}sum
				hasHash=0
				if ! verifyHash "$toPath" "$fileName" "$hashProgram" "$hashValue"; then
					progressMessageFailed "$hashName hash sum of $downloadName does not match, check logs $logsPath/downloads/$fileName.$hashProgram.log"
				fi
			;;
			
			KEYRING|KEYFILE|HKP|HKP_UNCOMPRESSED)
				hasHash=0
				progressMessage="$hashName signature does not match, check logs $logsPath/downloads/$fileName.${hashName,,}.log"
				if [ -z "$hashSignatureFileName" ]; then
					signatureFileName="$fileName".sig
				else
					signatureFileName="$hashSignatureFileName"
				fi
				
				case "$hashName" in
					KEYRING)
						if ! verifyKeyringSignature "$toPath" "$fileName" "$hashValue" "$signatureFileName" "no"; then
							progressMessageFailed "$progressMessage"
						fi
					;;
			
					KEYFILE)
						if ! verifyKeyFileSignature "$toPath" "$fileName" "$hashValue" "$signatureFileName" "no"; then
							progressMessageFailed "$progressMessage"
						fi
					;;
			
					HKP)
						if ! verifyHkpSignature "$toPath" "$fileName" "$hashValue" "$signatureFileName" "no"; then
							progressMessageFailed "$progressMessage"
						fi
					;;
			
					HKP_UNCOMPRESSED)
						temporaryFolder="$(temporaryFolderToRemoveOnExit)"
						decompressFileToStdout "$decompressionOption" "$toPath"/"$fileName" >"$temporaryFolder"/"$fileName"
						
						if ! verifyHkpSignature "$temporaryFolder" "$fileName" "$hashValue" "$signatureFileName" "yes"; then
							progressMessageFailed "$progressMessage"
						fi
					;;
				esac
				
			;;
			
			
			*)
				exitError "Unsupported hash algorithm $hashName for $toPath/$fileName"
			;;
			
		esac
	done
	
	if [ $hasHash -ne 0 ]; then
		progressMessageFailed "no hash algorithms specified"
	fi
	
	progressMessageSucceeded
}

function downloadSignatures()
{
	local -i signatureNumber
	for signatureNumber in ${!signatures_Url[@]}
	do
		downloadFileAndCheckHash "signature" "${signatures_Url[$signatureNumber]}" "$signaturesPath" "${signatures_FileName[$signatureNumber]}" "${signatures_Compression[$signatureNumber]}" "yes" ""
	done
}

function downloadKeyrings()
{
	local -i keyringNumber
	for keyringNumber in ${!keyrings_Url[@]}
	do
		downloadFileAndCheckHash "keyring" "${keyrings_Url[$keyringNumber]}" "$keyringsPath" "${keyrings_FileName[$keyringNumber]}" "${keyrings_Compression[$keyNumber]}" "no" "${keyrings_Hashes[$keyringNumber]}"
	done
}

function downloadKeys()
{
	local -i keyNumber
	for keyNumber in ${!keys_Url[@]}
	do
		downloadFileAndCheckHash "key" "${keys_Url[$keyNumber]}" "$keysPath" "${keys_FileName[$keyNumber]}" "${keys_Compression[$keyNumber]}" "yes" "${keys_Hashes[$keyNumber]}"
	done
}

function downloadSource()
{
	local -r downloadPhase="$1"
	local -r key="$2"
	downloadFileAndCheckHash "source package ($downloadPhase)" "${sourcePackages_Url["${key}"]}" "$sourcesPath" "${sourcePackages_FileName["${key}"]}" "${sourcePackages_Compression["${key}"]}" "no" "${sourcePackages_Hashes["${key}"]}"
	
	local -i patchNumber
	for patchNumber in ${sourcePackages_Patches["${key}"]}
	do
		downloadFileAndCheckHash "patch ($downloadPhase)" "${patches_Url[$patchNumber]}" "$sourcesPath" "${patches_FileName[$patchNumber]}" "${patches_Compression[$patchNumber]}" "no" "${patches_Hashes[$patchNumber]}"
	done
}

function downloadSources()
{
	local -r localDistributionVersionKey="$(printDistributionVersionKey "$distributionVersion")"
	local key
	local -i patchNumber
	for key in ${installPhase_toolchain1["${localDistributionVersionKey}"]}
	do
		downloadSource "toolchain1" "$key"
	done
	for key in ${installPhase_toolchain2["${localDistributionVersionKey}"]}
	do
		downloadSource "toolchain2" "$key"
	done
	for key in ${installPhase_system["${localDistributionVersionKey}"]}
	do
		downloadSource "system" "$key"
	done
}

INSTALLATION_FAILED_MESSAGE=""
function installationFailedTrapHandler()
{
	progressMessageFailed "$INSTALLATION_FAILED_MESSAGE"
}

function installPackage()
{
	local -r phase="$1"
	local -r key="$2"
	shift 2
	
	LFS_DISTRIBUTION_VERSION="$distributionVersion"
	LFS_PHASE="$phase"
	LFS_KEY="$key"
	LFS_SOURCE_PACKAGE_NAME="${sourcePackages_SourcePackageName["${key}"]}"
	LFS_SOURCE_PACKAGE_VERSION="${sourcePackages_Version["${key}"]}"
	
	progressMessage "Installing phase $LFS_PHASE source package $LFS_SOURCE_PACKAGE_NAME version $LFS_SOURCE_PACKAGE_VERSION"
	
	local -r ourCompression="${sourcePackages_Compression["${key}"]}"
	local -r ourFileName="${sourcePackages_FileName["${key}"]}"
	LFS_EXTRACTED_TARBALL_FOLDER="${sourcePackages_ExtractedTarballFolder["${key}"]}"
	LFS_PATCHES="${sourcePackages_Patches["${key}"]}"
	
	local -i exitCode
	
	# Use an override (versioned) installer, otherwise the default
	local -r installer_versioned=installPackage_${phase}_${LFS_SOURCE_PACKAGE_NAME}_${LFS_SOURCE_PACKAGE_VERSION}
	local -r installer_unversioned=installPackage_${phase}_${LFS_SOURCE_PACKAGE_NAME}
	if type "$installer_versioned" &>/dev/null; then
		local -r installer="$installer_versioned"
	elif type "$installer_unversioned" &>/dev/null; then
		local -r installer="$installer_unversioned"
	else
		progressMessageFailed "No installer $installer_versioned or $installer_unversioned defined"
	fi
	
	local -r extractStdOutLogFile="$logsPath"/"$phase"/"${LFS_SOURCE_PACKAGE_NAME}"-"${LFS_SOURCE_PACKAGE_VERSION}".extract.stdout.log
	local -r extractStdErrLogFile="$logsPath"/"$phase"/"${LFS_SOURCE_PACKAGE_NAME}"-"${LFS_SOURCE_PACKAGE_VERSION}".extract.stderr.log
	
	pushd "$sourcesPath" >/dev/null
		
		if ! tarExtract "$ourFileName" "$LFS_EXTRACTED_TARBALL_FOLDER" "$ourCompression" 1>"$extractStdOutLogFile" 2>"$extractStdErrLogFile"; then
			progressMessageFailed "extraction failed, logs in $phase/${LFS_SOURCE_PACKAGE_NAME}-${LFS_SOURCE_PACKAGE_VERSION}.extract.*.log"
		else
			progressMessageUpdate "extraction complete, logs in $phase/${LFS_SOURCE_PACKAGE_NAME}-${LFS_SOURCE_PACKAGE_VERSION}.extract.*.log"
		
			local -r installStdOutLogFile="$logsPath"/"$phase"/"${LFS_SOURCE_PACKAGE_NAME}"-"${LFS_SOURCE_PACKAGE_VERSION}".install.stdout.log
			local -r installStdErrLogFile="$logsPath"/"$phase"/"${LFS_SOURCE_PACKAGE_NAME}"-"${LFS_SOURCE_PACKAGE_VERSION}".install.stderr.log
		
			pushd "$LFS_EXTRACTED_TARBALL_FOLDER" >/dev/null
				
				INSTALLATION_FAILED_MESSAGE="$installer failed, logs in $phase/${LFS_SOURCE_PACKAGE_NAME}-${LFS_SOURCE_PACKAGE_VERSION}.install.*.log"
				addNextTrapHandler installationFailedTrapHandler
					
					local -i patchNumber
					for patchNumber in $LFS_PATCHES
					do
						echo "Applying patch ${patches_FileName[$patchNumber]}" 1>>"$installStdOutLogFile" 2>>"$installStdErrLogFile"
						if ! patch -Np1 -i ../"${patches_FileName[$patchNumber]}" 1>>"$installStdOutLogFile" 2>>"$installStdErrLogFile"; then
							exit 100
						fi
					done
				
					$installer  1>>"$installStdOutLogFile" 2>>"$installStdErrLogFile"
					installPackageInternal "$installer"
					
				removeLastTrapHandler
				
			popd >/dev/null
			rm -rf -- "$LFS_EXTRACTED_TARBALL_FOLDER"
		fi
		
	popd >/dev/null
	
	if [ $failed -eq 1 ]; then
		progressMessageFailed "$installer failed, logs in $phase/${LFS_SOURCE_PACKAGE_NAME}-${LFS_SOURCE_PACKAGE_VERSION}.install.*.log"
	fi
	progressMessageSucceeded
}

function installPackages()
{
	local -r phase="$1"
	
	local -r localDistributionVersionKey="$(printDistributionVersionKey "$distributionVersion")"
	case "$phase" in
		
		toolchain1)
			local -r packageKeys="${installPhase_toolchain1["${localDistributionVersionKey}"]}"
		;;
		
		toolchain2)
			local -r packageKeys="${installPhase_toolchain2["${localDistributionVersionKey}"]}"
		;;
		
		system)
			local -r packageKeys="${installPhase_system["${localDistributionVersionKey}"]}"
		;;
		
		*)
			exitError "Unknown phase $phase"
		;;
		
	esac
	
	local key
	for key in $packageKeys
	do
		installPackage "$phase" "$key"
	done
}

function stripToolchainSymbols()
{
	if [ "$stripToolchainSymbols" = "yes" ]; then
		strip --strip-debug /"$LFS_TOOLS"/lib/*
		strip --strip-unneeded /"$LFS_TOOLS"/{,s}bin/*
	fi
}

function stripToolchainDocs
{
	if [ "$stripToolchainDocs" = "yes" ]; then
		rm -rf /"$LFS_TOOLS"/{,share}/{info,man,doc}
	fi
}

function main()
{
	setDebugging
	findOurNameAndPath
	addNextTrapHandler removeFilesOnExit
	ensureWhichInstalled
	parseCommandLine "$@"
	
	setPathsAndExports
	
	verifyHostSystemRequirements
	source "$exportedFunctions"
	sourceMirrors
	sourceProfiles
	
	createSkeletonFolderStructure
	
	rehashCertificateAuthorities
	
	# Must have been processed using c_rehash
	
	downloadSignatures
	downloadKeyrings
	downloadKeys
	downloadSources
	
	if [ "$skipToolchain1" = "no" ]; then
		rm -rf /tools/*
		installPackages toolchain1
	fi
	if [ "$skipToolchain2" = "no" ]; then
		installPackages toolchain2
		stripToolchainSymbols
		stripToolchainDocs
	fi
}

main "$@"
