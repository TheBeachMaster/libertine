#!/bin/bash -
set +o allexport -o braceexpand +o emacs -o errexit +o errtrace +o functrace +o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword +o monitor +o noclobber +o noexec +o noglob +o nolog +o notify +o nounset +o onecmd +o physical +o pipefail +o posix +o verbose +o vi +o xtrace;unset BASH_ENV;unset BASH_XTRACEFD;unset CDPATH;unset ENV;unset FCEDIT;unset FIGNORE;unset FUNCNEST;unset GLOBIGNORE;unset HISTCONTROL;unset HISTFILE;unset HISTFILESIZE;unset HISTIGNORE;unset HISTSIZE;unset HISTTIMEFORMAT;unset HOSTFILE;unset IGNOREEOF;unset INPUTRC;unset MAIL;unset MAILCHECK;unset MAILPATH;unset TMOUT;umask 022

function declare_for_chroot()
{
	if [ $# -eq 1 ]; then
		# Done this way to avoid a Core Dump!
		local -r variable="$1"
		eval $variable=
	else
		local -r flags="$1"
		local -r variable="$2"
		declare ${flags}g $variable
	fi
	
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=($variable)
}

function redeclare_array_for_chroot()
{
	local -r variable="$1"
	declare -a $variable
	LFS_ARRAY_VARIABLES_TO_REDECLARE_IN_CHROOT+=($variable)
}

declare_for_chroot -a LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT
declare_for_chroot INSTALLATION_FAILED_MESSAGE

declare_for_chroot -a LFS_ARRAY_VARIABLES_TO_REDECLARE_IN_CHROOT
redeclare_array_for_chroot trapHandlers
redeclare_array_for_chroot filesToRemoveOnExit

# Defensive
declare_for_chroot FUNCNEST
FUNCNEST=40

function ensureWhichInstalled()
{
	set +e
	which
	local -ir exitCode=$?
	set -e
	if [ $exitCode = 127 ]; then
		exitError "Program which does not exist on path $PATH"
	fi
}

function essentialProgramCheck()
{
	# This nasty hack exists because source'd files override the set -xxxx options!
	set -e
	
	local program
	for program in "$@"
	do
		if ! which "$program" 1>/dev/null 2>/dev/null; then
			warning "Program $program does not exist on path $PATH"
			return 100
		fi
	done
}

function verifyDependency()
{
	if [ $# -lt 2 ]; then
		exitError "Needs at least 2 arguments"
	fi
	if [ $# -gt 3 ]; then
		exitError "Needs no more than 3 arguments"
	fi
	
	local -r sourcePackageName="$1"
	
	local version
	read -r -d$'\n' version
	
	# May be incomplete, eg part of the left-hand regex
	# eg 4.2.25(1)-release might be 4.2
	local -r minimumVersion="$2"
	
	# 0 is equal, =
	# 1 is greater than, >
	# 2 is less than, <
	set +e
	compareVersions "$version" "$minimumVersion"
	local -i comparison=$?
	set -e
	if [ $comparison -eq 2 ]; then
		warning "Dependency $sourcePackageName has a version, $version, less than the minimum known to work, $minimumVersion"
	fi
	
	if [ $# -eq 3 ]; then
		local -r maximumVersion="$3"
		
		set +e
		compareVersions "$version" "$maximumVersion"
		local -i comparison=$?
		set -e
		if [ $comparison -eq 1 ]; then
			warning "Dependency $sourcePackageName has a version, $version, greater than the maximum known to work, $maximumVersion"
		fi
	fi
}

# Derived from http://stackoverflow.com/questions/4023830/bash-how-compare-two-strings-in-version-format
function compareVersions()
{
	if [[ "$1" == "$2" ]]; then
		return 0
	fi
	
	local IFS=.
	local i ver1=($1) ver2=($2)
	
	# fill empty fields in ver1 with zeros
	for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
	do
		ver1[i]=0
	done
	
	for ((i=0; i<${#ver1[@]}; i++))
	do
		if [[ -z ${ver2[i]} ]]; then
			# fill empty fields in ver2 with zeros
			ver2[i]=0
		fi
		if ((10#${ver1[i]} > 10#${ver2[i]})); then
			return 1
		fi
		if ((10#${ver1[i]} < 10#${ver2[i]})); then
			return 2
		fi
	done
	
	return 0
}

# The purpose of these functions is to provide internal implementations of logic we can't be 100%
# sure of exists in the environment or is implemented as we would like for critical pieces of code.
# Such a critical piece is code executed before and during command line arg parsing (eg exitError)
# They will usually be MUCH slower than their external equivalents
function purebash_dirname()
{
	local -r converted="${1%/*}"
	if [ "$converted" = "$1" ]; then
		echo "."
	else
		echo "$converted"
	fi
}

function purebash_basename()
{
	echo "${1##*/}"
}

function exitError()
{
	local -r error="$1"
	echo "$ourName: $error" 1>&2
	exit 1
}

function warning()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	echo "$ourName: WARNING: $1" 1>&2
}

function setDebugging()
{
	# is set -x on?
	if [[ "$-" == *x* ]]; then
		export LFS_BASH_DEBUGGING="yes"
		LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('LFS_BASH_DEBUGGING')
	elif [ ! -z "$LFS_BASH_DEBUGGING" ]; then
		if [ "$LFS_BASH_DEBUGGING" = "yes" ]; then
			set -x
		fi
		LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('LFS_BASH_DEBUGGING')
	fi
}

function findOurNameAndPath()
{
	readonly ourName="$(purebash_basename "$0")"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('ourName')
	pushd "$(purebash_dirname "$0")" >/dev/null
	readonly crudeOurPath="$(pwd)"
	popd >/dev/null
}

function executeWithCleanEnvironment()
{
	essentialProgramCheck env sudo
	exec env -i HOME="$HOME" TERM="$TERM" PATH="/sbin:/bin:/usr/sbin:/usr/bin" LFS_BASH_DEBUGGING="$LFS_BASH_DEBUGGING" LFS_CLEAN_ENVIRONMENT='yes' sudo -E -p "Password required to run as root: " -- "$crudeOurPath"/"$ourName" $@
}

function exitHelp()
{
	echo -n -E "Usage: ${ourName} -h
Usage: ${ourName} -d distribution [-l lfsPath] [-c lfsConfigPath] [-m mirrors] [-1 toolchain1Profile] [-2 toolchain2Profile] [-o option] -- [profiles ...]

Profiles
[profiles ...] lists one or more system profiles to create. These are snippets of simplified bash
script, that install and build from source what would be called packages on other systems.

If no profile is specified, then the baseline 'lfs' profile is used.

profiles are executed in the order listed. Internally, a profile may reference (source)
another profile it depends on. This is the equivalent of package management on other
systems. A set of profiles is intended to be version-controlled using a source control system
such as git and so do not declare explicit version dependencies.

The profiles 'toolchain1' and 'toolchain2' are special. Implementors of profiles can assume
that these profiles are always sourced. It is an error to specify them in the list of profiles.

A profile does not have to just install packages.

Profiles may be suffixed with [distribution] to target a particular distribution.

Defaults
    distribution       ${LFS_DISTRIBUTION_VERSION}
    lfsPath            ${lfsPath}
    lfsConfigPath      ${lfsConfigPath}
    mirrors            ${mirrors}
    toolchain1Profile  ${toolchain1Profile}
    toolchain2Profile  ${toolchain2Profile}
    option             See below
    profiles           ${profiles}

A mirror defines mirror URLs. If a mirror is 'timezone', then timezone settings used to determine the actual mirrors.
If Etc/UTC or something similar is the timezone, then the 'language' mirrors are used. These use the LC_CTYPE,
LANG and LANGUAGE environment variables in order. The 'global' mirror can be specified to override this. A list of mirrors
is in <lfsConfigPath>/mirrors . Conversions from timezone and language are controlled using <lfsConfigPath>/timezones-to-mirrors.map
and <lfsConfigPath>/languages-to-mirrors.map respectively. Note that some mirrors, eg for the UK, are incomplete and source
the global mirrors first to provide defaults. mirrors may be symlinks.

At this time we don't support the metalink (.meta4) protocol for mirrors (as it requires additional
runtime dependencies).

Options
For options, prefix with either 'yes-' to turn it on
or 'no-' to turn it off. For example, to turn on 'strip-system-docs' :-

    ${ourName} -o yes-strip-system-docs

-o may be repeated as necessary. Options are evaluated in left-to-right order.
Last setting wins.

Options are as follows:-     Default
    skip-toolchain-if-backup-exists  ${skipToolchainIfBackupExists}
    strip-toolchain-symbols          ${stripToolchainSymbols}
    strip-toolchain-docs             ${stripToolchainDocs}
    strip-system-symbols             ${stripSystemSymbols}
    strip-system-docs                ${stripSystemDocs}
" 1>&2
	exit $1
}

function parseCommandLine()
{
	# Defaults
	LFS_DISTRIBUTION_VERSION="7.4"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('LFS_DISTRIBUTION_VERSION')
	
	lfsPath="/var/tmp/lfs"
	
	lfsConfigPath="${crudeOurPath}/config"
	
	mirrors="timezone"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('mirrors')
	
	toolchain1Profile=toolchain1
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('toolchain1Profile')
	
	toolchain2Profile=toolchain2
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('toolchain2Profile')
	
	skipToolchainIfBackupExists="yes"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('skipToolchainIfBackupExists')
	
	stripToolchainSymbols="yes"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('stripToolchainSymbols')
	
	stripToolchainDocs="yes"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('stripToolchainDocs')
	
	stripSystemSymbols="yes"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('stripSystemSymbols')
	
	stripSystemDocs="no"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('stripSystemDocs')
	
	profiles="system"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('profiles')
	
	if [ "$LFS_CLEAN_ENVIRONMENT" != "yes" ]; then
		executeWithCleanEnvironment "$@"
	else
		local OPTERR=1
		local OPTIND=1
		local OPTARG
		local option
		while getopts :hl:d:m:1:2:o: option
		do
			case "$option" in
				
				h)
					exitHelp 2
				;;
				
				d)
					LFS_DISTRIBUTION_VERSION="$OPTARG"
				;;
				
				l)
					lfsPath="$OPTARG"
				;;
				
				c)
					lfsConfigPath="$OPTARG"
				;;
				
				m)
					mirrors="$OPTARG"
				;;
				
				1)
					toolchain1Profile="$OPTARG"
				;;
				
				2)
					toolchain2Profile="$OPTARG"
				;;
				
				o)
					if [ -z "$OPTARG" ]; then
						exitError "Invalid option -o requires an argument"
					fi
				
					case "$OPTARG" in
						
						no-skip-toolchain-if-backup-exists)
							skipToolchainIfBackupExists="no"
						;;
						
						yes-skip-toolchain-if-backup-exists)
							skipToolchainIfBackupExists="yes"
						;;
						
						no-strip-toolchain-symbols)
							stripToolchainSymbols="no"
						;;
						
						yes-strip-toolchain-symbols)
							stripToolchainSymbols="yes"
						;;
						
						no-strip-toolchain-docs)
							stripToolchainDocs="no"
						;;
						
						yes-strip-toolchain-docs)
							stripToolchainDocs="yes"
						;;
						
						no-strip-system-symbols)
							stripSystemSymbols="no"
						;;
						
						yes-strip-system-symbols)
							stripSystemSymbols="yes"
						;;
						
						no-strip-system-docs)
							stripSystemDocs="no"
						;;
						
						yes-strip-system-docs)
							stripSystemDocs="yes"
						;;
						
						*)
							exitError "Invalid option -o ${OPTARG}"
						;;
						
					esac
				;;
				
				'?')
					exitError "Invalid option -${OPTARG}"
				;;
				
			esac
		done
		
		shift $((OPTIND - 1))
		if [ $# -ne 0 ]; then
			profiles="$@"
		fi
		
		if [ -z "$LFS_DISTRIBUTION_VERSION" ]; then
			exitError "Please specify a distribution using -d"
		fi
	fi
}

function setPathsAndExports()
{
	export PATH=/sbin:/bin:/usr/sbin:/usr/bin
	
	essentialProgramCheck mkdir uname awk sort md5sum
	
	if [ ! -d "$lfsConfigPath" ]; then
		exitError "Config path $lfsConfigPath does not exist or is not a directory"
	fi
	pushd "$lfsConfigPath">/dev/null
	lfsConfigPath="$(pwd)"
	popd >/dev/null
	
	readonly distributionConfigPath="$lfsConfigPath"/"$LFS_DISTRIBUTION_VERSION"
	if [ ! -d "$distributionConfigPath" ]; then
		exitError "distribution config path $distributionConfigPath does not exist or is not a directory"
	fi
	
	readonly certificateAuthoritiesPath="$distributionConfigPath"/certificate-authorities
	if [ ! -d "$certificateAuthoritiesPath" ]; then
		exitError "certificate-authorities path $certificateAuthoritiesPath does not exist or is not a directory"
	fi
	
	readonly mirrorsPath="$distributionConfigPath"/mirrors
	if [ ! -d "$mirrorsPath" ]; then
		exitError "Mirrors path $mirrorsPath does not exist or is not a directory"
	fi
	
	readonly profilesPath="$distributionConfigPath"/profiles
	if [ ! -d "$profilesPath" ]; then
		exitError "Profiles path $profilesPath does not exist or is not a directory"
	fi
	
	readonly gpghomePath="$distributionConfigPath"/gpghome
	if [ ! -d "$gpghomePath" ]; then
		exitError "gpghome path $gpghomePath does not exist or is not a directory"
	fi
	
	readonly keyringsPath="$distributionConfigPath"/keyrings
	if [ ! -d "$keyringsPath" ]; then
		exitError "Keyrings path $keyringsPath does not exist or is not a directory"
	fi
	
	readonly keysPath="$distributionConfigPath"/keys
	if [ ! -d "$keysPath" ]; then
		exitError "Keys path $keysPath does not exist or is not a directory"
	fi
	
	readonly signaturesPath="$distributionConfigPath"/signatures
	if [ ! -d "$signaturesPath" ]; then
		exitError "Signatures path $signaturesPath does not exist or is not a directory"
	fi
	
	readonly recipesPath="$distributionConfigPath"/recipes
	if [ ! -d "$recipesPath" ]; then
		exitError "Recipes path $recipesPath does not exist or is not a directory"
	fi
	
	readonly includesPath="$distributionConfigPath"/includes
	if [ ! -d "$includesPath" ]; then
		exitError "includes path $includesPath does not exist or is not a directory"
	fi
	
	readonly functionsPath="$distributionConfigPath"/functions
	if [ ! -d "$includesPath" ]; then
		exitError "functions path $functionsPath does not exist or is not a directory"
	fi
	
	readonly settingsPath="$distributionConfigPath"/settings
	if [ ! -f "$settingsPath" ]; then
		exitError "settings file $settingsPath does not exist or is not a file"
	fi
	
	if [ ! -d "$lfsPath" ]; then
		mkdir -m 0755 -p "$lfsPath"
	fi
	pushd "$lfsPath">/dev/null
	lfsPath="$(pwd)"
	popd >/dev/null
	
	LFS_LOG_PATH=/var/log/lfs/"$LFS_DISTRIBUTION_VERSION"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('LFS_LOG_PATH')
	
	LFS_DOWNLOADS_PATH="$lfsPath"/downloads
	
	LFS="$lfsPath"/"$LFS_DISTRIBUTION_VERSION"
	
	# We use the hashes of the toolchain1 and toolchain2 profiles to establish the uniqueness of the toolchain
	local -r hashesWithTrailingHyphen="$(sha224sum "$profilesPath"/"$toolchain1Profile".profile "$profilesPath"/"$toolchain2Profile".profile | awk -v ORS='-' '{print $1}')"
	LFS_VERSION="$LFS_DISTRIBUTION_VERSION"-"${hashesWithTrailingHyphen:0:${#hashesWithTrailingHyphen}-1}"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('LFS_VERSION')
	LFS_TOOLS=tools-"$LFS_VERSION"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('LFS_TOOLS')
	
	LFS_SOURCES_PATH="$LFS"/sources
	LFS_TOOLS_PATH="$LFS"/"$LFS_TOOLS"
	
	readonly toolsBackUpPath="$LFS"/"$LFS_TOOLS".backup
	
	export LC_ALL=POSIX
	LFS_TGT="$(uname -m)"-lfs-linux-gnu
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('LFS_TGT')
	
	if [ -f /proc/cpuinfo ]; then
		local -i highestCpu
		read -r -d $'\n' highestCpu < <(awk '$1 ~ /processor/ { print $3 }' /proc/cpuinfo | sort --unique --reverse --numeric-sort)
		local -ir highestCpuZeroBased=$((highestCpu + 1))
	else
		local -ir highestCpuZeroBased=1
	fi
	if [ $highestCpuZeroBased -ne 1 ]; then
		export MAKEFLAGS="-j $((highestCpuZeroBased*2))"
		LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('MAKEFLAGS')
	fi
}

function registerDebianPackage()
{
	printf '%s' "$@" >>"$LFS_CURRENT_DEBIAN_PACKAGES_TEMP"
}

function verifyHostSystemRequirements()
{
	# Check against http://www.linuxfromscratch.org/lfs/view/development/prologue/hostreqs.html
	
	readonly dependencyChecks="$distributionConfigPath"/dependency-checks
	if [ ! -d "$dependencyChecks" ]; then
		exitError "dependency-checks $dependencyChecks does not exist or is not a directory"
	fi
	
	local debianPackagesToInstallForDependencies=""
	
	pushd "$dependencyChecks" >/dev/null
		local dependencyCheck
		local -i exitCode
		for dependencyCheck in *.dependency-check
		do
			# Used to communicate with subshell, as we can't pass variables back (and we output stdout / stderr to the console)
			temporaryFileToRemoveOnExit
			LFS_CURRENT_DEBIAN_PACKAGES_TEMP="$TMP_FILE"
			# done as subshell to overcome the fact that commands are executing outside of a function
			if ! (source "$dependencyCheck"); then
				if [ -z "$debianPackagesToInstallForDependencies" ]; then
					debianPackagesToInstallForDependencies="$(head -n 1 "$LFS_CURRENT_DEBIAN_PACKAGES_TEMP")"
				else
					debianPackagesToInstallForDependencies="$debianPackagesToInstallForDependencies $(head -n 1 "$LFS_CURRENT_DEBIAN_PACKAGES_TEMP")"
				fi
			fi
		done
	popd >/dev/null

	if [ ! -z "$debianPackagesToInstallForDependencies" ]; then
		if which apt-get 1>/dev/null 2>/dev/null; then
			apt-get --quiet --quiet --yes update
			apt-get --quiet --quiet --yes install $debianPackagesToInstallForDependencies
		fi
	fi
}

function include_mirrors()
{
	progressMessage "Including mirror $mirrors"
	
	pushd "$mirrorsPath" >/dev/null
		
		include_mirror "$mirrors"
		
	popd >/dev/null
	
	local requiredMirrorName
	for requiredMirrorName in "${!keyrings_Mirror[@]}" "${!keys_Mirror[@]}" "${!sourcePackages_Mirror[@]}" "${!patches_Mirror[@]}"
	do
		if ! mirrorExists "$requiredMirrorName"; then
			progressMessageFailed "Mirror $requiredMirrorName is not defined in mirrors $mirrors"
		fi
	done
	
	progressMessageSucceeded
}

function include_phase()
{
	local -r phase="$1"
	shift 1
	
	pushd "$profilesPath" >/dev/null
		
		declare -A LFS_SOURCE_PACKAGE_VERSIONS
		declare -A LFS_SOURCE_PACKAGE_VERSION
		for profile in "$@"
		do
			progressMessage "Including phase $phase profile $profile"
			LFS_PHASE="$phase" include_profile "$profile"
			progressMessageSucceeded
		done
		declare -A LFS_SOURCE_PACKAGE_VERSION
		unset LFS_SOURCE_PACKAGE_VERSIONS
		
	popd >/dev/null
}

function include_profiles()
{
	include_phase toolchain1 "$toolchain1Profile"
	include_phase toolchain2 "$toolchain2Profile"
	include_phase system $profiles
}

function createSkeletonFolderStructure()
{
	mkdir -m 0755 -p "$LFS"
	
	# Logs
	mkdir -m 0755 -p "$LFS_LOG_PATH"
	rm -rf "$LFS_LOG_PATH"/*
	
	readonly downloadsLogsPath="$LFS_LOG_PATH"/downloads
	mkdir -m 0755 -p "$downloadsLogsPath"
	
	# Sources
	mkdir -m 0755 -p "$LFS_SOURCES_PATH"
	
	# Tools Symlink
	if [ -L /"$LFS_TOOLS" ]; then
		rm -rf -- /"$LFS_TOOLS"
	fi
	# symlink, say, /mnt/lfs/tools as /tools
	ln --symbolic "$LFS_TOOLS_PATH" /
}

function downloadCertificateAuthorities()
{
	local certificateAuthorityName
	for certificateAuthorityName in "${!certificateAuthorities_Mirror[@]}"
	do
		downloadFileAndCheckHash "certificate authority" "${certificateAuthorities_Mirror["${certificateAuthorityName}"]}" "${certificateAuthorities_RelativePath["${certificateAuthorityName}"]}" "$certificateAuthoritiesPath" "${certificateAuthorities_FileName["${certificateAuthorityName}"]}" "${certificateAuthorities_Compression["${certificateAuthorityName}"]}" "no" "${certificateAuthorities_Hashes["${certificateAuthorityName}"]}"
	done
}

function downloadSignatures()
{
	local -i index
	for index in ${!signatures_Mirror[@]}
	do
		downloadFileAndCheckHash "signature" "${signatures_Mirror[$index]}" "${signatures_RelativePath[$index]}" "$signaturesPath" "${signatures_FileName[$index]}" "${signatures_Compression[$index]}" "yes" ""
	done
}

function downloadKeyrings()
{
	local -i index
	for index in ${!keyrings_Mirror[@]}
	do
		downloadFileAndCheckHash "keyring" "${keyrings_Mirror[$index]}" "${keyrings_RelativePath[$index]}" "$keyringsPath" "${keyrings_FileName[$index]}" "${keyrings_Compression[$keyNumber]}" "no" "${keyrings_Hashes[$index]}"
	done
}

function downloadKeys()
{
	local -i index
	for index in ${!keys_Mirror[@]}
	do
		downloadFileAndCheckHash "key" "${keys_Mirror[$index]}" "${keys_RelativePath[$index]}" "$keysPath" "${keys_FileName[$index]}" "${keys_Compression[$index]}" "yes" "${keys_Hashes[$index]}"
	done
}

function downloadSources()
{
	local -i index
	for index in ${!sourcePackages_Mirror[@]}
	do
		downloadFileAndCheckHash "source package" "${sourcePackages_Mirror[$index]}" "${sourcePackages_RelativePath[$index]}" "$LFS_SOURCES_PATH" "${sourcePackages_FileName[$index]}" "${sourcePackages_Compression[$index]}" "no" "${sourcePackages_Hashes[$index]}"
	done
}

function downloadPatches()
{
	local -i index
	for index in ${!patches_Mirror[@]}
	do
		downloadFileAndCheckHash "patch" "${patches_Mirror[$index]}" "${patches_RelativePath[$index]}" "$LFS_SOURCES_PATH" "${patches_FileName[$index]}" "${patches_Compression[$index]}" "no" "${patches_Hashes[$index]}"
	done
}

function dependencyToPath()
{
	# TODO: Defer the 'current' creation
	
	local -r relativeOptPath=/opt/lfs/"$LFS_DISTRIBUTION_VERSION"
	local -r absoluteOptPath="${LFS}${relativeOptPath}"
	mkdir -m 0755 -p "$absoluteOptPath"
	rm -rf -- "$absoluteOptPath"/current
	ln -s "$LFS_DISTRIBUTION_VERSION" "$absoluteOptPath"/current
	
	local -r relativatePackagePath="$relativeOptPath"/"$LFS_PHASE"/"$LFS_DEPENDENCY_NAME"
	local -r absolutePackagePath="${LFS}${absoluteOptPath}"
	mkdir -m 0755 -p "$absolutePackagePath"
	
	local -r relativeVersionPath="$relativatePackagePath"/"$LFS_DEPENDENCY_VERSION"
	local -r absoluteVersionPath="${LFS}${relativeVersionPath}"
	mkdir -m 0755 -p "$absoluteVersionPath"
	rm -rf -- "$absolutePackagePath"/current
	ln -s "$LFS_DEPENDENCY_VERSION" "$absolutePackagePath"/current
	
	
	# Find and hash dependencies
	addFileToRemoveOnExit
	local -r dependenciesFileUnsorted="$TMP_FILE"
	local dependency
	declare -A dependencyPaths=()
	for dependency in ${!dependency_Dependencies["$LFS_DEPENDENCY_KEY"]}
	do
		printf '%s\0' "${dependency_Path["$dependency"]}" >>"$dependenciesFileUnsorted"
		local name="${dependency_Name["$dependency"]}"
		dependencyPaths["$name"]="${dependency_Path["$dependency"]}"
	done
	addFileToRemoveOnExit
	local -r dependenciesFileSorted="$TMP_FILE"
	# --stable and LC_ALL=C to ensure a consistent sort order before hashing
	LC_ALL=C sort --key=1 --stable --zero-terminated "$dependenciesFileUnsorted" >"$dependenciesFileSorted"
	local -r dependenciesHash="$(sha224sum "$dependenciesFileSorted" | awk 'NR==1 {print $1}')"
	
	
	
	# We should consider breaking-up settings to per recipe - as this better reflects changes
	local -r recipeVersion=recipe-"$LFS_DEPENDENCY_RECIPE_HASH"-include-"$LFS_DEPENDENCY_INCLUDE_HASH"-dependencies-"$dependenciesHash"-settings-"$LFS_SETTINGS_HASH"
	local -r relativeCompletePath="$relativeVersionPath"/"$recipeVersion"
	local -r absoluteCompletePath="${LFS}${absoluteVersionPath}"
	mkdir -m 0755 -p "$absoluteRecipePath"
	rm -rf -- "$absoluteVersionPath"/current
	ln -s "$recipeVersion" "$absoluteVersionPath"/current
	
	
	sudo -u \#${LFS_DEPENDENCY_UID} -g \#${LFS_DEPENDENCY_GID} -- mkdir -m 0755 -p "$absoluteCompletePath"/root
	
	mv "$dependenciesFileSorted" "$absoluteCompletePath"/dependencies.list
	chown ${LFS_DEPENDENCY_UID}:${LFS_DEPENDENCY_GID} "$absoluteCompletePath"/dependencies.list
	chmod 0400 "$absoluteCompletePath"/dependencies.list
	
	local -r absoluteDependenciesPath="$absoluteCompletePath"/dependencies
	mkdir -m 0755 -p "$absoluteDependenciesPath"
	local dependencyName
	local dependencyPath
	for dependencyName in "${!dependencyPaths[@]}"
	do
		ln -s "${dependencyPaths["$dependencyName"]}" "$absoluteDependenciesPath"/"$dependencyName"
	done
	
	dependency_Path["$LFS_DEPENDENCY_KEY"]="$relativeCompletePath"
}

function installPackage()
{
	LFS_PHASE="$1"
	LFS_DEPENDENCY_KEY="$2"
	LFS_DEPENDENCY_NAME="${dependency_Name["$LFS_DEPENDENCY_KEY"]}"
	LFS_DEPENDENCY_VERSION="${dependency_Version["$LFS_DEPENDENCY_KEY"]}"
	LFS_DEPENDENCY_RECIPE_HASH="${dependency_RecipeHash["$LFS_DEPENDENCY_KEY"]}"
	LFS_DEPENDENCY_INCLUDE_HASH="${dependency_IncludeHash["$LFS_DEPENDENCY_KEY"]}"
	
	LFS_DEPENDENCY_USER="${dependency_User["$LFS_DEPENDENCY_KEY"]}"
	LFS_DEPENDENCY_GROUP="${dependency_Group["$LFS_DEPENDENCY_KEY"]}"
	LFS_DEPENDENCY_UID="${dependency_Uid["$LFS_DEPENDENCY_KEY"]}"
	LFS_DEPENDENCY_GID="${dependency_Gid["$LFS_DEPENDENCY_KEY"]}"
	
	dependencyToPath
	LFS_DEPENDENCY_PATH="${dependency_Path["$LFS_DEPENDENCY_KEY"]}"
	LFS_DEPENDENCY_INSTALL_PATH="$LFS_DEPENDENCY_PATH"/root
	
	local -r LFS_DEPENDENCY_SKIP_INSTALL="${dependency_SkipInstall["$LFS_DEPENDENCY_KEY"]}"
	if [ "$LFS_DEPENDENCY_SKIP_INSTALL" = "1" ]; then
		return 0
	fi
	
	LFS_SOURCE_PACKAGE_INDEX=${dependency_SourcePackageIndex["$LFS_DEPENDENCY_KEY"]}
	LFS_SOURCE_PACKAGE_NAME="${sourcePackages_Name[$LFS_SOURCE_PACKAGE_INDEX]}"
	LFS_SOURCE_PACKAGE_VERSION="${sourcePackages_Version[$LFS_SOURCE_PACKAGE_INDEX]}"
	LFS_SOURCE_PACKAGE_COMPRESSION="${sourcePackages_Compression[$LFS_SOURCE_PACKAGE_INDEX]}"
	LFS_SOURCE_PACKAGE_FILENAME="${sourcePackages_FileName[$LFS_SOURCE_PACKAGE_INDEX]}"
	LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER="${sourcePackages_ExtractedTarballFolder[$LFS_SOURCE_PACKAGE_INDEX]}"
	LFS_SOURCE_PACKAGE_IS_TARBOMB="${sourcePackages_IsTarbomb[$LFS_SOURCE_PACKAGE_INDEX]}"
	
	local -r installer_versioned=installPackage_${LFS_PHASE}_${LFS_DEPENDENCY_NAME}_${LFS_DEPENDENCY_VERSION}
	local -r installer_unversioned=installPackage_${LFS_PHASE}_${LFS_DEPENDENCY_NAME}
	
	local -r logPathPrefix="$LFS_LOG_PATH"/"$LFS_DEPENDENCY_KEY"
	local -r installStdOutLogFile="$logPathPrefix".install.stdout.log
	local -r installStdErrLogFile="$logPathPrefix".install.stderr.log
	local -i exitCode
	
	progressMessage "Installing phase $LFS_PHASE dependency $LFS_DEPENDENCY_NAME version $LFS_DEPENDENCY_VERSION"
	
	# Use an override (versioned) installer, otherwise the default
	if type "$installer_versioned" &>/dev/null; then
		local -r installer="$installer_versioned"
	elif type "$installer_unversioned" &>/dev/null; then
		local -r installer="$installer_unversioned"
	else
		progressMessageFailed "No installer $installer_versioned or $installer_unversioned defined"
	fi
	
	pushd "$LFS_SOURCES_PATH" >/dev/null
		
		if [ ! -z "$LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER" ]; then
			tarExtract "$LFS_SOURCE_PACKAGE_FILENAME" "$LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER" "$LFS_SOURCE_PACKAGE_COMPRESSION" "$LFS_SOURCE_PACKAGE_IS_TARBOMB"
			progressMessageUpdate "(tar extraction complete, logs in $logPathPrefix.extract.*.log)"
		fi
		
		if [ ! -z "$LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER" ]; then
			pushd "$LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER" >/dev/null
		fi
		
			INSTALLATION_FAILED_MESSAGE="$installer failed, logs in $logPathPrefix.install.*.log"
			addNextTrapHandler installationFailedTrapHandler
				
				exec 6>&1 1>"$installStdOutLogFile"
				exec 7>&2 2>"$installStdErrLogFile"
					
					local -i index
					for index in ${dependency_PatchIndices["$LFS_DEPENDENCY_KEY"]}
					do
						echo "Applying patch ${patches_FileName[$index]}"
						if ! patch -Np1 -i ../"${patches_FileName[$index]}"; then
							exit 100
						fi
					done
					
					set -x
					# FORCE_UNSAFE_CONFIGURE=1 allows configure to run as root
					sudo -u \#${LFS_DEPENDENCY_UID} -g \#${LFS_DEPENDENCY_GID} -- FORCE_UNSAFE_CONFIGURE=1 $installer
					set +x
					
					
				exec 1>&6 6>&-
				exec 2>&7 7>&-
				
			removeLastTrapHandler
		
		if [ ! -z "$LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER" ]; then
			popd >/dev/null
			rm -rf -- "$LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER"
		fi
		
	popd >/dev/null
	
	progressMessageSucceeded
}

function installPackages()
{
	local -r phase="$1"
	local key
	
	for dependencyKey in ${phase_InstallationOrder["${phase}"]}
	do
		installPackage "$phase" "$dependencyKey"
	done
}

function stripToolchainSymbolsAfterToolchain2()
{
	if [ "$stripToolchainSymbols" = "yes" ]; then
		set +e
		# Fails for /tools/lib/thread2.7.0/libthread2.7.0.so
		find /"$LFS_TOOLS"/lib -type f \( -name '*.a' -o -name '*.o' -o \( -name '*.so*' -a ! -name '*.py' \) \) -print0 | xargs --null file --print0 --separator ' ' | awk -v IRS=$'\0' -v ORS=$'\0' '$2 ~/ELF|current/ {print $1}' | xargs --null strip --verbose --strip-debug
		find /"$LFS_TOOLS"/{,s}bin -type f -executable -print0 | xargs --null file --print0 --separator ' ' | awk -v IRS=$'\0' -v ORS=$'\0' '$2 ~/ELF/ {print $1}' | xargs --null strip --verbose --strip-unneeded
		set -e
	fi
}

function stripToolchainDocsAfterToolchain2
{
	if [ "$stripToolchainDocs" = "yes" ]; then
		rm -rf -- /"$LFS_TOOLS"/{,share}/{info,man,doc}
	fi
}

function backUpToolchain()
{
	if which rsync 1>/dev/null 2>/dev/null; then
		progressMessage "Backing up toolchain using rsync to $toolsBackUpPath"
		mkdir -m 0755 -p "$toolsBackUpPath"
		if rsync --verbose --archive --hard-links --acls --xattrs --delete-after --force --numeric-ids --fake-super --link-dest="$toolsBackUpPath" "$LFS_TOOLS_PATH"/ "$toolsBackUpPath"/ 1>"$LFS_LOG_PATH"/toolchain.backup.stdout.log 2>"$LFS_LOG_PATH"/toolchain.backup.stderr.log; then
			progressMessageSucceeded
		else
			progressMessageFailed "check logs in $LFS_LOG_PATH/toolchain.backup.*.log"
		fi
	fi
	
	progressMessage "Tarballing up toolchain using tar/gz to $toolsBackUpPath.tar.gz"
	tar --create --owner=root --group=root --sparse --posix --directory "$LFS" "$LFS_TOOLS" | gzip -9 >"$toolsBackUpPath".tar.gz
	progressMessageSucceeded
}

function createToolchain()
{
	progressMessage "Initiating creation of toolchain ($LFS_TOOLS)"
		chattr -R -f -aiD "$LFS" 1>/dev/null 2>/dev/null || true
		rm -rf -- "$LFS_TOOLS_PATH"
		mkdir -m 0755 -p "$LFS_TOOLS_PATH"
		export PATH=/"$LFS_TOOLS"/bin:/bin:/usr/bin
	progressMessageSucceeded
	
	installPackages toolchain1
	installPackages toolchain2
	
	progressMessage "Stripping toolchain symbols ($stripToolchainSymbols)"
	stripToolchainSymbolsAfterToolchain2 1>"$"$LFS_LOG_PATH""/toolchain2_strip-symbols.stdout.log 2>/toolchain2_strip-symbols.stderr.log
	progressMessageSucceeded
	
	progressMessage "Stripping toolchain docs ($stripToolchainDocs)"
	stripToolchainDocsAfterToolchain2 1>"$"$LFS_LOG_PATH""/toolchain2_strip-docs.stdout.log 2>/toolchain2_strip-docs.stderr.log
	progressMessageSucceeded
	
	backUpToolchain
}

function cleanUpTarget()
{
	if [ ! -d "$LFS" ]; then
		return 0
	fi
	
	progressMessage "Cleaning up target $LFS"
	
		chattr -R -f -aiD "$LFS" 1>"$LFS_LOG_PATH"/system_chattr-cleanup.stdout.log 2>"$LFS_LOG_PATH"/system_chattr-cleanup.stderr.log || true
		
		pushd "$LFS" >/dev/null
		
			local file
			for file in *
			do
				case "$file" in
					
					dev|proc|sys|sources|$LFS_TOOLS|$LFS_TOOLS.backup|$LFS_TOOLS.backup.*)
						:
					;;
				
					*)
						if ! rm -rf -- "$file"; then
							progressMessageFailed "could not remove $file"
						fi
					;;
				
				esac
			done
			
			if [ -d dev ]; then
				
				pushd dev >/dev/null
				
					for file in *
					do
						if [ ! -f "$file" ]; then
							if ! rm -rf -- "$file"; then
								progressMessageFailed "could not remove dev/$file"
							fi
						fi
					done
					
				popd >/dev/null
				
			fi
			
			if [ -d sources ]; then
				
				pushd sources >/dev/null
				
					for file in *
					do
						if [ ! -f "$file" ]; then
							if ! rm -rf -- "$file"; then
								progressMessageFailed "could not remove sources/$file"
							fi
						fi
					done
					
				popd >/dev/null
				
			fi
			
		popd >/dev/null
		
	progressMessageSucceeded
}

function createOrUseBackUpToolchain()
{
	if [ "$skipToolchainIfBackupExists" = "yes" ]; then
		if [ -d "$toolsBackUpPath" ] && which rsync 1>/dev/null 2>/dev/null; then
			cleanUpTarget
			progressMessage "Restoring toolchain using rsync ($LFS_TOOLS)"
				mkdir -m 0755 -p "$LFS_TOOLS_PATH"
				
				if ! rsync --verbose --archive --hard-links --acls --xattrs --delete-after --force --numeric-ids --fake-super --link-dest="$LFS_TOOLS_PATH" "$toolsBackUpPath"/ "$LFS_TOOLS_PATH"/ 1>"$LFS_LOG_PATH"/toolchain.restore.stdout.log 2>"$LFS_LOG_PATH"/toolchain.restore.stderr.log; then
					progressMessageFailed "check logs in $LFS_LOG_PATH/toolchain.restore.*.log"
				fi
				changeOwnerOfToolchain
			progressMessageSucceeded
			
		elif [ -f "$toolsBackUpPath".tar.gz ]; then
			cleanUpTarget
			progressMessage "Restoring toolchain using tarball ($LFS_TOOLS)"
				rm -rf -- "$LFS_TOOLS_PATH"
				
				pushd "$LFS"/.. >/dev/null
					if ! tar --extract --gzip --file "$toolsBackUpPath".tar.gz 1>"$LFS_LOG_PATH"/toolchain.restore.stdout.log 2>"$LFS_LOG_PATH"/toolchain.restore.stderr.log; then
						progressMessageFailed "check logs in $LFS_LOG_PATH/toolchain.restore.*.log"
					fi
				popd >/dev/null
				changeOwnerOfToolchain
			progressMessageSucceeded
		else
			createToolchain
		fi
	else
		createToolchain
	fi
}

function runSystemInstallationLogic()
{
	local -r callback="$1"
	
	local -r stdoutLog="$LFS_LOG_PATH"/system_"$callback".stdout.log
	local -r stderrLog="$LFS_LOG_PATH"/system_"$callback".stderr.log
	
	progressMessage "Phase system, executing $callback on target"
		
		INSTALLATION_FAILED_MESSAGE="logs in $phase/$callback.*.log"
		addNextTrapHandler installationFailedTrapHandler
			
			exec 6>&1 1>"$stdoutLog"
			exec 7>&2 2>"$stderrLog"
				
				set -x
				# FORCE_UNSAFE_CONFIGURE=1 allows configure to run as root
				FORCE_UNSAFE_CONFIGURE=1 $callback
				set +x
				
			exec 1>&6 6>&-
			exec 2>&7 7>&-
			
		removeLastTrapHandler
		
	progressMessageSucceeded
}

function mountVirtualFilesystems()
{
	local -i index
	local -i ttyGid=-1
	for index in ${!groups_Name[@]}
	do
		if [ "${groups_Name[$index]}" = "tty" ]; then
			ttyGid=${groups_Gid[$index]}
			break
		fi
	done
	if [ $ttyGid -eq -1 ]; then
		exitError "Please ensure the tty group is defined on the target system"
	fi
	
	mount --bind /dev "$LFS"/dev
	mount -t devpts devpts "$LFS"/dev/pts -o gid=$ttyGid,mode=620
	mount -t proc proc "$LFS"/proc
	mount -t sysfs sysfs "$LFS"/sys
	
	# On Debian/Ubuntu and others, /dev/shm is a symlink to a file that would be outside of the LFS chroot due to the mount of /dev above
	if [ -h "$LFS"/dev/shm ]; then
		local -r link="$(readlink "$LFS"/dev/shm)"
		mkdir -m 0755 -p "$LFS"/"$link"
		mount -t tmpfs shm "$LFS"/"$link"
	else
		mount -t tmpfs shm "$LFS"/dev/shm
	fi
}

function unmountVirtualFilesystems()
{
	umount "$LFS"/dev/pts

	if [ -h "$LFS"/dev/shm ]; then
		local -r link=$(readlink "$LFS"/dev/shm)
		umount "$LFS"/"$link"
	else
		umount "$LFS"/dev/shm
	fi

	umount "$LFS"/dev
	umount "$LFS"/proc
	umount "$LFS"/sys
}

function replicateBashFunctionsAndGlobalVariables()
{
	# compgen will include local variables, so we use a subshell...
	compgen -v | while IFS='' read -r -d $'\n' variableName
	do
		if [ "${variableName:0:4}" = "LFS_" ]; then
			declare -p "$variableName"
			continue
		fi
		for LFS_GLOBAL_VARIABLE_TO_EXPORT_TO_CHROOT in "${LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT[@]}"
		do
			if [ "$LFS_GLOBAL_VARIABLE_TO_EXPORT_TO_CHROOT" = "$variableName" ]; then
				declare -p "$variableName"
				break
			fi
		done
	done
	
	local LFS_ARRAY_VARIABLE_TO_REDECLARE_IN_CHROOT
	for LFS_ARRAY_VARIABLE_TO_REDECLARE_IN_CHROOT in "${LFS_ARRAY_VARIABLES_TO_REDECLARE_IN_CHROOT[@]}"
	do
		declare -a "$LFS_ARRAY_VARIABLE_TO_REDECLARE_IN_CHROOT"
	done
	
	declare -f
}

function chrootToEnvironment()
{
	local -r continutationBinaryForChroot="$LFS"/"$LFS_TOOLS"/sbin/lfs-chroot-install
	cat >"$continutationBinaryForChroot" <<-EOF
		#!/bin/bash -
		set +o allexport -o braceexpand +o emacs -o errexit +o errtrace +o functrace +o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword +o monitor +o noclobber +o noexec +o noglob +o nolog +o notify +o nounset +o onecmd +o physical +o pipefail +o posix +o verbose +o vi +o xtrace;unset BASH_ENV;unset BASH_XTRACEFD;unset CDPATH;unset ENV;unset FCEDIT;unset FIGNORE;unset FUNCNEST;unset GLOBIGNORE;unset HISTCONTROL;unset HISTFILE;unset HISTFILESIZE;unset HISTIGNORE;unset HISTSIZE;unset HISTTIMEFORMAT;unset HOSTFILE;unset IGNOREEOF;unset INPUTRC;unset MAIL;unset MAILCHECK;unset MAILPATH;unset TMOUT;umask 022
		
		$(replicateBashFunctionsAndGlobalVariables)
	EOF
	
	cat >>"$continutationBinaryForChroot" <<-'EOF'
		
		# Fix up paths and variables
		LC_ALL=POSIX
		
		export PATH=/bin:/usr/bin:/sbin:/usr/sbin:/"$LFS_TOOLS"/bin
		LFS=
		LFS_SOURCES_PATH=/sources
		LFS_TOOLS_PATH=/"$LFS_TOOLS"
		LFS_LOG_PATH=/var/log/lfs/"$LFS_DISTRIBUTION_VERSION"
		
		mkdir -m 0755 -p "$LFS_LOG_PATH"/system
		
		setDebugging
		addNextTrapHandler removeFilesOnExit
		installPackages system
	EOF
	
	cp "$continutationBinaryForChroot" /tmp/XXXX
	
	mountVirtualFilesystems
	
	set +e
	/"$LFS_TOOLS"/bin/chroot "$LFS" /"$LFS_TOOLS"/bin/env -i HOME=/root TERM="$TERM" LC_ALL=POSIX PATH=/bin:/usr/bin:/sbin:/usr/sbin:/"$LFS_TOOLS"/bin /"$LFS_TOOLS"/bin/bash --login --noprofile +h /"$LFS_TOOLS"/sbin/lfs-chroot-install
	local -ir exitCode=$?
	set -e
	
	unmountVirtualFilesystems
	
	rm -rf -- "$continutationBinaryForChroot"
	
	cp --archive "$LFS"/var/log/lfs/"$LFS_DISTRIBUTION_VERSION"/* "$LFS_LOG_PATH"/ || true
	rm -rf -- "$LFS"/var/log/lfs
	
	if [ $exitCode -ne 0 ]; then
		exitError "chroot script failed with exit code $exitCode"
	fi
	
	# DESTDIR
}

function renderEarlyPathCommands()
{
	local -i index
	for (( index=0; index != ${#earlyPathCommands[@]}; index++ ))
	do
		eval ${earlyPathCommands[$index]}
	done
}

function renderLatePathCommands()
{
	# reverse order because of the append and immutable commands
	local -i index
	for (( index=${#latePathCommands[@]}-1; index != -1; index-- ))
	do
		eval ${latePathCommands[$index]}
	done
}

function sourceFunctionsAndSettings()
{
	echo nextSystemUid $nextSystemUid nextSystemUid
	echo HELLO_WORLD $HELLO_WORLD HELLO_WORLD
	
	local fileToSource
	pushd "$functionsPath" >/dev/null
		
		for fileToSource in *.functions
		do
			source "$fileToSource"
		done
		
	popd >/dev/null
	
	echo xnextSystemUid $nextSystemUid nextSystemUid
	echo xHELLO_WORLD $HELLO_WORLD HELLO_WORLD
	
	declare_for_chroot LFS_SETTINGS_HASH
	LFS_SETTINGS_HASH="$(sha224sum "$settingsPath" | awk 'NR==1 {print $1}')"
	source "$settingsPath"
	
	echo ynextSystemUid $nextSystemUid nextSystemUid
	echo yHELLO_WORLD $HELLO_WORLD HELLO_WORLD
}

function main()
{
	setDebugging
	findOurNameAndPath
	ensureWhichInstalled
	parseCommandLine "$@"
	
	setPathsAndExports
	sourceFunctionsAndSettings
	
	echo nextSystemUid $nextSystemUid nextSystemUid
	echo aHELLO_WORLD $HELLO_WORLD HELLO_WORLD
	
	addNextTrapHandler removeFilesOnExit
	
	echo nextSystemUid $nextSystemUid nextSystemUid
	echo bHELLO_WORLD $HELLO_WORLD HELLO_WORLD
	
	verifyHostSystemRequirements
	
	echo nextSystemUid $nextSystemUid nextSystemUid
	echo cHELLO_WORLD $HELLO_WORLD HELLO_WORLD
	
	include_mirrors
	
	echo nextSystemUid $nextSystemUid nextSystemUid
	echo dHELLO_WORLD $HELLO_WORLD HELLO_WORLD
	
	include_profiles
	
	echo nextSystemUid $nextSystemUid nextSystemUid
	echo eHELLO_WORLD $HELLO_WORLD HELLO_WORLD
		
	# Suspended for now, as we are using --cacert instead of --capath
	#rehashCertificateAuthorities
	
	createSkeletonFolderStructure
	downloadCertificateAuthorities
	downloadSignatures
	downloadKeyrings
	downloadKeys
	downloadSources
	downloadPatches
	
	createOrUseBackUpToolchain
	
	runSystemInstallationLogic renderEarlyPathCommands
	chrootToEnvironment
	runSystemInstallationLogic renderLatePathCommands
	
	removeFilesOnExit
}

main "$@"
