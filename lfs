#!/bin/bash -
set +o allexport -o braceexpand +o emacs -o errexit +o errtrace +o functrace +o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword +o monitor +o noclobber +o noexec +o noglob +o nolog +o notify +o nounset +o onecmd +o physical +o pipefail +o posix +o verbose +o vi +o xtrace;unset BASH_ENV;unset BASH_XTRACEFD;unset CDPATH;unset ENV;unset FCEDIT;unset FIGNORE;unset FUNCNEST;unset GLOBIGNORE;unset HISTCONTROL;unset HISTFILE;unset HISTFILESIZE;unset HISTIGNORE;unset HISTSIZE;unset HISTTIMEFORMAT;unset HOSTFILE;unset IGNOREEOF;unset INPUTRC;unset MAIL;unset MAILCHECK;unset MAILPATH;unset TMOUT;umask 022

function declare_for_chroot()
{
	if [ $# -eq 1 ]; then
		# Done this way to avoid a Core Dump!
		local -r variable="$1"
		eval $variable=
	else
		local -r flags="$1"
		local -r variable="$2"
		declare ${flags}g $variable
	fi
	
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=($variable)
}

function redeclare_array_for_chroot()
{
	local -r variable="$1"
	declare -a $variable
	LFS_ARRAY_VARIABLES_TO_REDECLARE_IN_CHROOT+=($variable)
}

declare_for_chroot -a LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT
declare_for_chroot INSTALLATION_FAILED_MESSAGE

declare_for_chroot -a LFS_ARRAY_VARIABLES_TO_REDECLARE_IN_CHROOT
redeclare_array_for_chroot trapHandlers
redeclare_array_for_chroot filesToRemoveOnExit

# Defensive
declare_for_chroot FUNCNEST
FUNCNEST=40

function ensureWhichInstalled()
{
	set +e
	which
	local -ir exitCode=$?
	set -e
	if [ $exitCode = 127 ]; then
		exitError "Program which does not exist on path $PATH"
	fi
}

function essentialProgramCheck()
{
	# This nasty hack exists because source'd files override the set -xxxx options!
	set -e
	
	local program
	for program in "$@"
	do
		if ! which "$program" 1>/dev/null 2>/dev/null; then
			warning "Program $program does not exist on path $PATH"
			return 100
		fi
	done
}

# The purpose of these functions is to provide internal implementations of logic we can't be 100%
# sure of exists in the environment or is implemented as we would like for critical pieces of code.
# Such a critical piece is code executed before and during command line arg parsing (eg exitError)
# They will usually be MUCH slower than their external equivalents
function purebash_dirname()
{
	local -r converted="${1%/*}"
	if [ "$converted" = "$1" ]; then
		echo "."
	else
		echo "$converted"
	fi
}

function purebash_basename()
{
	echo "${1##*/}"
}

function exitError()
{
	local -r error="$1"
	echo "$ourName: $error" 1>&2
	exit 1
}

function warning()
{
	if [ $# -ne 1 ]; then
		exitError "Incorrect arguments"
	fi
	
	echo "$ourName: WARNING: $1" 1>&2
}

function setDebugging()
{
	# is set -x on?
	if [[ "$-" == *x* ]]; then
		export LFS_BASH_DEBUGGING="yes"
		LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('LFS_BASH_DEBUGGING')
	elif [ ! -z "$LFS_BASH_DEBUGGING" ]; then
		if [ "$LFS_BASH_DEBUGGING" = "yes" ]; then
			set -x
		fi
		LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('LFS_BASH_DEBUGGING')
	fi
}

function findOurNameAndPath()
{
	readonly ourName="$(purebash_basename "$0")"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('ourName')
	pushd "$(purebash_dirname "$0")" >/dev/null
	readonly crudeOurPath="$(pwd)"
	popd >/dev/null
}

function executeWithCleanEnvironment()
{
	essentialProgramCheck env sudo
	exec env -i HOME="$HOME" TERM="$TERM" PATH="/sbin:/bin:/usr/sbin:/usr/bin" LFS_BASH_DEBUGGING="$LFS_BASH_DEBUGGING" LFS_CLEAN_ENVIRONMENT='yes' sudo -E -p "Password required to run as root: " -- "$crudeOurPath"/"$ourName" $@
}

function exitHelp()
{
	echo -n -E "Usage: ${ourName} -h
Usage: ${ourName} -d distribution [-l lfsPath] [-c lfsConfigPath] [-m mirrors] [-1 crosscompilerProfile] [-2 toolchain2Profile] [-o option] -- [profiles ...]

Profiles
[profiles ...] lists one or more system profiles to create. These are snippets of simplified bash
script, that install and build from source what would be called packages on other systems.

If no profile is specified, then the baseline 'lfs' profile is used.

profiles are executed in the order listed. Internally, a profile may reference (source)
another profile it depends on. This is the equivalent of package management on other
systems. A set of profiles is intended to be version-controlled using a source control system
such as git and so do not declare explicit version dependencies.

The profiles 'crosscompiler' and 'toolchain2' are special. Implementors of profiles can assume
that these profiles are always sourced. It is an error to specify them in the list of profiles.

A profile does not have to just install packages.

Profiles may be suffixed with [distribution] to target a particular distribution.

Defaults
    distribution       ${LFS_DISTRIBUTION_VERSION}
    lfsPath            ${lfsPath}
    lfsConfigPath      ${lfsConfigPath}
    mirrors            ${mirrors}
    crosscompilerProfile  ${crosscompilerProfile}
    toolchain2Profile  ${toolchain2Profile}
    option             See below
    profiles           ${profiles}

A mirror defines mirror URLs. If a mirror is 'timezone', then timezone settings used to determine the actual mirrors.
If Etc/UTC or something similar is the timezone, then the 'language' mirrors are used. These use the LC_CTYPE,
LANG and LANGUAGE environment variables in order. The 'global' mirror can be specified to override this. A list of mirrors
is in <lfsConfigPath>/mirrors . Conversions from timezone and language are controlled using <lfsConfigPath>/timezones-to-mirrors.map
and <lfsConfigPath>/languages-to-mirrors.map respectively. Note that some mirrors, eg for the UK, are incomplete and source
the global mirrors first to provide defaults. mirrors may be symlinks.

At this time we don't support the metalink (.meta4) protocol for mirrors (as it requires additional
runtime dependencies).

Options
For options, prefix with either 'yes-' to turn it on
or 'no-' to turn it off. For example, to turn on 'skip-signature-checks' :-

    ${ourName} -o yes-skip-signature-checks

-o may be repeated as necessary. Options are evaluated in left-to-right order.
Last setting wins.

Options are as follows:-   Default
    skip-signature-checks  ${skipSignatureChecks}
" 1>&2
	exit $1
}

function parseCommandLine()
{
	# Defaults
	LFS_DISTRIBUTION_VERSION="7.4"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('LFS_DISTRIBUTION_VERSION')
	
	lfsPath="/var/tmp/lfs"
	
	lfsConfigPath="${crudeOurPath}/config"
	
	mirrors="timezone"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('mirrors')
	
	crosscompilerProfile=crosscompiler
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('crosscompilerProfile')
	
	toolchain2Profile=toolchain2
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('toolchain2Profile')
	
	skipSignatureChecks="no"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('skipSignatureChecks')
	
	profiles="system"
	LFS_GLOBAL_VARIABLES_TO_EXPORT_TO_CHROOT+=('profiles')
	
	if [ "$LFS_CLEAN_ENVIRONMENT" != "yes" ]; then
		executeWithCleanEnvironment "$@"
	else
		local OPTERR=1
		local OPTIND=1
		local OPTARG
		local option
		while getopts :hl:d:m:1:2:o: option
		do
			case "$option" in
				
				h)
					exitHelp 2
				;;
				
				d)
					LFS_DISTRIBUTION_VERSION="$OPTARG"
				;;
				
				l)
					lfsPath="$OPTARG"
				;;
				
				c)
					lfsConfigPath="$OPTARG"
				;;
				
				m)
					mirrors="$OPTARG"
				;;
				
				1)
					crosscompilerProfile="$OPTARG"
				;;
				
				2)
					toolchain2Profile="$OPTARG"
				;;
				
				o)
					if [ -z "$OPTARG" ]; then
						exitError "Invalid option -o requires an argument"
					fi
				
					case "$OPTARG" in
						
						no-skip-signature-checks)
							skipSignatureChecks="no"
						;;
						
						yes-skip-signature-checks)
							skipSignatureChecks="yes"
						;;
						
						*)
							exitError "Invalid option -o ${OPTARG}"
						;;
						
					esac
				;;
				
				'?')
					exitError "Invalid option -${OPTARG}"
				;;
				
			esac
		done
		
		shift $((OPTIND - 1))
		if [ $# -ne 0 ]; then
			profiles="$@"
		fi
		
		if [ -z "$LFS_DISTRIBUTION_VERSION" ]; then
			exitError "Please specify a distribution using -d"
		fi
	fi
}

function setPaths()
{
	essentialProgramCheck mkdir awk
	
	if [ ! -d "$lfsConfigPath" ]; then
		exitError "Config path $lfsConfigPath does not exist or is not a directory"
	fi
	pushd "$lfsConfigPath">/dev/null
	lfsConfigPath="$(pwd)"
	popd >/dev/null
	
	readonly distributionConfigPath="$lfsConfigPath"/"$LFS_DISTRIBUTION_VERSION"
	if [ ! -d "$distributionConfigPath" ]; then
		exitError "distribution config path $distributionConfigPath does not exist or is not a directory"
	fi
	
	readonly certificateAuthoritiesPath="$distributionConfigPath"/certificate-authorities
	if [ ! -d "$certificateAuthoritiesPath" ]; then
		exitError "certificate-authorities path $certificateAuthoritiesPath does not exist or is not a directory"
	fi
	
	readonly mirrorsPath="$distributionConfigPath"/mirrors
	if [ ! -d "$mirrorsPath" ]; then
		exitError "Mirrors path $mirrorsPath does not exist or is not a directory"
	fi
	
	readonly gpghomePath="$distributionConfigPath"/gpghome
	if [ ! -d "$gpghomePath" ]; then
		exitError "gpghome path $gpghomePath does not exist or is not a directory"
	fi
	
	readonly keyringsPath="$distributionConfigPath"/keyrings
	if [ ! -d "$keyringsPath" ]; then
		exitError "Keyrings path $keyringsPath does not exist or is not a directory"
	fi
	
	readonly keysPath="$distributionConfigPath"/keys
	if [ ! -d "$keysPath" ]; then
		exitError "Keys path $keysPath does not exist or is not a directory"
	fi
	
	readonly signaturesPath="$distributionConfigPath"/signatures
	if [ ! -d "$signaturesPath" ]; then
		exitError "Signatures path $signaturesPath does not exist or is not a directory"
	fi
	
	readonly recipesPath="$distributionConfigPath"/recipes
	if [ ! -d "$recipesPath" ]; then
		exitError "Recipes path $recipesPath does not exist or is not a directory"
	fi
	
	readonly recipesPackageUidFile="$recipesPath"/package-uid
	if [ ! -f "$recipesPackageUidFile" ]; then
		exitError "package-uid file $recipesPackageUidFile does not exist or is not a file"
	fi
	
	readonly includesPath="$distributionConfigPath"/includes
	if [ ! -d "$includesPath" ]; then
		exitError "includes path $includesPath does not exist or is not a directory"
	fi
	
	readonly functionsPath="$distributionConfigPath"/functions
	if [ ! -d "$includesPath" ]; then
		exitError "functions path $functionsPath does not exist or is not a directory"
	fi
	
	readonly settingsPath="$distributionConfigPath"/settings
	if [ ! -d "$settingsPath" ]; then
		exitError "settings path $settingsPath does not exist or is not a directory"
	fi
	
	if [ ! -d "$lfsPath" ]; then
		mkdir -m 0755 -p "$lfsPath"
	fi
	pushd "$lfsPath">/dev/null
	lfsPath="$(pwd)"
	popd >/dev/null
	
	readonly lfsLogPath=/var/log/lfs/"$LFS_DISTRIBUTION_VERSION"
	readonly lfsDownloadsPath="$lfsPath"/downloads
	readonly lfsExtractsPath="$lfsPath"/extracts
	
	LFS="$lfsPath"/"$LFS_DISTRIBUTION_VERSION"
}

function createSkeletonFolderStructure()
{
	mkdir -m 0755 -p "$LFS"
	
	# Logs
	mkdir -m 0755 -p "$lfsLogPath"
	rm -rf "$lfsLogPath"/*
	
	readonly downloadsLogsPath="$lfsLogPath"/downloads
	mkdir -m 0755 -p "$downloadsLogsPath"
}

function installPackageSkip()
{
	:
}

function installPackage()
{
	LFS_DEPENDENCY_PATH="${dependency_Path["$LFS_DEPENDENCY_KEY"]}"
	LFS_DEPENDENCY_RELATIVE_PATH="${dependency_RelativePath["$LFS_DEPENDENCY_KEY"]}"
	LFS_DEPENDENCY_RECIPE_SETTINGS_DEPENDENCIES="${dependency_RecipeSettingsDependencies["$LFS_DEPENDENCY_KEY"]}"
	LFS_DEPENDENCY_PREFIX_PATH="$LFS_DEPENDENCY_PATH"/install
	
	pathToRootOfChroot "$LFS_DEPENDENCY_PREFIX_PATH"
	LFS_DEPENDENCY_RELATIVE_PATH_TO_ROOT_FROM_INSTALL_FOLDER="$PathToRoot"
	
	LFS_DEPENDENCY_SKIP_INSTALL="${dependency_SkipInstall["$LFS_DEPENDENCY_KEY"]}"
	
	if [ "$LFS_PHASE" = "system" ]; then
		LFS_DEPENDENCY_ROOT=""
	else
		LFS_DEPENDENCY_ROOT="$LFS"
	fi
	LFS_DEPENDENCY_PACKAGE_PATH="${LFS_DEPENDENCY_ROOT}${LFS_DEPENDENCY_PATH}"
	LFS_DEPENDENCY_INSTALL_PATH="$LFS_DEPENDENCY_PACKAGE_PATH"/install
	LFS_DEPENDENCY_BINPATH_PATH="$LFS_DEPENDENCY_PACKAGE_PATH"/binpath
	LFS_DEPENDENCY_SOURCE_PATH="$LFS_DEPENDENCY_PACKAGE_PATH"/source
	LFS_DEPENDENCY_LOG_PATH="$LFS_DEPENDENCY_PACKAGE_PATH"/log
	LFS_DEPENDENCY_INSTALLED_PATH="$LFS_DEPENDENCY_PACKAGE_PATH"/installed
	
	if [ -f "$LFS_DEPENDENCY_INSTALLED_PATH" ]; then
		progressMessage "Skipping phase $LFS_PHASE dependency $LFS_DEPENDENCY_NAME version $LFS_DEPENDENCY_VERSION"
		
		installPackagePathBinariesToPath
		
		progressMessageSucceeded
		return 0
	fi
	
	local -r installer_versioned=install_${LFS_PHASE}_${LFS_DEPENDENCY_NAME}_${LFS_DEPENDENCY_VERSION}
	local -r installer_unversioned=install_${LFS_PHASE}_${LFS_DEPENDENCY_NAME}
	
	local -r logPathPrefix="$LFS_DEPENDENCY_LOG_PATH"
	local -r installStdOutLogFile="$LFS_DEPENDENCY_LOG_PATH"/install.stdout.log
	local -r installStdErrLogFile="$LFS_DEPENDENCY_LOG_PATH"/install.stderr.log
	local -i exitCode
	
	progressMessage "Installing phase $LFS_PHASE dependency $LFS_DEPENDENCY_NAME version $LFS_DEPENDENCY_VERSION"
	
	# Skip installer
	if [ "$LFS_DEPENDENCY_SKIP_INSTALL" = "1" ]; then
		local -r installer="installPackageSkip"
		if type "$installer_versioned" &>/dev/null; then
			progressMessageFailed "A skip installer should not have an installer function"
		elif type "$installer_unversioned" &>/dev/null; then
			progressMessageFailed "A skip installer should not have an installer function"
		fi
	else
		# Use an override (versioned) installer, otherwise the default
		if type "$installer_versioned" &>/dev/null; then
			local -r installer="$installer_versioned"
		elif type "$installer_unversioned" &>/dev/null; then
			local -r installer="$installer_unversioned"
		else
			progressMessageFailed "No installer $installer_versioned or $installer_unversioned defined"
		fi
	fi
	
	installPerPackageFhs
	
	pushd "$LFS_DEPENDENCY_SOURCE_PATH" >/dev/null
		
		INSTALLATION_FAILED_MESSAGE="failed, logs in $LFS_DEPENDENCY_LOG_PATH/install.*.log"
		addInstallationFailedTrapHandler
		
			exec 6>&1 1>"$installStdOutLogFile"
			exec 7>&2 2>"$installStdErrLogFile"
		
				local -i index
				count=0
				for index in ${dependency_SourcePackageIndices["$LFS_DEPENDENCY_KEY"]}
				do
					setLfsSourcePackageVariables $index
			
					if [ -z "$LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER" ]; then
						# May fail because the names are the same, there's more than one file, $LFS_SOURCE_PACKAGE_NAME is $LFS_DEPENDENCY_NAME etc. Done for convenience
						ln -s "$LFS_SOURCE_PACKAGE_FILENAME" "$LFS_SOURCE_PACKAGE_NAME" 2>/dev/null || true
						if [ $count -eq 0 ]; then
							ln -s "$LFS_SOURCE_PACKAGE_FILENAME" "$LFS_DEPENDENCY_NAME" 2>/dev/null || true
						fi
					else
						if [ -d "$lfsExtractsPath"/"$LFS_SOURCE_PACKAGE_MIRROR"/"$LFS_SOURCE_PACKAGE_RELATIVE_PATH".decompressed ]; then
							tarExtract "$LFS_SOURCE_PACKAGE_FILENAME" "$LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER" "" "$LFS_SOURCE_PACKAGE_IS_TARBOMB"
						else
							tarExtract "$LFS_SOURCE_PACKAGE_FILENAME" "$LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER" "$LFS_SOURCE_PACKAGE_COMPRESSION" "$LFS_SOURCE_PACKAGE_IS_TARBOMB"
						fi

						# May fail because the names are the same, there's more than one file, $LFS_SOURCE_PACKAGE_NAME is $LFS_DEPENDENCY_NAME etc. Done for convenience
						ln -s "$LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER" "$LFS_SOURCE_PACKAGE_NAME" 2>/dev/null || true
						if [ $count -eq 0 ]; then
							ln -s "$LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER" "$LFS_DEPENDENCY_NAME" 2>/dev/null || true
						fi
					fi
					
					let count=count+1
				done

				local patchSourcePackageName
				local patchSourcePackageVersion
				local pathCorrection
				for index in $LFS_DEPENDENCY_PATCHES
				do
					setLfsSourcePackageVariables ${patches_SourcePackageIndex[$index]}

					if [ ! -z "$LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER" ]; then
						pushd "$LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER" >/dev/null
						pathCorrection=".."
					else
						pathCorrection="."
					fi
					
					echo "Applying patch ${patches_FileName[$index]}"
					if ! sudo -u \#${LFS_DEPENDENCY_UID} -g \#${LFS_DEPENDENCY_GID} patch -Np1 -i "$pathCorrection"/"${patches_FileName[$index]}"; then
						exit 100
					fi
				
					if [ ! -z "$LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER" ]; then
						popd >/dev/null
					fi
				done
				
				executeFunctionUnderSudo $installer
				
				lockDownPermissions
				setOtherExecutableBinaries
				setSetuidBinaries
				setSetgidBinaries
				installBinariesToPackagePath
				installPackagePathBinariesToPath
				
			exec 1>&6 6>&-
			exec 2>&7 7>&-
			
		removeLastTrapHandler
		
	popd >/dev/null
	
	touch "$LFS_DEPENDENCY_INSTALLED_PATH"
	lockDownPackage 1>>"$installStdOutLogFile" 2>>"$installStdErrLogFile"
	
	progressMessageSucceeded
}

function removeAnyFailedPackagesFromPreviousRuns()
{
	local optPath="$LFS"/opt/lfs/"$LFS_DISTRIBUTION_VERSION"
	local phaseFolder
	local dependencyName
	local dependencyVersion
	local dependencyHashes
	
	pushd "$optPath" >/dev/null
		for phaseFolder in *
		do
			if [ ! -e "$phaseFolder" ]; then
				continue
			fi
			
			if [ ! -d "$phaseFolder" ]; then
				continue
			fi
			
			pushd "$phaseFolder" >/dev/null
				for dependencyName in *
				do
					if [ ! -e "$dependencyName" ]; then
						continue
					fi
		
					if [ ! -d "$dependencyName" ]; then
						continue
					fi
					
					pushd "$dependencyName" >/dev/null
						for dependencyVersion in *
						do
							if [ ! -e "$dependencyVersion" ]; then
								continue
							fi
							
							if [ "$dependencyVersion" = "current" ]; then
								if [ ! -e "$(readlink current)" ]; then
									rm -f current
									continue
								fi
							fi
		
							if [ ! -d "$dependencyVersion" ]; then
								continue
							fi
					
							pushd "$dependencyVersion" >/dev/null
								for dependencyHashes in *
								do
									if [ ! -e "$dependencyHashes" ]; then
										continue
									fi
		
									if [ ! -d "$dependencyHashes" ]; then
										continue
									fi
									
									if [ -f "$dependencyHashes"/installed ]; then
										continue
									fi
									
									chattr -R -ai "$dependencyHashes" 2>/dev/null || true
									rm -rf "$dependencyHashes"
									if [ -L current ]; then
										if [ ! -e "$(readlink current)" ]; then
											rm -f current
										fi
									fi
									if [ -L recipe-settings-dependencies ]; then
										if [ ! -e "$(readlink recipe-settings-dependencies)" ]; then
											rm -f recipe-settings-dependencies
										fi
									fi
									
								done
							popd  >/dev/null
							
							if [ "$dependencyVersion" = "current" ]; then
								if [ ! -e "$(readlink current)" ]; then
									rm -f current
									continue
								fi
							fi
							
						done
					popd  >/dev/null
					
				done
			popd  >/dev/null
			
		done
	popd  >/dev/null
	
	find "$optPath" -depth -mindepth 1 -maxdepth 4 -type d -empty -delete
}

function calculateDependencyPaths()
{
	for LFS_PHASE in crosscompiler toolchain2 system
	do
		for LFS_DEPENDENCY_KEY in ${phase_InstallationOrder["${LFS_PHASE}"]}
		do
			LFS_DEPENDENCY_NAME="${dependency_Name["$LFS_DEPENDENCY_KEY"]}"
			LFS_DEPENDENCY_VERSION="${dependency_Version["$LFS_DEPENDENCY_KEY"]}"
			LFS_DEPENDENCY_RECIPE_HASH="${dependency_RecipeHash["$LFS_DEPENDENCY_KEY"]}"
			LFS_DEPENDENCY_INCLUDE_HASH="${dependency_IncludeHash["$LFS_DEPENDENCY_KEY"]}"
			LFS_DEPENDENCY_SETTINGS_HASH="${dependency_SettingsHash["$LFS_DEPENDENCY_KEY"]}"
	
			LFS_DEPENDENCY_USER=lfs-"$LFS_DEPENDENCY_NAME"
			LFS_DEPENDENCY_GROUP="$LFS_DEPENDENCY_USER"
			LFS_DEPENDENCY_UID=${dependency_UidGid["$LFS_DEPENDENCY_KEY"]}
			LFS_DEPENDENCY_GID=$LFS_DEPENDENCY_UID
			
			LFS_DEPENDENCY_PATCHES="${dependency_PatchIndices["$LFS_DEPENDENCY_KEY"]}"

			dependencyToPath
		done
	done
}

function installPackages()
{
	LFS_PHASE="$1"
	
	prepareZzzLfsPath
	
	if [ -f "$LFS_DEPENDENCY_INSTALLED_PATH_ZZZ" ]; then
		progressMessage "All dependencies for phase $LFS_PHASE installed"
		progressMessageSucceeded
		return 0
	fi
	
	prepareMuslCrossPath
	
	for LFS_DEPENDENCY_KEY in ${phase_InstallationOrder["${LFS_PHASE}"]}
	do
		LFS_DEPENDENCY_NAME="${dependency_Name["$LFS_DEPENDENCY_KEY"]}"
		LFS_DEPENDENCY_VERSION="${dependency_Version["$LFS_DEPENDENCY_KEY"]}"
		LFS_DEPENDENCY_RECIPE_HASH="${dependency_RecipeHash["$LFS_DEPENDENCY_KEY"]}"
		LFS_DEPENDENCY_INCLUDE_HASH="${dependency_IncludeHash["$LFS_DEPENDENCY_KEY"]}"
		LFS_DEPENDENCY_SETTINGS_HASH="${dependency_SettingsHash["$LFS_DEPENDENCY_KEY"]}"
	
		LFS_DEPENDENCY_USER=lfs-"$LFS_DEPENDENCY_NAME"
		LFS_DEPENDENCY_GROUP="$LFS_DEPENDENCY_USER"
		LFS_DEPENDENCY_UID=${dependency_UidGid["$LFS_DEPENDENCY_KEY"]}
		LFS_DEPENDENCY_GID=$LFS_DEPENDENCY_UID
		
		LFS_DEPENDENCY_PATCHES="${dependency_PatchIndices["$LFS_DEPENDENCY_KEY"]}"
		
		lfs_dependency_includes
		
		installPackage
	done
}

function stripToolchainSymbolsAfterToolchain2()
{
	if [ "$stripToolchainSymbols" = "yes" ]; then
		set +e
		# Fails for /tools/lib/thread2.7.0/libthread2.7.0.so
		find /"$LFS_TOOLS"/lib -type f \( -name '*.a' -o -name '*.o' -o \( -name '*.so*' -a ! -name '*.py' \) \) -print0 | xargs --null file --print0 --separator ' ' | awk -v IRS=$'\0' -v ORS=$'\0' '$2 ~/ELF|current/ {print $1}' | xargs --null strip --verbose --strip-debug
		find /"$LFS_TOOLS"/{,s}bin -type f -executable -print0 | xargs --null file --print0 --separator ' ' | awk -v IRS=$'\0' -v ORS=$'\0' '$2 ~/ELF/ {print $1}' | xargs --null strip --verbose --strip-unneeded
		set -e
	fi
}

function backUpToolchain()
{
	if which rsync 1>/dev/null 2>/dev/null; then
		progressMessage "Backing up toolchain using rsync to $toolsBackUpPath"
		mkdir -m 0755 -p "$toolsBackUpPath"
		if rsync --verbose --archive --hard-links --acls --xattrs --delete-after --force --numeric-ids --fake-super --link-dest="$toolsBackUpPath" "$LFS_TOOLS_PATH"/ "$toolsBackUpPath"/ 1>"$lfsLogPath"/toolchain.backup.stdout.log 2>"$lfsLogPath"/toolchain.backup.stderr.log; then
			progressMessageSucceeded
		else
			progressMessageFailed "check logs in $lfsLogPath/toolchain.backup.*.log"
		fi
	fi
	
	progressMessage "Tarballing up toolchain using tar/gz to $toolsBackUpPath.tar.gz"
	tar --create --owner=root --group=root --sparse --posix --directory "$LFS" "$LFS_TOOLS" | gzip -9 >"$toolsBackUpPath".tar.gz
	progressMessageSucceeded
}

function createToolchain()
{
	installPackages crosscompiler
	installPackages toolchain2
	
	progressMessage "Stripping toolchain symbols ($stripToolchainSymbols)"
	stripToolchainSymbolsAfterToolchain2 1>"$"$lfsLogPath""/toolchain2_strip-symbols.stdout.log 2>/toolchain2_strip-symbols.stderr.log
	progressMessageSucceeded
	
	backUpToolchain
}

function cleanUpTarget()
{
	if [ ! -d "$LFS" ]; then
		return 0
	fi
	
	progressMessage "Cleaning up target $LFS"
	
		chattr -R -f -aiD "$LFS" 1>"$lfsLogPath"/system_chattr-cleanup.stdout.log 2>"$lfsLogPath"/system_chattr-cleanup.stderr.log || true
		
		pushd "$LFS" >/dev/null
		
			local file
			for file in *
			do
				case "$file" in
					
					dev|proc|sys|sources|$LFS_TOOLS|$LFS_TOOLS.backup|$LFS_TOOLS.backup.*)
						:
					;;
				
					*)
						if ! rm -rf -- "$file"; then
							progressMessageFailed "could not remove $file"
						fi
					;;
				
				esac
			done
			
			if [ -d dev ]; then
				
				pushd dev >/dev/null
				
					for file in *
					do
						if [ ! -f "$file" ]; then
							if ! rm -rf -- "$file"; then
								progressMessageFailed "could not remove dev/$file"
							fi
						fi
					done
					
				popd >/dev/null
				
			fi
			
			if [ -d sources ]; then
				
				pushd sources >/dev/null
				
					for file in *
					do
						if [ ! -f "$file" ]; then
							if ! rm -rf -- "$file"; then
								progressMessageFailed "could not remove sources/$file"
							fi
						fi
					done
					
				popd >/dev/null
				
			fi
			
		popd >/dev/null
		
	progressMessageSucceeded
}

function createOrUseBackUpToolchain()
{
	if [ -d "$toolsBackUpPath" ] && which rsync 1>/dev/null 2>/dev/null; then
		cleanUpTarget
		progressMessage "Restoring toolchain using rsync ($LFS_TOOLS)"
			mkdir -m 0755 -p "$LFS_TOOLS_PATH"
			
			if ! rsync --verbose --archive --hard-links --acls --xattrs --delete-after --force --numeric-ids --fake-super --link-dest="$LFS_TOOLS_PATH" "$toolsBackUpPath"/ "$LFS_TOOLS_PATH"/ 1>"$lfsLogPath"/toolchain.restore.stdout.log 2>"$lfsLogPath"/toolchain.restore.stderr.log; then
				progressMessageFailed "check logs in $lfsLogPath/toolchain.restore.*.log"
			fi
			changeOwnerOfToolchain
		progressMessageSucceeded
		
	elif [ -f "$toolsBackUpPath".tar.gz ]; then
		cleanUpTarget
		progressMessage "Restoring toolchain using tarball ($LFS_TOOLS)"
			rm -rf -- "$LFS_TOOLS_PATH"
			
			pushd "$LFS"/.. >/dev/null
				if ! tar --extract --gzip --file "$toolsBackUpPath".tar.gz 1>"$lfsLogPath"/toolchain.restore.stdout.log 2>"$lfsLogPath"/toolchain.restore.stderr.log; then
					progressMessageFailed "check logs in $lfsLogPath/toolchain.restore.*.log"
				fi
			popd >/dev/null
			changeOwnerOfToolchain
		progressMessageSucceeded
	else
		createToolchain
	fi
}

function runSystemInstallationLogic()
{
	local -r callback="$1"
	
	local -r stdoutLog="$lfsLogPath"/system_"$callback".stdout.log
	local -r stderrLog="$lfsLogPath"/system_"$callback".stderr.log
	
	progressMessage "Phase system, executing $callback on target"
		
		INSTALLATION_FAILED_MESSAGE="logs in $phase/$callback.*.log"
		addInstallationFailedTrapHandler
			
			exec 6>&1 1>"$stdoutLog"
			exec 7>&2 2>"$stderrLog"
				
				set -x
				# FORCE_UNSAFE_CONFIGURE=1 allows configure to run as root
				FORCE_UNSAFE_CONFIGURE=1 $callback
				set +x
				
			exec 1>&6 6>&-
			exec 2>&7 7>&-
			
		removeLastTrapHandler
		
	progressMessageSucceeded
}

function renderEarlyPathCommands()
{
	local -i index
	for (( index=0; index != ${#earlyPathCommands[@]}; index++ ))
	do
		eval ${earlyPathCommands[$index]}
	done
}

function renderLatePathCommands()
{
	# reverse order because of the append and immutable commands
	local -i index
	for (( index=${#latePathCommands[@]}-1; index != -1; index-- ))
	do
		eval ${latePathCommands[$index]}
	done
}

function sourceFunctions()
{
	local fileToSource
	pushd "$functionsPath" >/dev/null
		
		for fileToSource in *.functions
		do
			source "$fileToSource"
		done
		
	popd >/dev/null
}

function main()
{
	setDebugging
	findOurNameAndPath
	ensureWhichInstalled
	parseCommandLine "$@"
	setPaths
	sourceFunctions
	
	doSets
	
	initialiseTraps
	
	verifyHostSystemRequirementsUsingDependencyChecks
	
	doInclude
		
	# Suspended for now, as we are using --cacert instead of --capath
	#rehashCertificateAuthorities
	
	createSkeletonFolderStructure
	
	doDownloads
	
	installEssentialFolderStructure
	
	removeAnyFailedPackagesFromPreviousRuns
	
	calculateDependencyPaths
	
	createOrUseBackUpToolchain
	
	runSystemInstallationLogic renderEarlyPathCommands
	
	chrootToEnvironment
	
	runSystemInstallationLogic renderLatePathCommands
}

main "$@"
