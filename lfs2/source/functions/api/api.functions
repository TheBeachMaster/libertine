function api_download()
{
	local -r downloadKind="$1"
	local -r downloadName="$2"
	local -r downloadVersion="$3"
	api_download_kind="$downloadKind"
	api_download_index=${#api_downloads_name[@]}
	# there is the possibility of collision (eg autotools)
	# normally this is wanted, although in those circumstances we should distinguish by mirror, path (and for packages, version)
	api_downloads_name+=("$downloadName")
	api_downloads_version[$api_download_index]="$downloadVersion"
	api_downloads_kinds[$api_download_index]="$downloadKind"
	
	api_downloads_mirror[$api_download_index]=""
	api_downloads_path[$api_download_index]=""
	
	api_downloads_referrer[$api_download_index]=""
	api_downloads_post_data[$api_download_index]=""
	
	api_downloads_archive[$api_download_index]="none"
	api_downloads_compression[$api_download_index]="none"
	api_downloads_tarbomb[$api_download_index]="no"
	api_downloads_archive_folder[$api_download_index]=""
	api_downloads_download_as[$api_download_index]=""
	
	api_downloads_size[$api_download_index]=-1
	api_downloads_md5[$api_download_index]=""
	api_downloads_sha1[$api_download_index]=""
	api_downloads_sha224[$api_download_index]=""
	api_downloads_sha256[$api_download_index]=""
	api_downloads_sha384[$api_download_index]=""
	api_downloads_sha512[$api_download_index]=""
	api_downloads_signed_as[$api_download_index]="none"
	api_downloads_signed_id[$api_download_index]=""
	api_downloads_signed_signatureFile[$api_download_index]=""
}

function api_verifyOneArgument()
{
	if [ $1 -ne 1 ]; then
		lfs_exitError "Please specify exactly one argument"
	fi
}

function mirror()
{
	api_verifyOneArgument $#
	
	api_downloads_mirror[$api_download_index]="$1"
}

function path()
{
	api_verifyOneArgument $#
	local -r relativePath="$1"
	api_downloads_path[$api_download_index]="$relativePath"

	# the defaults for these vary with the kind of resource in use
	case "$api_download_kind" in
		
		certificate-authority|patch|file|keyring|keyfile)
			local -r compressionExtension="${ourFileName##*.}"
			api_downloads_archive[$api_download_index]=file

			if [ -z "$compressionExtension" ]; then
				local -r ourCompression=none
			else
				case "$compressionExtension" in
					Z)
						# eg gzip downloads
						local -r ourCompression=compress
					;;
		
					gz)
						local -r ourCompression=gzip
					;;
		
					bz)
						local -r ourCompression=bzip2
					;;
	
					bz2)
						local -r ourCompression=bzip2
					;;
		
					# A faster compressor still is lz4
					lzo)
						local -r ourCompression=lzop
					;;
		
					lz)
						local -r ourCompression=lzip
					;;
		
					lzma)
						local -r ourCompression=lzma
					;;
		
					xz)
						local -r ourCompression=xz
					;;
		
					*)
						local -r ourCompression=none
					;;
				esac
			fi
			api_downloads_archive_folder[$api_download_index]=""
			api_downloads_compression[$api_download_index]="$ourCompression"
		;;
		
		package)
			local -r ourFileName="$(lfs_basename "$relativePath")"
			local -r compressionExtension="${ourFileName##*.}"
			local -r withoutCompressionExtension="${ourFileName%.*}"
			if [ -z "$compressionExtension" ]; then
				local -r ourArchive="none"
				local -r ourArchiveFolder="$withoutCompressionExtension"
			else
				case "$compressionExtension" in
				
					# The various abominations are also slackware packages (txz, tgz especially)
					tar|tgz|tbz|tbz2|txz|tlz|tlzma|tz|taz)
						local -r ourArchive="tarball"
						local -r ourArchiveFolder="$withoutCompressionExtension"
					;;
					
					zip)
						local -r ourArchive="zip"
						local -r ourArchiveFolder="$withoutCompressionExtension"
					;;
					
					*)
						local -r ourArchive="tarball"
						local -r ourArchiveFolder="${withoutCompressionExtension%.*}"
					;;
				
				esac
			fi
			case "$compressionExtension" in
				tar)
					local -r ourCompression=none
				;;
				
				zip)
					local -r ourCompression=none
				;;
		
				Z|tz|taz)
					# eg gzip downloads
					local -r ourCompression=compress
				;;
		
				gz|tgz)
					local -r ourCompression=gzip
				;;
		
				bz|tbz)
					local -r ourCompression=bzip2
				;;
	
				bz2|tbz2)
					local -r ourCompression=bzip2
				;;
		
				# A faster compressor still is lz4
				lzo)
					local -r ourCompression=lzop
				;;
		
				lz|tlz)
					local -r ourCompression=lzip
				;;
		
				lzma|tlzma)
					local -r ourCompression=lzma
				;;
		
				xz|txz)
					local -r ourCompression=xz
				;;
		
				*)
						local -r ourCompression=none
				;;
			esac
		
			api_downloads_archive[$api_download_index]="$ourArchive"
			api_downloads_compression[$api_download_index]="$ourCompression"
			api_downloads_archive_folder[$api_download_index]="$ourArchiveFolder"
		;;
		
		*)
			lfs_exitError "Unknown api_download_kind $api_download_kind"
		;;
		
	esac
	
	api_downloads_download_as[$api_download_index]="$(lfs_basename "$relativePath")"
}

function referrer()
{
	api_verifyOneArgument $#
	api_downloads_referrer[$api_download_index]="$1"
}

function post_data()
{
	api_verifyOneArgument $#
	api_downloads_post_data[$api_download_index]="$1"
}

function archive()
{
	api_verifyOneArgument $#
	api_downloads_archive[$api_download_index]="$1"
}

function compression()
{
	api_verifyOneArgument $#
	api_downloads_compression[$api_download_index]="$1"
}

function tarbomb()
{
	api_verifyOneArgument $#
	api_downloads_tarbomb[$api_download_index]="$1"
}

function archive_folder()
{
	api_verifyOneArgument $#
	api_downloads_archive_folder[$api_download_index]="$1"
}

function download_as()
{
	api_verifyOneArgument $#
	api_downloads_download_as[$api_download_index]="$1"
}

function size()
{
	api_verifyOneArgument $#
	api_downloads_size[$api_download_index]=$1
}

function md5()
{
	api_verifyOneArgument $#
	api_downloads_md5[$api_download_index]="$1"
}

function sha1()
{
	api_verifyOneArgument $#
	api_downloads_sha1[$api_download_index]="$1"
}

function sha224()
{
	api_verifyOneArgument $#
	api_downloads_sha224[$api_download_index]="$1"
}

function sha256()
{
	api_verifyOneArgument $#
	api_downloads_sha256[$api_download_index]="$1"
}

function sha384()
{
	api_verifyOneArgument $#
	api_downloads_sha284[$api_download_index]="$1"
}

function sha512()
{
	api_verifyOneArgument $#
	api_downloads_sha512[$api_download_index]="$1"
}

function signed_as()
{
	case "$1" in
		
		keyring|keyfile|hkp|hkp_uncompressed)
			:
		;;
		
		none)
			:
		;;
		
		*)
			lfs_exitError "Unrecognised signed_as $1"
		;;
	esac
	
	api_downloads_signed_as[$api_download_index]="$1"
	api_downloads_signed_id[$api_download_index]="$2"
	
	if [ $# -eq 3 ]; then
		api_downloads_signed_signatureFile[$api_download_index]="$3"
	else
		# actually, assumes a default name and location. Clever but annoying.
		api_downloads_signed_signatureFile[$api_download_index]=""
	fi
}

function package()
{
	name="$1"
	
	local -r versionName="$1"
	local -r versionValue="$2"
	local -i found=0
	local key
	for key in "${!api_package_version_settings[@]}"
	do
		# Once a setting is made, it can not be overwritten
		# This works well if we source machine, distribution and the recipes
		if [ "$key" = "$versionName" ]; then
			found=1
			break
		fi
	done
	if [ $found -eq 0 ]; then
		api_package_version_settings["$name"]="$2"
		version="$2"
	else
		version="$(get_package_version_setting "$name")"
	fi
	
	api_download "package" "$name" "$version"
}

function patch()
{
	name="$1"
	
	api_download "patch" "$name" 0
}

function file()
{
	name="$1"
	
	api_download "file" "$name" 0
}

function keyring()
{
	name="$1"
	
	api_download "keyring" "$name" 0
}

function keyfile()
{
	name="$1"
	
	api_download "keyfile" "$name" 0
}

