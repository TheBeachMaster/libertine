recipe_after_functions=()

function recipe_after_resolveDependencies()
{
	# Has to be made local in source
	recipe_after_temporaryRecipeDependenciesPath="$recipe_before_temporaryRecipePath"/dependencies
	mkdir -m 0755 -p "$recipe_after_temporaryRecipeDependenciesPath"
	
	local dependantRecipeName
	local dependantRecipeVersion
	local dependantRecipeFileName
	local localRecipe
	local localRecipeName
	local localRecipeVersion
	local dependentRecipeLinkValue
	local -i index
	pushd "$distribution_recipesPath" 1>/dev/null 2>/dev/null
		for index in "${!api_recipe_dependsRecipeName[@]}"
		do
			dependantRecipeName="${api_recipe_dependsRecipeName[$index]}"
			dependantRecipeVersion="${api_recipe_dependsRecipeVersion[$index]}"
			if [ -z "$dependantRecipeVersion" ]; then
				dependantRecipeFileName="${dependantRecipeName}.recipe"
			else
				dependantRecipeFileName="${dependantRecipeName}_${dependantRecipeVersion}.recipe"
			fi
			
			# TODO: A bit brittle
			IFS=' ' read -r localRecipe localRecipeName localRecipeVersion <<<"$(head -n 1 "$dependantRecipeFileName")"
			if [ "$localRecipe" != "recipe" ]; then
				lfs_exitError "Please make sure the first line in a recipe starts 'recipe NAME VERSION'"
			fi
			api_recipe_dependsRecipeVersion[$index]="$localRecipeVersion"
			
			# There's a relative symlink from "$recipeName"-"$recipeVersion" to "$recipeName"-"$recipeVersion"-"$recipeHash"
			dependentRecipeLinkValue="$(readlink "$LFS_BUILD_ROOT_PATH_DISTRIBUTION"/"$localRecipeName"-"$localRecipeVersion")"
			
			ln -s ../../"$dependentRecipeLinkValue" "$recipe_after_temporaryRecipeDependenciesPath"/"$dependantRecipeFileName"
		done
	popd 1>/dev/null 2>/dev/null
}
recipe_after_functions+=(recipe_after_resolveDependencies)

function recipe_after_installRecipeCopy()
{
	# Must be a copy, not a hardlink
	cp "$actualRecipeFile" "$recipe_after_temporaryRecipeDependenciesPath"/"$recipeName".recipe
}
recipe_after_functions+=(recipe_after_installRecipeCopy)

function recipe_after_computeHash()
{
	local -r recipeHashFile="$recipe_after_temporaryRecipeDependenciesPath".hash
	
	pushd "$recipe_after_temporaryRecipeDependenciesPath" 1>/dev/null 2>/dev/null
		
		{
			local dependencyFileName
			for dependencyFileName in *
			do
				# syntax should be name-version-hash
				# should symlink to 
				if [ ! -f "$dependencyFileName" ]; then
					continue
				else	
					printf "${dependencyFileName} "
					if [ -L "$dependencyFileName" ]; then
						hash_hashFile "$dependencyFileName"/dependencies.hash
					else
						hash_hashFile "$dependencyFileName"
					fi
				fi
			done
		} >"$recipeHashFile"
	
	popd 1>/dev/null 2>/dev/null
	
	recipeHash="$(hash_hashFile "$recipeHashFile")"
}
recipe_after_functions+=(recipe_after_computeHash)

function recipe_after_setPaths()
{
	LFS_RECIPE_NAME_VERSION="${recipeName}"-"${recipeVersion}"
	LFS_RECIPE_NAME_VERSION_HASH="$LFS_RECIPE_NAME_VERSION"-"${recipeHash}"
	
	LFS_BUILD_ROOT_PATH_RECIPE_RELATIVE="$LFS_BUILD_ROOT_PATH_DISTRIBUTION_RELATIVE"/"$LFS_RECIPE_NAME_VERSION_HASH"
	LFS_BUILD_ROOT_PATH_RECIPE="$LFS_BUILD_ROOT_PATH"/"$LFS_BUILD_ROOT_PATH_RECIPE_RELATIVE"
	
	LFS_BUILD_ROOT_PATH_RECIPE_DEPENDENCIES="$LFS_BUILD_ROOT_PATH_RECIPE"/dependencies
	LFS_BUILD_ROOT_PATH_RECIPE_DEPENDENCIES_HASHFILE="$LFS_BUILD_ROOT_PATH_RECIPE"/dependencies.hash
	
	LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADEDFILE="$LFS_BUILD_ROOT_PATH_RECIPE"/.downloaded
	LFS_BUILD_ROOT_PATH_RECIPE_BUILTFILE="$LFS_BUILD_ROOT_PATH_RECIPE"/.built
	
	LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS="$LFS_BUILD_ROOT_PATH_RECIPE"/downloads
	LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_PACKAGE="$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS"/package
	LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_PATCH="$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS"/patch
	LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_FILE="$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS"/file
	LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_SIGNATURE="$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS"/signature
	LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_KEYFILE="$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS"/keyfile
	LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_KEYRING="$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS"/keyring
	
	LFS_BUILD_ROOT_PATH_RECIPE_BUILDSCRIPT="$LFS_BUILD_ROOT_PATH_RECIPE"/build.bash
	
	LFS_BUILD_ROOT_PATH_RECIPE_BUILD="$LFS_BUILD_ROOT_PATH_RECIPE"/build
}
recipe_after_functions+=(recipe_after_setPaths)

function recipe_after_checkIfIdentical()
{
	if [ -d "$LFS_BUILD_ROOT_PATH_RECIPE" ]; then
		if [ -f "$LFS_BUILD_ROOT_PATH_RECIPE_BUILTFILE" ]; then
			touch "$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADEDFILE"
			# already built, no need to do again
			return 0
		fi
		if [ -f "$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADEDFILE" ]; then
			# downloads good, clean up any build garbage
			rm -rf "$LFS_BUILD_ROOT_PATH_RECIPE"/build
		else
			# TODO: Check for individual downloads
			rm -rf "$LFS_BUILD_ROOT_PATH_RECIPE"/build
		fi
	else
		pushd "$LFS_BUILD_ROOT_PATH_DISTRIBUTION" 1>/dev/null 2>/dev/null
			mv -T "$recipe_before_temporaryRecipePath" "$LFS_RECIPE_NAME_VERSION_HASH"
		popd 1>/dev/null 2>/dev/null
	fi
}
recipe_after_functions+=(recipe_after_checkIfIdentical)

function recipe_after_removeTemporaryOutput()
{
	rm -rf "$recipe_before_temporaryRecipePath"
	unset recipe_before_temporaryRecipePath
}
recipe_after_functions+=(recipe_after_removeTemporaryOutput)

function recipe_after_symlinkPaths()
{
	local mightExist="$LFS_BUILD_ROOT_PATH_DISTRIBUTION"/"$LFS_RECIPE_NAME_VERSION"
	if [ -e "$mightExist" ]; then
		rm -rf "$mightExist"
	fi
	ln -s "$LFS_RECIPE_NAME_VERSION_HASH" "$mightExist"
	
	# Machine recipe does not simply symlink
	if [ "$machineName" = "$recipeName" ]; then
		mightExist="$LFS_BUILD_ROOT_PATH_DISTRIBUTION"/"$machineName"
		if [ -e "$mightExist" ]; then
			# TODO: Implies REBUILD
			rm -rf "$mightExist"
		fi
		ln -s "$LFS_RECIPE_NAME_VERSION" "$mightExist"
	fi
}
recipe_after_functions+=(recipe_after_symlinkPaths)

function recipe_after_beginBuildScript()
{
	rm -rf "$LFS_BUILD_ROOT_PATH_RECIPE_BUILDSCRIPT"
	
	# need to export download_as names, path locations, package names, versions
	# need to support extraction, patching
	# need to export settings
	# pre- and post- install scripts (eg all the stripping commands)
	
	cat >"$LFS_BUILD_ROOT_PATH_RECIPE_BUILDSCRIPT" <<-EOF	
		#!$(file_pathToBinary bash)
		set -e
	
		function $(declare -f lfs_dirname)
	
		function $(declare -f lfs_basename)
	
		function $(declare -f lfs_findOurNameAndPath)
	
		lfs_findOurNameAndPath
		
		readonly LFS_MACHINE_NAME='$machineName'
		readonly LFS_MACHINE_HASH='$machine_hash'
		readonly LFS_MACHINE_NAME_HASH='$LFS_MACHINE_NAME_HASH'
		
		readonly LFS_DISTRIBUTION_NAME='$ourDistributionName'
		readonly LFS_DISTRIBUTION_VERSION='$ourDistributionVersion'
		readonly LFS_DISTRIBUTION_HASH='$machine_distributionHash'
		readonly LFS_DISTRIBUTION_NAME_VERSION_HASH='$LFS_DISTRIBUTION_NAME_VERSION_HASH'
		
		readonly LFS_RECIPE_NAME='$recipeName'
		readonly LFS_RECIPE_VERSION='$recipeVersion'
		readonly LFS_RECIPE_HASH='$recipeHash'
		readonly LFS_RECIPE_NAME_VERSION='$LFS_RECIPE_NAME_VERSION'
		readonly LFS_RECIPE_NAME_VERSION_HASH='$LFS_RECIPE_NAME_VERSION_HASH'
		
		readonly LFS_BUILD_ROOT_PATH='$LFS_BUILD_ROOT_PATH'
		
		readonly LFS_BUILD_ROOT_PATH_MACHINE_RELATIVE='$LFS_BUILD_ROOT_PATH_MACHINE_RELATIVE'
		readonly LFS_BUILD_ROOT_PATH_MACHINE='$LFS_BUILD_ROOT_PATH_MACHINE'
		
		readonly LFS_BUILD_ROOT_PATH_DISTRIBUTION_RELATIVE='$LFS_BUILD_ROOT_PATH_DISTRIBUTION_RELATIVE'
		readonly LFS_BUILD_ROOT_PATH_DISTRIBUTION='$LFS_BUILD_ROOT_PATH_DISTRIBUTION'
		
		readonly LFS_BUILD_ROOT_PATH_RECIPE_RELATIVE='$LFS_BUILD_ROOT_PATH_RECIPE_RELATIVE'
		readonly LFS_BUILD_ROOT_PATH_RECIPE='$LFS_BUILD_ROOT_PATH_RECIPE'
		
		readonly LFS_BUILD_ROOT_PATH_RECIPE_DEPENDENCIES='$LFS_BUILD_ROOT_PATH_RECIPE_DEPENDENCIES'
		readonly LFS_BUILD_ROOT_PATH_RECIPE_DEPENDENCIES_HASHFILE='$LFS_BUILD_ROOT_PATH_RECIPE_DEPENDENCIES_HASHFILE'
		
		readonly LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADEDFILE='$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADEDFILE'
		readonly LFS_BUILD_ROOT_PATH_RECIPE_BUILTFILE='$LFS_BUILD_ROOT_PATH_RECIPE_BUILTFILE'
		
		readonly LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS='$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS'
		readonly LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_PACKAGE='$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_PACKAGE'
		readonly LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_PATCH='$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_PATCH'
		readonly LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_FILE='$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_FILE'
		readonly LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_SIGNATURE='$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_SIGNATURE'
		readonly LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_KEYFILE='$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_KEYFILE'
		readonly LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_KEYRING='$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADS_KEYRING'
		
		readonly LFS_BUILD_ROOT_PATH_RECIPE_BUILD='$LFS_BUILD_ROOT_PATH_RECIPE_BUILD'
		
		readonly LFS_NATIVE_ARCHITECTURE='$(get_setting_native_architecture)'
		readonly LFS_NATIVE_TRIPLE='$(get_setting_native_architecture_triple)'

		readonly LFS_FOREIGN_ARCHITECTURE='$(get_setting_foreign_architecture)'
		readonly LFS_FOREIGN_TRIPLE='$(get_setting_foreign_architecture_triple)'
		
		declare -A LFS_DOWNLOADS_PACKAGE_PATHS=()
		declare -A LFS_DOWNLOADS_PATCH_PATHS=()
		declare -A LFS_DOWNLOADS_FILE_PATHS=()
		declare -A LFS_DOWNLOADS_KEYRING_PATHS=()
		declare -A LFS_DOWNLOADS_KEYFILE_PATHS=()
	EOF
}
recipe_after_functions+=(recipe_after_beginBuildScript)

function recipe_after_addDownloadTargets()
{
	if [ -f "$LFS_BUILD_ROOT_PATH_RECIPE_DOWNLOADEDFILE" ]; then
		return 0
	fi
	
	declare -a make_downloadTargetsSet=()
	
	# TODO: some downloads will be duplicated, eg gnulib, autotools-config. Too bad for now.
	# TODO: downloads will be duplicated if a package changes version slightly, unless we use a downloads cache. Too bad for now.
	local -i downloadIndex
	local name
	local version
	local download_kind
	local mirror
	local path
	local download_as
	local referrer
	local post_data
	local compression
	local -i size
	
	for downloadIndex in "${!api_downloads_name[@]}"
	do
		name="${api_downloads_name[$downloadIndex]}"
		version="${api_downloads_version[$downloadIndex]}"
		download_kind="${api_downloads_kinds[$downloadIndex]}"
		mirror="${api_downloads_mirror[$downloadIndex]}"
		path="${api_downloads_path[$downloadIndex]}"
		download_as="${api_downloads_download_as[$downloadIndex]}"
		
		referrer="${api_downloads_referrer[$downloadIndex]}"
		post_data="${api_downloads_post_data[$downloadIndex]}"
		compression="${api_downloads_compression[$downloadIndex]}"
		
		size=${api_downloads_size[$downloadIndex]}
		
		make_downloadTargetIfRequired
	done
	
	make_addTargetDownload
}
recipe_after_functions+=(recipe_after_addDownloadTargets)

function recipe_after_addVerifyTargets()
{
	declare -a make_verifyTargetsSet=()
	
	local -i downloadIndex
	local name
	local version
	local download_kind
	local mirror
	local path
	local -i size
	local md5
	local sha1
	local sha224
	local sha256
	local sha384
	local sha512
	for downloadIndex in "${!api_downloads_name[@]}"
	do
		name="${api_downloads_name[$downloadIndex]}"
		version="${api_downloads_version[$downloadIndex]}"
		download_kind="${api_downloads_kinds[$downloadIndex]}"
		mirror="${api_downloads_mirror[$downloadIndex]}"
		path="${api_downloads_path[$downloadIndex]}"
		download_as="${api_downloads_download_as[$downloadIndex]}"
		
		size=${api_downloads_size[$downloadIndex]}
		md5="${api_downloads_md5[$downloadIndex]}"
		sha1="${api_downloads_sha1[$downloadIndex]}"
		sha244="${api_downloads_sha224[$downloadIndex]}"
		sha256="${api_downloads_sha256[$downloadIndex]}"
		sha384="${api_downloads_sha384[$downloadIndex]}"
		sha512="${api_downloads_sha512[$downloadIndex]}"
	
		make_verifyTarget
	done
	
	make_addTargetVerify
}
recipe_after_functions+=(recipe_after_addVerifyTargets)

function recipe_after_finishBuildFile()
{
	rm -rf "$LFS_BUILD_ROOT_PATH_RECIPE_BUILDSCRIPT"
	
	{
		cat "$distribution_snippetsPath"/*.build.snippet 2>/dev/null || true
		
		declare -f "recipe_install_${recipeName}" || lfs_exitError "Make sure recipe $recipeName contains a function called recipe_install_$recipeName, even if it does nothing"
		
		local -r privatePrefix="_recipe_install_${recipeName}"
		local -ir privatePrefixLength=${#privatePrefix}
		local a
		local b
		local functionName
		while IFS=' ' read -r a b functionName
		do
			if [ "${functionName:0:$privatePrefixLength}" = "$privatePrefix" ]; then
				declare -f "$functionName"
			fi
		done < <(declare -F)
		
		echo "recipe_install_${recipeName}"
	} >>"$LFS_BUILD_ROOT_PATH_RECIPE_BUILDSCRIPT"
	
	chmod +x "$LFS_BUILD_ROOT_PATH_RECIPE_BUILDSCRIPT"
	
	make_addTargetBuild
}
recipe_after_functions+=(recipe_after_finishBuildFile)
