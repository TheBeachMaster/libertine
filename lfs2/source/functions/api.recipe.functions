function recipe()
{
	recipeName="$1"
	recipeVersion="$2"
}

# If we allow each package 256 uids, that gives 1 for the package as a whole and enough for every program in it
function uidgid()
{
	api_verifyOneArgument $#
	api_recipes_uidgid["${recipeName}"]=$1
}

function depends()
{
	local -r dependsRecipeName="$1"
	# might be empty
	local -r dependsRecipeVersion="$2"
	api_recipe_depends+=("${dependsRecipeName}_${dependsRecipeVersion}.recipe")
}






function post-install()
{
	# could check that an install function is defined!
	:
}

function remove_unwanted()
{
	local -r parentPath="$1"
	shift 1
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local file
	local filePath
	local existingPaths
	for file in "$@"
	do
		filePath="$parentPath"/"$file"
		
		existingPaths="${dependency_RemoveResourcePaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_RemoveResourcePaths["$DependencyKey"]="$filePath"
		else
			dependency_RemoveResourcePaths["$DependencyKey"]="$existingPaths $filePath"
		fi
	done
}

function doc_resources()
{
	local -r parentPath="$1"
	shift 1
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local file
	local filePath
	local existingPaths
	for file in "$@"
	do
		filePath="$parentPath"/"$file"
		
		existingPaths="${dependency_DocResourcePaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_DocResourcePaths["$DependencyKey"]="$filePath"
		else
			dependency_DocResourcePaths["$DependencyKey"]="$existingPaths $filePath"
		fi
	done
}

function compile_resources()
{
	local -r parentPath="$1"
	shift 1
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local file
	local filePath
	local existingPaths
	for file in "$@"
	do
		filePath="$parentPath"/"$file"
		
		existingPaths="${dependency_CompileResourcePaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_CompileResourcePaths["$DependencyKey"]="$filePath"
		else
			dependency_CompileResourcePaths["$DependencyKey"]="$existingPaths $filePath"
		fi
	done
}

function libtool_archives()
{
	local -r parentPath="$1"
	shift 1
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local file
	local filePath
	local existingPaths
	for file in "$@"
	do
		filePath="$parentPath"/"$file"
		
		existingPaths="${dependency_LibtoolArchivePaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_LibtoolArchivePaths["$DependencyKey"]="$filePath"
		else
			dependency_LibtoolArchivePaths["$DependencyKey"]="$existingPaths $filePath"
		fi
	done
}

function strip_unneeded()
{
	local -r parentPath="$1"
	shift 1
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local file
	local filePath
	local existingPaths
	for file in "$@"
	do
		filePath="$parentPath"/"$file"
		
		existingPaths="${dependency_BinaryStripPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_BinaryStripPaths["$DependencyKey"]="$filePath"
		else
			dependency_BinaryStripPaths["$DependencyKey"]="$existingPaths $filePath"
		fi
	done
}

function uidgid_paths()
{
	local -r value="$1"
	local -r parentPath="$2"
	shift 2
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local path
	local combination
	local existingPaths
	for path in "$@"
	do
		combination="${parentPath}/${path}.${value}"
		
		existingPaths="${dependency_UidGidPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_UidGidPaths["$DependencyKey"]="$combination"
		else
			dependency_UidGidPaths["$DependencyKey"]="$existingPaths $combination"
		fi
	done
}

function capabilities_binaries()
{
	local -r value="$1"
	local -r parentPath="$2"
	shift 2
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local path
	local combination
	local existingPaths
	for path in "$@"
	do
		combination="${parentPath}/${path}.${value}"
		
		existingPaths="${dependency_CapabilitiesBinaryInstallPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_CapabilitiesBinaryInstallPaths["$DependencyKey"]="$combination"
		else
			dependency_CapabilitiesBinaryInstallPaths["$DependencyKey"]="$existingPaths $combination"
		fi
	done
}

function _binaryPermissionBits()
{
	local -r value="$1"
	local -r parentPath="$2"
	shift 2
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local path
	local combination
	local existingPaths
	for path in "$@"
	do
		combination="${parentPath}/${path}.${value}"
		
		existingPaths="${dependency_BinaryPermissionBitsPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_BinaryPermissionBitsPaths["$DependencyKey"]="$combination"
		else
			dependency_BinaryPermissionBitsPaths["$DependencyKey"]="$existingPaths $combination"
		fi
	done
}

function executable_binaries()
{
	local -r parentPath="$1"
	shift 1
	_binaryPermissionBits a+x "$parentPath" "$@"
}

function setuid_binaries()
{
	local -r parentPath="$1"
	shift 1
	_binaryPermissionBits u+s "$parentPath" "$@"
}

function setgid_binaries()
{
	local -r parentPath="$1"
	shift 1
	_binaryPermissionBits g+s "$parentPath" "$@"
}

function explicit_filemode()
{
	local -r fileModeBits="$1"
	local -r parentPath="$2"
	shift 2
	_binaryPermissionBits "$fileModeBits" "$parentPath" "$@"
}

function install_binaries()
{
	local -r relativeBinaryPath="$1"
	shift 1
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local binary
	local binaryPath
	local existingPaths
	for binary in "$@"
	do
		binaryPath="$relativeBinaryPath"/"$binary"
		
		existingPaths="${dependency_BinaryInstallPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_BinaryInstallPaths["$DependencyKey"]="$binaryPath"
		else
			dependency_BinaryInstallPaths["$DependencyKey"]="$existingPaths $binaryPath"
		fi
	done
}

function install_system_binaries()
{
	local -r relativeBinaryPath="$1"
	shift 1
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local binary
	local binaryPath
	local existingPaths
	for binary in "$@"
	do
		binaryPath="$relativeBinaryPath"/"$binary"
		
		existingPaths="${dependency_SystemBinaryInstallPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_SystemBinaryInstallPaths["$DependencyKey"]="$binaryPath"
		else
			dependency_SystemBinaryInstallPaths["$DependencyKey"]="$existingPaths $binaryPath"
		fi
	done
}








function make_fhs_folders_before_install()
{
	local -r relativeParentPath="$1"
	shift 1
	
	local -r ourRecipeVersion="${LFS_RECIPE_VERSION["${LFS_RECIPE_NAME}"]}"
	dependency_key "$LFS_PHASE" "$LFS_RECIPE_NAME" "$ourRecipeVersion"
	
	local folder
	local folderPath
	local existingPaths
	for folderPath in "$@"
	do
		# The leading slash is deliberate
		binaryPath=/"$relativeParentPath"/"$folderPath"
		
		existingPaths="${dependency_MakeFhsFoldersBeforeInstallPaths["$DependencyKey"]}"
		if [ -z "$existingPaths" ]; then
			dependency_MakeFhsFoldersBeforeInstallPaths["$DependencyKey"]="$binaryPath"
		else
			dependency_MakeFhsFoldersBeforeInstallPaths["$DependencyKey"]="$existingPaths $binaryPath"
		fi
	done
}

function dependencyPath()
{
	local -r dependencyName="$1"
	for dependencyKey in "${!dependency_Name[@]}"
	do
		if [ "${dependency_Name["$dependencyKey"]}" = "$dependencyName" ]; then
			if [ "${dependency_Phase["$dependencyKey"]}" = "$LFS_PHASE" ]; then
				echo -n "${dependency_Path["$dependencyKey"]}"
				return 0
			fi
		fi
	done
}

function fixUpGnulib()
{
	pushdDependencyFolder
	
		../gnulib/gnulib-tool --add-import
		
	popdDependencyFolder
}

function fixUpAutoToolsConfig()
{
	if [ -d config ]; then
		
		pushd config >/dev/null
			local -r configSubFile="$(pwd)"/config.sub
			local -r configGuessFile="$(pwd)"/config.guess
			chmod +x "$configSubFile"
			chmod +x "$configGuessFile"
		popd >/dev/null
		
		local dependencyFolder
		for dependencyFolder in *
		do
			if [ "$dependencyFolder" = "config" ]; then
				continue
			fi
			if [ "${dependencyFolder:0:7}" = "config-" ]; then
				continue
			fi
		
			if [ ! -d "$dependencyFolder" ]; then
				continue
			fi
			
			pushd "$dependencyFolder" >/dev/null
			
				# Update autotools malarkey
				local configFolder
				local configFile
				for configFolder in . config support build-aux
				do
					if [ ! -d "$configFolder" ]; then
						continue
					fi
					
					pushd "$configFolder" >/dev/null
					
						for configFile in config.sub configfsf.sub
						do
							if [ -f "$configFile" ]; then
								mv "$configFile" "$configFile".orig
								ln "$configSubFile" "$configFile"
							fi
						done
						for configFile in config.guess
						do
							if [ -f "$configFile" ]; then
								mv "$configFile" "$configFile".orig
								ln "$configGuessFile" "$configFile"
							fi
						done
						
					popd >/dev/null
				done
			
				popd >/dev/null
		done
	fi
}

function autotoolsConfiguredMakeWrapper()
{
	# This weird setting of PATH is so we can use the set -x output on the command line directly to test build problems
	PATH="$PATH" \
	make \
		--jobs $LFS_MAKE_COMPILE_JOBS \
		--load-average $LFS_MAKE_LOAD_AVERAGE \
		--debug \
		--print-directory \
		V=1 \
	"$@" 1>&2
}

function buildUsingMakeExternal()
{
	# This weird setting of PATH is so we can use the set -x output on the command line directly to test build problems
	PATH="$PATH" \
	make \
		--jobs $LFS_MAKE_COMPILE_JOBS \
		--load-average $LFS_MAKE_LOAD_AVERAGE \
		--debug \
		--print-directory \
		V=1 \
		CC="$LFS_C_TARGET_EXTERNAL_CC" \
		CXX="$LFS_C_TARGET_EXTERNAL_CXX" \
		CPP="$LFS_C_TARGET_EXTERNAL_CPP" \
		CXXCPP="$LFS_C_TARGET_EXTERNAL_CXXCPP" \
		AR="$LFS_C_TARGET_EXTERNAL_AR" \
		AS="$LFS_C_TARGET_EXTERNAL_AS" \
		NM="$LFS_C_TARGET_EXTERNAL_NM" \
		RANLIB="$LFS_C_TARGET_EXTERNAL_RANLIB" \
		OBJDUMP="$LFS_C_TARGET_EXTERNAL_OBJDUMP" \
		OBJCOPY="$LFS_C_TARGET_EXTERNAL_OBCOPY" \
		LD="$LFS_C_TARGET_EXTERNAL_LD" \
		STRIP="$LFS_C_TARGET_EXTERNAL_STRIP" \
		CPPFLAGS="$LFS_C_TARGET_EXTERNAL_CPPFLAGS" \
		CFLAGS="$LFS_C_TARGET_EXTERNAL_CFLAGS" \
		CXXFLAGS="$LFS_C_TARGET_EXTERNAL_CXXFLAGS" \
		LDFLAGS="$LFS_C_TARGET_EXTERNAL_LDFLAGS" \
	"$@" 1>&2
}

function callback_empty()
{
	:
}

# This is a hack for packages which don't support cross-compilation
function buildUsingAutotoolsHost()
{
	local -r callback="$1"
	shift 1
	
	fixUpAutoToolsConfig
	
	pushdDependencyFolder
		# This weird setting of PATH is so we can use the set -x output on the command line directly to test build problems
		PATH="$PATH" \
		./configure \
			CC="$LFS_C_HOST_CC" \
			CXX="$LFS_C_HOST_CXX" \
			CPP="$LFS_C_HOST_CPP" \
			CXXCPP="$LFS_C_HOST_CXXCPP" \
			AR="$LFS_C_HOST_AR" \
			AS="$LFS_C_HOST_AS" \
			NM="$LFS_C_HOST_NM" \
			RANLIB="$LFS_C_HOST_RANLIB" \
			OBJDUMP="$LFS_C_HOST_OBJDUMP" \
			OBJCOPY="$LFS_C_HOST_OBJCOPY" \
			LD="$LFS_C_HOST_LD" \
			STRIP="$LFS_C_HOST_STRIP" \
			CPPFLAGS="$LFS_C_HOST_CPPFLAGS" \
			CFLAGS="$LFS_C_HOST_CFLAGS" \
			CXXFLAGS="$LFS_C_HOST_CXXFLAGS" \
			LDFLAGS="$LFS_C_HOST_LDFLAGS" \
		--host="$LFS_NATIVE_TRIPLE" \
		--target="$LFS_NATIVE_TRIPLE" \
		--prefix="${LFS}${LFS_DEPENDENCY_PREFIX_PATH}"/build \
		"$@" 1>&2
		
		$callback
		
		autotoolsConfiguredMakeWrapper

		autotoolsConfiguredMakeWrapper install
		
	popdDependencyFolder
}

function buildUsingAutotoolsExternal()
{
	local -r callback="$1"
	shift 1
	
	fixUpAutoToolsConfig
	
	pushdDependencyFolder
		# This weird setting of PATH is so we can use the set -x output on the command line directly to test build problems
		# Note that an older name for CC_FOR_BUILD is HOST_CC
		PATH="$PATH" \
		./configure \
			CC_FOR_BUILD="$LFS_C_HOST_CC" \
			CXX_FOR_BUILD="$LFS_C_HOST_CXX" \
			CPPFLAGS_FOR_BUILD="$LFS_C_HOST_CPPFLAGS" \
			CFLAGS_FOR_BUILD="$LFS_C_HOST_CFLAGS" \
			CXXFLAGS_FOR_BUILD="$LFS_C_HOST_CXXFLAGS" \
			LDFLAGS_FOR_BUILD="$LFS_C_HOST_LDFLAGS" \
			CC="$LFS_C_TARGET_EXTERNAL_CC" \
			CXX="$LFS_C_TARGET_EXTERNAL_CXX" \
			CPP="$LFS_C_TARGET_EXTERNAL_CPP" \
			CXXCPP="$LFS_C_TARGET_EXTERNAL_CXXCPP" \
			AR="$LFS_C_TARGET_EXTERNAL_AR" \
			AS="$LFS_C_TARGET_EXTERNAL_AS" \
			NM="$LFS_C_TARGET_EXTERNAL_NM" \
			RANLIB="$LFS_C_TARGET_EXTERNAL_RANLIB" \
			OBJDUMP="$LFS_C_TARGET_EXTERNAL_OBJDUMP" \
			OBJCOPY="$LFS_C_TARGET_EXTERNAL_OBJCOPY" \
			LD="$LFS_C_TARGET_EXTERNAL_LD" \
			STRIP="$LFS_C_TARGET_EXTERNAL_STRIP" \
			CPPFLAGS="$LFS_C_TARGET_EXTERNAL_CPPFLAGS" \
			CFLAGS="$LFS_C_TARGET_EXTERNAL_CFLAGS" \
			CXXFLAGS="$LFS_C_TARGET_EXTERNAL_CXXFLAGS" \
			LDFLAGS="$LFS_C_TARGET_EXTERNAL_LDFLAGS" \
		--host="$LFS_NATIVE_TRIPLE" \
		--target="$LFS_FOREIGN_TRIPLE" \
		--prefix="$LFS_DEPENDENCY_PREFIX_PATH" \
		"$@" 1>&2
		
		$callback
		
		autotoolsConfiguredMakeWrapper
	
		if [ -z "$LFS" ]; then
			autotoolsConfiguredMakeWrapper install
		else
			autotoolsConfiguredMakeWrapper DESTDIR="$LFS" install
		fi
		
	popdDependencyFolder
}

function pushdDependencyFolder()
{
	pushd "$LFS_DEPENDENCY_NAME" >/dev/null
}

function popdDependencyFolder()
{
	popd >/dev/null
}

function createBuildFolderAndPushd()
{
	local -r buildFolder=../"$LFS_DEPENDENCY_NAME"-build
	mkdir -m 0755 -p "$buildFolder"
	pushd "$buildFolder" >/dev/null
}

function popdBuildFolder()
{
	popd >/dev/null
}

function setLfsSourcePackageVariables()
{
	LFS_SOURCE_PACKAGE_NAME="${sourcePackages_Name[$1]}"
	LFS_SOURCE_PACKAGE_VERSION="${sourcePackages_Version[$1]}"
	LFS_SOURCE_PACKAGE_COMPRESSION="${sourcePackages_Compression[$1]}"
	LFS_SOURCE_PACKAGE_FILENAME="${sourcePackages_FileName[$1]}"
	LFS_SOURCE_PACKAGE_EXTRACTED_TARBALL_FOLDER="${sourcePackages_ExtractedTarballFolder[$1]}"
	LFS_SOURCE_PACKAGE_IS_TARBOMB="${sourcePackages_IsTarbomb[$1]}"
	LFS_SOURCE_PACKAGE_MIRROR="${sourcePackages_Mirror[$1]}"
	LFS_SOURCE_PACKAGE_RELATIVE_PATH="${sourcePackages_RelativePath[$1]}"
}
