
# Declare before use:-
#   make_makeFile
#   make_downloadTargets
#   make_verifyTargets
#   make_buildTargets

function make_addDownloadTargets()
{
	echo -ne " $@" >>"$make_downloadTargets"
	make_downloadTargetsSet+=("$@")
}

function make_addVerifyTargets()
{
	echo -ne " $@" >>"$make_verifyTargets"
	make_verifyTargetsSet+=("$@")
}

function make_addBuildTargets()
{
	echo -ne " $@" >>"$make_buildTargets"
}

function make_start()
{
	local -r whichMake="$(file_pathToBinary make)"
	local -r whichBash="$(file_pathToBinary bash)"
	cat >"$make_makeFile" <<-EOF
		#!${whichMake}
		
		SHELL=${whichBash}
		
		.ONESHELL:
		
		all: all-download all-verify all-build
		
	EOF
	
	chmod +x "$make_makeFile"
}

function make_addTarget()
{
	local -r targetName="$1"
	shift 1
	
	cat >"$make_makeFile" <<-EOF
		${targetName}: $@
		
	EOF
}

function make_commonVariables()
{
	parentPath="$(lfs_dirname "$path")"
	
	if [ -n "$download_as" ]; then
		fileName="$download_as"
	else
		fileName="$(lfs_basename "$path")"
	fi
	
	cacheParentPath="$distribution_cacheDownloadsPath"/"$download_kind"/"$mirror"/"$name"
	downloadFilePath="$cacheParentPath"/"$fileName"
}

function make_downloadTargetIfRequired()
{
	local parentPath
	local fileName
	local cacheParentPath
	local downloadFilePath
	make_commonVariables
	
	if [ ! -d "$cacheParentPath" ]; then
		mkdir -m 0755 -p "$cacheParentPath"
	fi
	
	local -r resolvedMirror="${api_mirrors_Url["$mirror"]}"
	if [ -z "$resolvedMirror" ]; then
		lfs_exitError "No known mirror $mirror"
	fi
	local -r url="${resolvedMirror}${path}"
	
	cat >>"$LFS_BUILD_ROOT_PATH_RECIPE_BUILDSCRIPT" <<-EOF
		LFS_DOWNLOADS_${download_kind^^}_PATHS['$name']='$downloadFilePath'
	EOF
	
	if [ $size -eq -1 ]; then
		if [ -f "$downloadFilePath" ]; then
			return 0
		fi
		local -ir continueAt=-1
	else
		if [ -f "$downloadFilePath" ]; then
			local -ir actualSize=$(stat --printf='%s' "$downloadFilePath")
			if [ $size = $actualSize ]; then
				return 0
			elif [ $actualSize -gt $size ]; then
				rm -rf "$downloadFilePath"
				local -ir continueAt=-1
			else
				if [ "${api_mirrors_PartialsSupported["$mirror"]}" = "yes" ]; then
					local -ir continueAt=$actualSize
				else
					local -ir continueAt=-1
				fi
			fi
		else
			local -ir continueAt=-1
		fi
	fi
	
	if [ -z "$post_data" ]; then
		local -r verb=GET
	else
		local -r verb=POST
		local -r curl_post="$post_data"
	fi
	
	if [ -z "$referrer" ]; then
		# Misspelling is correct - it is to mirror the typo in the HTTP/1.1 header definitions
		local -r referer="$(dirname "$url")/"
	else
		local -r referer="$referrer"
	fi
	
	declare -a curl_args=()
	declare -a curl_requestHeaders=()
	
	curl_addQuotedArg "$(file_pathToBinary curl)"
	curl_createCommandLine "$verb" "$url" "$referer" "$downloadFilePath" "$compression" $continueAt
	
	local -r downloadTarget="download-${recipeName}_${recipeVersion}.${downloadIndex}"
	make_addDownloadTargets "$downloadTarget"
	{
		printf '%s:\n' "${downloadTarget}"
		printf '\t'
		echo -ne "${curl_args[@]}"
		printf '\n\n'
	} >>"$make_makeFile"
	
	make_downloadTargetsSet+=("$downloadTarget")
}

function make_verifyTarget()
{
	local parentPath
	local fileName
	local cacheParentPath
	local downloadFilePath
	make_commonVariables
	
	local -r verifyScript="$cacheParentPath"/"$name".verify
	if [ -e "$verifyScript" ]; then
		rm -rf "$verifyScript"
	fi
	
	cat >"$verifyScript" <<-EOF
		#!$(file_pathToBinary bash)
		set -e
		
		function $(declare -f lfs_dirname)
		
		function $(declare -f lfs_basename)
		
		function $(declare -f lfs_findOurNameAndPath)
		
		lfs_findOurNameAndPath
		
		readonly LFS_DOWNLOAD_FILENAME='$fileName'
		
		readonly LFS_BINARY_stat='$(file_pathToBinary stat)'
		
		readonly LFS_BINARY_md5='$(file_pathToBinary md5sum)'
		
		readonly LFS_BINARY_sha1='$(file_pathToBinary sha1sum)'
		
		readonly LFS_BINARY_sha224='$(file_pathToBinary sha224sum)'
		
		readonly LFS_BINARY_sha256='$(file_pathToBinary sha256sum)'
		
		readonly LFS_BINARY_sha384='$(file_pathToBinary sha384sum)'
		
		readonly LFS_BINARY_sha512='$(file_pathToBinary sha512sum)'
		
	EOF
	
	cat >"$verifyScript" <<-'EOF'
		readonly LFS_DOWNLOAD_PATH='$crudeOurPath'/"$LFS_DOWNLOAD_FILENAME"
		
		function verifySize()
		{
			local -r size=$1
			test "$("$LFS_BINARY_stat" --printf='%s' "$LFS_DOWNLOAD_PATH")" -eq "$size"
		}
		
		function verifyHash()
		{
			local -r hashAlgorithm="$1"
			local -r hashValue="$2"
			
			local -r hashProgramPathVariable=LFS_BINARY_${hashAlgorithm}
			${!hashProgramPathVariable} --check --strict --status <<-EOFX
				$hashValue  $LFS_DOWNLOAD_PATH
			EOFX
		}
	EOF
	
	{
		if [ $size -ne -1 ]; then
			echo -ne "verifySize $size"
		fi
		
		local algorithm
		for algorithm in md5 sha1 sha224 sha256 sha384 sha512
		do
			if [ -n "${!algorithm}" ]; then
				echo -ne "verifyHash $algorithm ${!algorithm}"
			fi
		done
	} >>"$verifyScript"
	
	chmod +x "$verifyScript"
	
	local -r verifyTarget="verify-${recipeName}_${recipeVersion}.${downloadIndex}"
	make_addVerifyTargets "$verifyTarget"
	{
		printf '%s:\n\t' "${verifyTarget}"
		echo -ne "'"
		echo -ne "$verifyScript"
		echo -ne "'"
		printf '\n\n'
	} >>"$make_makeFile"
	
	make_verifyTargetsSet+=("$verifyTarget")
}

function make_finish()
{
	# TODO: Add a CA download section, so that we can use CAs...
	
	cat >>"$make_makeFile" <<-EOF
		all-download:$(cat "$make_downloadTargets")
		
		all-verify:$(cat "$make_verifyTargets")
		
		all-build:$(cat "$make_buildTargets")
		
		.PHONY: all all-download all-verify all-build$(cat "$make_downloadTargets")$(cat "$make_verifyTargets")$(cat "$make_buildTargets")
		
	EOF
}