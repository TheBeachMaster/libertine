
# Declare before use:-
#   make_makeFile
#   make_downloadTargets
#   make_verifyTargets
#   make_buildTargets

function make_addDownloadTargets()
{
	echo -ne " $@" >>"$make_downloadTargets"
}

function make_addVerifyTargets()
{
	echo -ne " $@" >>"$make_verifyTargets"
}

function make_addBuildTargets()
{
	echo -ne " $@" >>"$make_buildTargets"
}

function make_start()
{
	local -r whichMake="$(hash -t make || which make 2>/dev/null)"
	cat >"$make_makeFile" <<-EOF
		#!${whichMake}
		
		all: all-download all-verify all-build
		
	EOF
}

function make_downloadTargetIfRequired()
{
	local -r parentPath="$(lfs_dirname "$path")"
	
	if [ -n "$download_as" ]; then
		local -r fileName="$download_as"
	else
		local -r fileName="$(lfs_basename "$path")"
	fi
	
	local -r cacheParentPath="$distribution_cacheDownloadsPath"/"$parentPath"
	local -r downloadFilePath="$cacheParentPath"/"$fileName"
	
	local -r resolvedMirror="${api_mirrors_Url["$mirror"]}"
	if [ -z "$resolvedMirror" ]; then
		lfs_exitError "No known mirror $mirror"
	fi
	local -r url="${resolvedMirror}${path}"
	
	cat >>"$LFS_BUILD_ROOT_PATH_RECIPE_BUILDSCRIPT" <<-EOF
		LFS_DOWNLOADS_${download_kind^^}_PATHS['$name']='$downloadFilePath'
	EOF
	
	if [ $size -eq -1 ]; then
		if [ -f "$downloadFilePath" ]; then
			return 0
		fi
		local -ir continueAt=-1
	else
		if [ -f "$downloadFilePath" ]; then
			local -ir actualSize=$(stat --printf='%s' "$downloadFilePath")
			if [ $size = $actualSize ]; then
				return 0
			elif [ $actualSize -gt $size ]; then
				rm -rf "$downloadFilePath"
				local -ir continueAt=-1
			else
				if [ "${api_mirrors_PartialsSupported["$mirror"]}" = "yes" ]; then
					local -ir continueAt=$actualSize
				else
					local -ir continueAt=-1
				fi
			fi
		else
			local -ir continueAt=-1
		fi
	fi
	
	if [ -z "$post_data" ]; then
		local -r verb=GET
	else
		local -r verb=POST
		local -r curl_post="$post_data"
	fi
	
	if [ -z "$referrer" ]; then
		# Misspelling is correct - it is to mirror the typo in the HTTP/1.1 header definitions
		local -r referer="$(dirname "$url")/"
	else
		local -r referer="$referrer"
	fi
	
	declare -a curl_args=()
	declare -a curl_requestHeaders=()
	
	curl_addQuotedArg "$(hash -t curl || which curl 2>/dev/null)"
	curl_createCommandLine "$verb" "$url" "$referer" "$downloadFilePath" "$compression" $continueAt
	
	local -r downloadTarget="download-${recipeName}_${recipeVersion}.${downloadIndex}"
	make_addDownloadTargets "$downloadTarget"
	{
		printf '%s:\n' "${downloadTarget}"
		printf '\t%s\n' "mkdir -m 0755 -p '${cacheParentPath}'"
		printf '\t'
		echo -ne "${curl_args[@]}"
		printf '\n\n'
	} >>"$make_makeFile"
	
	chmod +x "$make_makeFile"
}

function make_finish()
{
	# TODO: Add a CA download section, so that we can use CAs...
	
	cat >>"$make_makeFile" <<-EOF
		all-download:$(cat "$make_downloadTargets")
		
		all-verify:$(cat "$make_verifyTargets")
		
		all-build:$(cat "$make_buildTargets")
		
		.PHONY: all all-download all-verify all-build$(cat "$make_downloadTargets")$(cat "$make_verifyTargets")$(cat "$make_buildTargets")
		
	EOF
}