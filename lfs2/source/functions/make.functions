function make_addTarget()
{
	make_targetsPhony+=("$target")
}

function make_addTargetDownloadItem()
{
	local -r target="download-${recipeName}_${recipeVersion}.${downloadIndex}"
	local -r isEmpty="$1"
	
	make_addTarget
	
	if [ "$isEmpty" = "yes" ]; then
		printf '\t%s:\n\n' "$target"
	else
		printf '%s:\n\t' "$target"
		echo -ne "'"
		echo -ne "$downloadScript"
		echo -ne "'"
		printf '\n\n'
	fi
}

function make_addTargetDownload()
{
	local -r target="download-${recipeName}_${recipeVersion}"
	
	make_addTarget
	make_targetsDownload+=("$target")
	
	# If we remove 'download' here, then we make things faster... but with builds happening whilst downloading
	printf '%s:' "$target"
	local -i downloadIndex
	for downloadIndex in "${!api_downloads_name[@]}"
	do
		echo -ne " download-${recipeName}_${recipeVersion}.${downloadIndex}"
	done
	printf '\n\n'
}

function make_addTargetVerifyItem()
{
	local -r target="verify-${recipeName}_${recipeVersion}.${downloadIndex}"
	
	make_addTarget
	
	printf '%s: %s\n\t' "$target" "download-${recipeName}_${recipeVersion}.${downloadIndex}"
	echo -ne "'"
	echo -ne "$verifyScript"
	echo -ne "'"
	printf '\n\n'
}

function make_addTargetVerify()
{
	local -r target="verify-${recipeName}_${recipeVersion}"
	
	make_addTarget
	make_targetsVerify+=("$target")
	
	printf '%s: %s' "$target" "download-${recipeName}_${recipeVersion}"
	local -i downloadIndex
	for downloadIndex in "${!api_downloads_name[@]}"
	do
		echo -ne " verify-${recipeName}_${recipeVersion}.${downloadIndex}"
	done
	printf '\n\n'
}

function make_addTargetBuild()
{
	local -r target="build-${recipeName}_${recipeVersion}"
	
	make_addTarget
	make_targetsBuild+=("$target")
	
	# depends on our verify tartget
	printf '%s: %s' "$target" "verify-${recipeName}_${recipeVersion}"
	local -i index
	for index in "${!api_recipe_dependsRecipeName[@]}"
	do
		echo -ne " build-${api_recipe_dependsRecipeName[$index]}_${api_recipe_dependsRecipeVersion[$index]}"
	done
	printf '\n\t'
	
	echo -ne "'"
	echo -ne "$LFS_BUILD_ROOT_PATH_RECIPE_BUILDSCRIPT"
	echo -ne "'"
	printf '\n\n'
}

function make_start()
{
	cat <<-EOF
		#!$(file_pathToBinary make)
		
		SHELL=$(file_pathToBinary bash)
		
		all: download verify build
		
	EOF
}

function make_commonVariables()
{
	parentPath="$(lfs_dirname "$path")"
	
	if [ -n "$download_as" ]; then
		fileName="$download_as"
	else
		fileName="$(lfs_basename "$path")"
	fi
	
	# version only exists for packages
	cacheParentPath="$LFS_BUILD_ROOT_PATH_MACHINE"/"$download_kind"/"$mirror"/"$name"
	downloadFilePath="$cacheParentPath"/"$fileName"
}

function make_downloadTargetIfRequired()
{
	local parentPath
	local fileName
	local cacheParentPath
	local downloadFilePath
	make_commonVariables
	
	if [ ! -d "$cacheParentPath" ]; then
		mkdir -m 0755 -p "$cacheParentPath"
	fi
	
	local -r resolvedMirror="${api_mirrors_Url["$mirror"]}"
	if [ -z "$resolvedMirror" ]; then
		lfs_exitError "No known mirror $mirror"
	fi
	local -r url="${resolvedMirror}${path}"
	
	cat >>"$LFS_BUILD_ROOT_PATH_RECIPE_BUILDSCRIPT" <<-EOF
		LFS_DOWNLOADS_${download_kind^^}_PATHS['$name']='$downloadFilePath'
	EOF
	
	if [ $size -eq -1 ]; then
		if [ -f "$downloadFilePath" ]; then
			make_addTargetDownloadItem "yes"
			return 0
		fi
		local -ir continueAt=-1
	else
		if [ -f "$downloadFilePath" ]; then
			local -ir actualSize=$(stat --printf='%s' "$downloadFilePath")
			if [ $size = $actualSize ]; then
				make_addTargetDownloadItem "yes"
				return 0
			elif [ $actualSize -gt $size ]; then
				rm -rf "$downloadFilePath"
				local -ir continueAt=-1
			else
				if [ "${api_mirrors_PartialsSupported["$mirror"]}" = "yes" ]; then
					local -ir continueAt=$actualSize
				else
					local -ir continueAt=-1
				fi
			fi
		else
			local -ir continueAt=-1
		fi
	fi
	
	if [ -z "$post_data" ]; then
		local -r verb=GET
	else
		local -r verb=POST
		local -r curl_post="$post_data"
	fi
	
	if [ -z "$referrer" ]; then
		# Misspelling is correct - it is to mirror the typo in the HTTP/1.1 header definitions
		local -r referer="$(dirname "$url")/"
	else
		local -r referer="$referrer"
	fi
	
	local -r downloadScript="$cacheParentPath"/"$fileName".download
	if [ -e "$downloadScript" ]; then
		rm -rf "$downloadScript"
	fi
	{
		cat <<-EOF
			#!$(file_pathToBinary bash)
			set -e
			
			function $(declare -f lfs_dirname)
			
			function $(declare -f lfs_basename)
			
			function $(declare -f lfs_findOurNameAndPath)
			
			lfs_findOurNameAndPath
			
			readonly etcPath='$etcPath'
			readonly lfs_configPath='$lfs_configPath'
			readonly lfs_netrcFilePath='$lfs_netrcFilePath'
			readonly lfs_curlrcFilePath='$lfs_curlrcFilePath'
			readonly LFS_PROGRAM_NAME='$ourName'
			readonly LFS_CURL_USERAGENT="$ourName/$machineDistributionName/$machineDistributionVersion"
			readonly LFS_CURL_MAX_REDIRECTS='$defaults_curl_maxRedirs'
			readonly LFS_CURL_RETRIES='$defaults_curl_retries'
			readonly LFS_CURL_SUPPORTS_NETRC_OPTION='$defaults_curl_supportsNetrcFileOption'
			
			readonly LFS_BINARY_curl='$(file_pathToBinary curl)'
			readonly fileName='$fileName'
			readonly verb='$verb'
			readonly url='$url'
			readonly referer='$referer'
			readonly fileName='$fileName'
			readonly compression='$compression'
			readonly continueAt=$continueAt
		EOF
		
		cat "$distribution_snippetsPath"/*.download.snippet 2>/dev/null || true
		
		cat <<-'EOF'
			curl_download '$LFS_BINARY_curl' '$verb' '$url' '$referer' '$fileName' '$compression' $continueAt
		EOF
	} >"$downloadScript"
	
	chmod +x "$downloadScript"
	
	make_addTargetDownloadItem "no"
}

function make_verifyTarget()
{
	local parentPath
	local fileName
	local cacheParentPath
	local downloadFilePath
	make_commonVariables
	
	local -r verifyScript="$cacheParentPath"/"$fileName".verify
	if [ -e "$verifyScript" ]; then
		rm -rf "$verifyScript"
	fi
	
	{
		cat <<-EOF
			#!$(file_pathToBinary bash)
			set -e
		
			function $(declare -f lfs_dirname)
		
			function $(declare -f lfs_basename)
		
			function $(declare -f lfs_findOurNameAndPath)
		
			lfs_findOurNameAndPath
		
			readonly LFS_BINARY_stat='$(file_pathToBinary stat)'
		
			readonly LFS_BINARY_md5='$(file_pathToBinary md5sum)'
		
			readonly LFS_BINARY_sha1='$(file_pathToBinary sha1sum)'
		
			readonly LFS_BINARY_sha224='$(file_pathToBinary sha224sum)'
		
			readonly LFS_BINARY_sha256='$(file_pathToBinary sha256sum)'
		
			readonly LFS_BINARY_sha384='$(file_pathToBinary sha384sum)'
		
			readonly LFS_BINARY_sha512='$(file_pathToBinary sha512sum)'
		
			readonly LFS_DOWNLOAD_FILENAME='$fileName'
		
		EOF
		
		cat "$distribution_snippetsPath"/*.verify.snippet 2>/dev/null || true
		
		if [ $size -ne -1 ]; then
			echo -ne "verifySize $size"
		fi
		
		local algorithm
		for algorithm in md5 sha1 sha224 sha256 sha384 sha512
		do
			if [ -n "${!algorithm}" ]; then
				echo -ne "verifyHash $algorithm ${!algorithm}"
			fi
		done
	} >"$verifyScript"
	
	chmod +x "$verifyScript"
	
	make_addTargetVerifyItem
}

function make_finish()
{
	# TODO: Add a CA download section, so that we can use CAs...
	
	cat <<-EOF
		download: ${make_targetsDownload[@]}
		
		verify: ${make_targetsVerify[@]}
		
		build :${make_targetsBuild[@]}
		
		.PHONY: all download verify build ${make_targetsPhony[@]}
		
	EOF
}